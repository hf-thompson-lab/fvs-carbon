---
title: "11_CFIGrowOnly"
output: html_document
---

# Setup

```{r setup, include=FALSE}
suppressPackageStartupMessages({
  library(targets)
  library(tarchetypes)
  library(tidyverse)
  library(readxl)
  library(terra)
  library(measurements)
})
tar_source()
```

## Load targets results from other documents

```{r load tar objects}
tar_load(fiadb)
tar_load(fvsne_states)
tar_load(species_crosswalk)
tar_load(nrsgro_srvy_summary)
tar_load(nrshrv_plot)
tar_load(nrshrv_plot_stats)
tar_load(fvs_num_partitions)
tar_load(fvs_partition)
tar_load(fvs_randseed)
```

## Preload targets results from this document

When tar_make() has already built the objects defined in this document,
run this block to pre-load them. You can then skip running ```{targets} blocks.

```{r load tar objects defined here, eval = FALSE}
get_this_rmd_file() |>
  tar_objects_defined_in_rmd() |>
  tar_load()
```


# Stands

Use the raw data from Department of Conservation & Recreation (DCR) Office of Watershed Management, Division of Water Supply Protection (DWSP)'s Continuous Forest Inventory (CFI).

We need stands (plots), visits (inventories), disturbances, and the lookup
table for disturbance codes.

In addition, (A. Barker Plotkin, et al. 2025) did a thorough analysis of the CFI data,
identifying 283 plots that were consistently surveyed and not relocated
from 1970 - 2020. We follow ABP where possible for this analysis.

```{targets cfiabp_trees}
tarchetypes::tar_file_read(
  cfiabp_trees,
  "data/raw/DWSP_CFI/trees283-6-defpropasp.csv",
  read_csv(!!.x)
)
```

```{targets tblDWSPCFIPlotsComplete}
tarchetypes::tar_file_read(
  tblDWSPCFIPlotsComplete,
  "data/raw/DWSP_CFI/tblDWSPCFIPlotsComplete.xlsx",
  read_excel(!!.x)
)
```

```{targets tblSuppPlotDisturbanceCodes}
tarchetypes::tar_file_read(
  tblSuppPlotDisturbanceCodes,
  "data/raw/DWSP_CFI/tblSuppPlotDisturbanceCodes.xlsx",
  read_excel(!!.x)
)
```

```{targets tblDWSPCFIPlotVisitDisturbances}
tarchetypes::tar_file_read(
  tblDWSPCFIPlotVisitDisturbances,
  "data/raw/DWSP_CFI/tblDWSPCFIPlotVisitDisturbances.xlsx",
  read_excel(!!.x) |>
    # Fix column name
    rename(
      PlotVisitDisturbanceYearCorrected = PlotVisitDisturbandYearCorrected,
      MasterPlotVisitID = PlotVisitID
    ) |>
    left_join(
      tblSuppPlotDisturbanceCodes |>
        select(DisturbanceCode, DisturbanceDesc),
      by = join_by(PlotVisitDisturbanceCode == DisturbanceCode)
    ) |>
    mutate(
      DisturbanceDesc = as.factor(DisturbanceDesc)
    )
)
```

```{targets tblDWSPCFIPlotVisitsComplete}
tarchetypes::tar_file_read(
  tblDWSPCFIPlotVisitsComplete,
  "data/raw/DWSP_CFI/tblDWSPCFIPlotVisitsComplete.xlsx",
  read_excel(!!.x)
)
```

```{targets tblSuppTreeStatusCodes}
tarchetypes::tar_file_read(
  tblSuppTreeStatusCodes,
  "data/raw/DWSP_CFI/tblSuppTreeStatusCodes.xlsx",
  read_excel(
    !!.x,
    col_types = c(
      "numeric", "text", "numeric",
      "numeric", "numeric", "numeric",
      "numeric", "numeric", "numeric",
      "numeric", "numeric", "numeric",
      "numeric", "numeric", "numeric",
      "numeric", "numeric", "numeric",
      "numeric", "numeric"
    )
  )
)

```

```{targets qryDWSPCFIPlotVisitTreeDetail}
tarchetypes::tar_file_read(
  qryDWSPCFIPlotVisitTreeDetail,
  "data/raw/DWSP_CFI/qryDWSPCFIPlotVisitTreeDetail_Partial_HF.xlsx",
  read_excel(!!.x) |>
    # Fix column names
    rename(
      MasterTreeID = VisitMasterTreeID,
      MasterPlotVisitID = VisitIDNumberDetail
    ) |>
    # Fix column types - giving read_excel the right types causes it to hang
    mutate(
      MasterTreeID = as.numeric(MasterTreeID),
      VisitTreeNumberDetail = as.numeric(VisitTreeNumberDetail)
    ) |>
    left_join(
      tblSuppTreeStatusCodes |>
        select(StatusCode, TreeStatusDesc) |>
        rename(VisitTreeStatusCode = StatusCode),
      by = join_by(VisitTreeStatusCode)
    )
)
```

```{targets tblDWSPCFITreesComplete}
tarchetypes::tar_file_read(
  tblDWSPCFITreesComplete,
  "data/raw/DWSP_CFI/tblDWSPCFITreesComplete.xlsx",
  read_excel(!!.x)
)
```

## Elevation

LiDAR elevation maps are available from https://www.mass.gov/info-details/massgis-data-lidar-terrain-data#overview
These are in ERDAS IMAGINE (IMG) format.

Rather than download all tiles we can fetch the 31 tile index and determine
which tiles the plots are in.

```{r MassGIS DEM Tiles, eval=FALSE}
massgis_dem_tile_index <- vect(
  "data/raw/MassGIS/LIDARINDEX_DEMMOSTILES_POLY/LIDARINDEX_DEMMOSTILES_POLY.shp"
)
tblDWSPCFIPlotsComplete |>
  # Remove rows without lat/lon
  filter(!is.na(GPSLatitude) & !is.na(GPSLongitude)) |>
  # select an arbitrary row with lat/lon for each plot
  # we assume that lat/lon is consistent over time
  group_by(MasterPlotID) |>
  filter(row_number() == 1) |>
  ungroup() |>
  # Reshape the data for terra::vect()
  select(MasterPlotID, GPSLatitude, GPSLongitude) |>
  rename(
    lat = GPSLatitude,
    lon = GPSLongitude
  ) |>
  vect(crs = "EPSG:4326") |>
  # Re-project to match the tile index
  project(massgis_dem_tile_index) |>
  intersect(massgis_dem_tile_index) |>
  as.data.frame() |>
  distinct(TILE) |>
  arrange(TILE)
```

So, we need tiles 4, 12, 13 and 14.
Download those and unpack into data/raw/MassGIS.

Use terra::extract() to extract the elevation in feet for each plot from
the appropriate tile.

```{targets cfigro_plot_elevft, tar_simple = TRUE}
# Files for tile NN are named
# MassGIS/LidarElevation_YYYYtoZZZZ_NN/Lidar_Elevation_YYYYtoZZZZ_NN.img
# We'll keep this as a list and extract() each tile separately - this is
# much, MUCH faster than merging tiles with terra::merge() or terra::m
massgis_dem_tiles <- lapply(
  list.files("data/raw/MassGIS", pattern = "Lidar_Elevation_*"),
  \(tile) { rast(file.path("data/raw/MassGIS", tile, paste0(tile, ".img"))) }
)

tmp_plot_location <- tblDWSPCFIPlotsComplete |>
  # Remove rows without lat/lon
  filter(!is.na(GPSLatitude) & !is.na(GPSLongitude)) |>
  # select an arbitrary row with lat/lon for each plot
  # we assume that lat/lon is consistent over time
  group_by(MasterPlotID) |>
  filter(row_number() == 1) |>
  ungroup() |>
  # Reshape the data for terra::vect()
  select(MasterPlotID, GPSLatitude, GPSLongitude) |>
  rename(
    lat = GPSLatitude,
    lon = GPSLongitude
  ) |>
  vect(crs = "EPSG:4326") |>
  # Match the projection of the first tile
  project(massgis_dem_tiles[[1]])

# Build a dataframe with two columns:
# MasterPlotID, ELEVFT
# with one row per MasterPlotID
as.data.frame(tmp_plot_location) |>
  mutate(
    # Call extract() on each available tile; for plots that overlap
    # with that tile, we'll get back elevation, otherwise NA.
    # Coalesce across tiles to get the non-NA elevation for
    # each plot.
    ELEVFT = do.call(
      coalesce,
      lapply(massgis_dem_tiles, \(x) extract(x, tmp_plot_location)$FEET)
    )
  )
```

## County

MA county data is available from https://www.mass.gov/info-details/massgis-data-counties

Download those and unpack into data/raw/MassGIS/counties.

Use terra::intersect() to extract the county for each plot.

```{targets cfigro_plot_county, tar_simple = TRUE}
massgis_county <- vect("data/raw/MassGIS/counties/COUNTIES_POLY.shp")

tmp_countycd <- fia_tbl(fiadb, "COUNTY", \(.data, con) {
  .data |>
    filter(STATECD == 25) # Massachusetts has STATECD == 25
}) |>
  mutate(COUNTY = toupper(COUNTYNM)) |>
  select(COUNTY, COUNTYCD, STATECD)

tblDWSPCFIPlotsComplete |>
  # Remove rows without lat/lon
  filter(!is.na(GPSLatitude) & !is.na(GPSLongitude)) |>
  # select an arbitrary row with lat/lon for each plot
  # we assume that lat/lon is consistent over time
  group_by(MasterPlotID) |>
  filter(row_number() == 1) |>
  ungroup() |>
  # Reshape the data for terra::vect()
  select(MasterPlotID, GPSLatitude, GPSLongitude) |>
  rename(
    lat = GPSLatitude,
    lon = GPSLongitude
  ) |>
  vect(crs = "EPSG:4326") |>
  # Match the projection of the first tile
  project(massgis_county) |>
  intersect(massgis_county) |>
  as.data.frame() |>
  select(MasterPlotID, COUNTY) |>
  left_join(
    tmp_countycd,
    by = join_by(COUNTY)
  )
```

### FVS_LOCATION

While we're here, FVS wants a location, which is the nearest national forest.

We do this by:
1. Finding the geographic center of the Quabbin plots;
2. Finding the FIA plot closest to that geographic center;
3. Looking up the FVS_LOC_CD from that plot.

FVS national forests are far apart, so all the Quabbin plots will have
the same national forest.

```{r fvs location, eval = FALSE}
geo_ctr <- cfigro_plot |>
  group_by() |>
  summarize(
    lat_ctr = mean(LATITUDE, na.rm = TRUE),
    lon_ctr = mean(LONGITUDE, na.rm = TRUE)
  ) |>
  ungroup()
lat_ctr <- as.numeric(geo_ctr[["lat_ctr"]])
lon_ctr <- as.numeric(geo_ctr[["lon_ctr"]])

fia_tbl(fiadb, "PLOTGEOM", \(.data, con) {
  .data |>
    # We only need the first instance of each plot
    group_by(STATECD, COUNTYCD, PLOT) |>
    filter(row_number() == 1) |>
    ungroup() |>
    mutate(
      LAT_DELTA = abs(LAT - lat_ctr),
      LON_DELTA = abs(LON - lon_ctr),
      MANHATTAN = LAT_DELTA + LON_DELTA
    ) |>
    # The point with the shortest Euclidean distance will have Manhattan
    # distance less than twice the minimum Manhattan distance. We could
    # find a tighter upper bound, but there won't be many within 2 so
    # this is fine.
    filter(MANHATTAN < 2 * min(MANHATTAN, na.rm = TRUE)) |>
    mutate(DIST = sqrt(LAT_DELTA^2 + LON_DELTA^2)) |>
    arrange(DIST) |>
    head(1) |>
    left_join(
      tbl(con, "REF_FVS_LOC_NAME") |>
        select(FVS_LOC_CD, FVS_LOC_CD_NAME),
      by = join_by(FVS_LOC_CD)
    ) |>
    select(FVS_LOC_CD, FVS_LOC_CD_NAME)
})
```

FVS location 922, White Mountain National Forest

## Watershed

The DCR Division of Water Supply Protection (DWSP) maintains CFI plots
in the various reservoir watersheds as a means to manage water quality.

The plots in the Quabbin watershed (Watershed == 1) have a particularly
long history of high-quality data collection and responsible harvest, so
we will focus on just this watershed.

ABP plots are filtered to the Quabbin watershed.

## Relocation

Many plots were relocated prior to 1970, while retaining the same
MasterPlotID. To avoid analysis across this disjunction in trees,
we restrict analysis to 1970 and after.

ABP trees are filtered to non-relocated plot visits.

## Harvest

We would like to follow the FIA definition of harvest:

> 2.5.44 TRTCD1
> ... The area affected by the treatment must be at least 1 acre in size.

Sadly, we don't have access to the area affected.

For each tree, however, we do have access to information on whether it was cut.

FIA also defines harvest as:

> Appendix H: Damage Agent Codes and Thresholds
> 71000, Harvest, Removal of 10% cubic volume.

We likewise do not have volume, but can approximate this.

### FIA Observed

Question: is "Harvest == removal of >= 10% of biomass" consistent with what
is recorded in FIA? We have noted previously that FIA may mark a plot as
harvested when no trees are cut, and may mark a plot as not harvested when
many of its trees are cut, so cutting is an imperfect predictor of fia harvest.

FIA doesn't record biomass, but does record carbon, which is a good proxy.

```{r fia havest analysis, eval=FALSE}
# Sum the carbon of trees that were live pre-harvest
pre_harvest_carbon <- fia_trees(
    fiadb,
    nrshrv_plot_stats |> filter(PRE_HARVEST == 1)
  ) |>
  filter(STATUSCD == 1) |>
  filter_add_stand_id() |>
  select(STAND_ID, CARBON_AG, DIA, TPA_UNADJ) |>
  group_by(STAND_ID) |>
  summarize(
    CARBON_AG = sum(CARBON_AG, na.rm = TRUE),
    BALIVE_AG = sum(pi * (DIA / 2)^2, na.rm = TRUE)
  ) |>
  ungroup()

# Harvested trees don't get biomass, so we need to find their
# previous selves and get the biomass from there.
harvested_carbon <- fia_trees_by_cn(
    fiadb,
    fia_trees_filtered(
      fiadb,
      nrshrv_plot_stats |> filter(HARVEST == 1),
      \(.data, con) {
        .data |>
          filter(STATUSCD == 3) |>
          select(PREV_TRE_CN) |>
          rename(CN = PREV_TRE_CN)
      }
    )
  ) |>
  filter_add_stand_id() |>
  select(STAND_ID, CARBON_AG, DIA, TPA_UNADJ) |>
  group_by(STAND_ID) |>
  summarize(
    CARBON_HRV = sum(CARBON_AG, na.rm = TRUE),
    BALIVE_HRV = sum(pi * (DIA / 2)^2, na.rm = TRUE)
  ) |>
  ungroup()

fia_harvest_intensity <- pre_harvest_carbon |>
  inner_join(harvested_carbon, by = join_by(STAND_ID)) |>
  mutate(
    CARBON_PCT = 100 * CARBON_HRV / CARBON_AG,
    BALIVE_PCT = 100 * BALIVE_HRV / BALIVE_AG
  )

fia_harvest_intensity |>
  ggplot(aes(CARBON_PCT)) +
  geom_histogram(binwidth = 5) +
  geom_vline(xintercept = 10) +
  theme_bw() +
  ggtitle("Carbon Removal % in FIA harvested plots")

fia_harvest_intensity |>
  ggplot(aes(BALIVE_PCT)) +
  geom_histogram(binwidth = 5) +
  geom_vline(xintercept = 10) +
  theme_bw() +
  ggtitle("Basal Area Removal % in FIA harvested plots")

```

So, the vast majority of harvest is >= 10% of carbon. The distribution of
removal of basal area is about the same, so we'll use %BA removed as a proxy.

### DWSP CFI Tree Status

Let's look at individual tree status to help understand plot status:

```{r plot cfi tree status code, eval = FALSE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_abp(cfiabp_trees) |>
  mutate(TreeStatusDesc = ordered(
    TreeStatusDesc,
    levels = c("Live tree >=5.6\"", "standing dead", "fallen dead", "Out of population")
  )) |>
  ggplot(aes(VisitCycle, fill = fct_rev(TreeStatusDesc))) +
  geom_bar(position = "stack") +
  scale_fill_viridis_d(name = "Tree Status") +
  theme_bw() +
  ggtitle("DWSP CFI Tree Status by Visit Cycle") +
  ylab("Number of Trees") +
  xlab("Visit Cycle")
```

So TreeStatusDesc uses codes 1-4, back-propagated to prior visit cycles.

### ABP 2025 Tree Status

```{r plot abp tree status code, eval = FALSE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_abp(cfiabp_trees) |>
  mutate(
    Status6 = if_else(is.na(Status6), "X", Status6),
    StatusDesc = case_match(
      Status6,
      "L" ~ "Live",
      "R" ~ "Recruit",
      "D" ~ "Dead",
      "C" ~ "Cut",
      "X" ~ "Out of Population"
    ),
    StatusDesc = ordered(
      StatusDesc,
      levels = c("Recruit", "Live", "Dead", "Cut", "Out of Population")
    )
  ) |>
  ggplot(aes(VisitCycle, fill = fct_rev(StatusDesc))) +
  geom_bar(position = "stack") +
  scale_fill_viridis_d(name = "Tree Status") +
  theme_bw() +
  ggtitle("ABP 2025 Tree Status by Visit Cycle") +
  ylab("Number of Trees") +
  xlab("Visit Cycle")
```

### FIA vs. CFI Harvest

CFI defines CutAnyTime, which presumably includes pre-1970 harvest.
CutAnyTime seems to mean CutAnyTimePreviously, since individual plots
have multiple values.

We compute two harvest indicators:
- FIA Harvest - is more than 10% of the BA in "Cut" trees
- CFI Harvest - is CutSinceLastVisit ever TRUE

```{targets cfigro_plot_harvested, tar_simple = TRUE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_abp(cfiabp_trees) |>
  cfi_harvested()
```


```{r plot cfigro_plot_harvested, eval = FALSE}
cfigro_plot_harvested |>
  mutate(
    HarvestType = case_when(
      FIAHarvested & CFIHarvested ~ "Both",
      FIAHarvested ~ "FIA",
      CFIHarvested ~ "CFI",
      .default = "Neither"
    )
  ) |>
  ggplot(aes(HarvestType)) +
  geom_bar() +
  geom_text(aes(y = after_stat(count + 5), label = after_stat(count)), stat = "count") +
  theme_bw() +
  ggtitle("FIA vs CFI Plot Harvest Status") +
  ylab("Number of Plots")
```

Defined in cfi_harvested()

## Disturbance

We would like to follow the FIA definition of disturbance:

> 2.5.38 DSTRBCD1
>
> The area affected by the disturbance must be at least 1 acre in size. A
> significant level of disturbance (mortality or damage to 25 percent of the trees
> in the condition) is required.

Sadly, we don't have access to the area affected, or to damage separate from
mortality.

CFI does provide a disturbance flag, and starting in 2010 a disturbance
intensity.

Disturbance Severity code:

- 1 - Light
- 2 - Moderate
- 3 - Severe

Ignoring light disturbance seems in-line with FIA definition, so we will
flag plots with Moderate to Severe disturbance.

Notable disturbance codes:

- 0: None
- 10: Harvest Cut

It looks like disturbances > 10 are not currently used. We also wish to
distinguish between harvest and other disturbance, so we won't mark things
with distrubance code 10 as disturbed.

Note that we need PlotVisits to get from Disturbance to Plots.

### Harvest vs. Non-Harvest Disturbance Types

```{r disturbance types, eval = FALSE}
tblSuppPlotDisturbanceCodes |>
  mutate(DisturbanceCategory = case_when(
    DisturbanceCode == 0 ~ "None",
    DisturbanceCode %in% c(8, 9, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22) ~
      "Harvest Related",
    .default = "Non-Harvest"
    )
  ) |>
  select(DisturbanceCode, DisturbanceCategory, DisturbanceDesc)
```

### Disturbance History

```{r plot disturbance type, eval = FALSE}
tblDWSPCFIPlotVisitDisturbances |>
  left_join(
    tblDWSPCFIPlotVisitsComplete |>
      distinct(MasterPlotVisitID, MasterPlotID, VisitYear, VisitCycle),
    by = join_by(MasterPlotVisitID)
  ) |>
  # Remove harvest and harvest-related disturbances
  filter(!PlotVisitDisturbanceCode %in% c(0, 8, 9, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22)) |>
  filter(
    PlotVisitDisturbanceYearCorrected >= VisitYear - 10 &
      PlotVisitDisturbanceYearCorrected < 9999 &
      (is.na(PlotVisitDisturbanceSeverity) | PlotVisitDisturbanceSeverity > 1)
  ) |>
  inner_join(
    cfiabp_trees |> distinct(MasterPlotID, VisitCycle),
    by = join_by(MasterPlotID, VisitCycle)
  ) |>
  mutate(DisturbanceDesc = factor(DisturbanceDesc)) |>
  ggplot(aes(PlotVisitDisturbanceYearCorrected, fill = DisturbanceDesc)) +
  geom_bar() +
  ggtitle("CFI Plot Disturbance Type by Year") +
  xlab("Year of Disturbance") +
  ylab("Number of Plots") +
  theme_bw()
```

```{r cfi plot disturbance history, eval = FALSE}
plotNum <- cfiabp_trees |>
  distinct(MasterPlotID) |>
  arrange(MasterPlotID) |>
  mutate(plot_num = row_number())

tblDWSPCFIPlotVisitDisturbances |>
  left_join(
    tblDWSPCFIPlotVisitsComplete |>
      distinct(MasterPlotVisitID, MasterPlotID, VisitYear, VisitCycle),
    by = join_by(MasterPlotVisitID)
  ) |>
  filter(PlotVisitDisturbanceCode != 0) |>
  # Remove harvest and harvest-related disturbances
  #mutate(PlotVisitDisturbanceCode = if_else(PlotVisitDisturbanceCode %in% c(8, 9, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22), 9, PlotVisitDisturbanceCode)) |>
  filter(
    PlotVisitDisturbanceYearCorrected >= VisitYear - 10 &
      #PlotVisitDisturbanceYearCorrected >= 1970 &
      PlotVisitDisturbanceYearCorrected < 9999 &
      (is.na(PlotVisitDisturbanceSeverity) | PlotVisitDisturbanceSeverity > 1)
  ) |>
  inner_join(
    cfiabp_trees |> distinct(MasterPlotID, VisitCycle),
    by = join_by(MasterPlotID, VisitCycle)
  ) |>
  left_join(
    plotNum,
    by = join_by(MasterPlotID)
  ) |>
  mutate(DisturbanceDesc = factor(DisturbanceDesc)) |>
  full_join(
    expand_grid(plot_num = 1:283, PlotVisitDisturbanceYearCorrected = 1960:2021),
    by = join_by(plot_num, PlotVisitDisturbanceYearCorrected)
  ) |>
  group_by(plot_num) |>
  arrange(PlotVisitDisturbanceYearCorrected) |>
  fill(DisturbanceDesc, .direction = "down") |>
  ungroup() |>
  filter(!is.na(DisturbanceDesc)) |>
  ggplot(aes(PlotVisitDisturbanceYearCorrected, plot_num, color = DisturbanceDesc)) +
  geom_point() +
  scale_y_continuous(breaks = 0:6 * 50, minor_breaks = 1:30 * 10) +
  scale_color_discrete(name = "Most Recent\nDisturbance") +
  ggtitle("Quabbin Plots CFI Disturbance") +
  xlab("Year") +
  ylab("Plot") +
  theme_bw()
```

### CFI Plot Disturbance

```{targets cfigro_plot_disturbed, tar_simple = TRUE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_abp(cfiabp_trees) |>
  cfi_disturbed(tblDWSPCFIPlotVisitDisturbances)
```

```{r plot cfi plot disturbance, eval = FALSE}
cfigro_plot_disturbed |>
  ggplot(aes(CFIDisturbed)) +
  geom_bar()
```

So, how many plots are unharvested and undisturbed?

```{r plot cfi status, eval = FALSE}
cfiabp_trees |>
  distinct(MasterPlotID) |>
  left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
  left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
  mutate(
    Status = case_when(
      FIAHarvested & CFIDisturbed ~ "Harvested & Disturbed",
      FIAHarvested ~ "Harvested",
      CFIDisturbed ~ "Disturbed",
      .default = "Neither"
    )
  ) |>
  ggplot(aes(Status)) +
  geom_bar() +
  geom_text(aes(y = after_stat(count + 5), label = after_stat(count)), stat = "count") +
  theme_bw() +
  ggtitle("CFI Plots by Status") +
  ylab("Number of Plots")
```



### FIA Disturbance

FIA marks a plot as disturbed if more than an acre is impacted, and >25% of
stems in that acre show damage or mortality.

Using ">25% mortality", we get many fewer disturbed plots:

```{r plot fia disturbance, eval = FALSE}
cfigro_plot_disturbed |>
  ggplot(aes(FIADisturbed)) +
  geom_bar()
```


Using this definition, how many plots are neither harvested nor disturbed?

So, how many plots are unharvested and undisturbed by this metric?

```{r plot fia status, eval = FALSE}
cfiabp_trees |>
  distinct(MasterPlotID) |>
  left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
  left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
  mutate(
    Status = case_when(
      FIAHarvested & FIADisturbed ~ "Harvested & Disturbed",
      FIAHarvested ~ "Harvested",
      FIADisturbed ~ "Disturbed",
      .default = "Neither"
    )
  ) |>
  ggplot(aes(Status)) +
  geom_bar() +
  geom_text(aes(y = after_stat(count + 5), label = after_stat(count)), stat = "count") +
  theme_bw() +
  ggtitle("CFI Plots by FIA Status") +
  ylab("Number of Plots")
```

### Longest Undisturbed Period


```{r fia plot disturbance history, eval = FALSE}
tblDWSPCFIPlotVisitDisturbances |>
  left_join(
    tblDWSPCFIPlotVisitsComplete |>
      distinct(MasterPlotVisitID, MasterPlotID, VisitYear, VisitCycle),
    by = join_by(MasterPlotVisitID)
  ) |>
  # Remove harvest and harvest-related disturbances
  # filter(!PlotVisitDisturbanceCode %in% c(8, 9, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22)) |>
  filter(
    PlotVisitDisturbanceYearCorrected >= VisitYear - 10 &
      PlotVisitDisturbanceYearCorrected >= 1970 &
      PlotVisitDisturbanceYearCorrected < 9999 &
      (is.na(PlotVisitDisturbanceSeverity) | PlotVisitDisturbanceSeverity > 1)
  ) |>
  full_join(
    cfiabp_trees |> distinct(MasterPlotID, VisitCycle),
    by = join_by(MasterPlotID, VisitCycle)
  ) |>
  inner_join(
    cfiabp_trees |> distinct(MasterPlotID, VisitCycle),
    by = join_by(MasterPlotID, VisitCycle)
  ) |>
  mutate(PlotVisitDisturbanceCode = replace_na(PlotVisitDisturbanceCode, 0)) |>
  group_by(MasterPlotID, VisitCycle) |>
  summarize(PlotVisitDisturbanceCode = max(PlotVisitDisturbanceCode, na.rm = TRUE), .groups = "drop") |>
  mutate(
    undisturbed_interval = if_else(
      PlotVisitDisturbanceCode > 0, 0,
      if_else(
        VisitCycle == 1970, 1, NA
      )
    )
  ) |>
  group_by(MasterPlotID) |>
  arrange(VisitCycle) |>
  mutate(
    undisturbed_interval = case_when(
      !is.na(undisturbed_interval) ~ undisturbed_interval,
      VisitCycle == 1980 ~ lag(undisturbed_interval) + 1
    )
  ) |>
  mutate(
    undisturbed_interval = case_when(
      !is.na(undisturbed_interval) ~ undisturbed_interval,
      VisitCycle == 1990 ~ lag(undisturbed_interval) + 1
    )
  ) |>
  mutate(
    undisturbed_interval = case_when(
      !is.na(undisturbed_interval) ~ undisturbed_interval,
      VisitCycle == 2000 ~ lag(undisturbed_interval) + 1
    )
  ) |>
  mutate(
    undisturbed_interval = case_when(
      !is.na(undisturbed_interval) ~ undisturbed_interval,
      VisitCycle == 2010 ~ lag(undisturbed_interval) + 1
    )
  ) |>
    mutate(
    undisturbed_interval = case_when(
      !is.na(undisturbed_interval) ~ undisturbed_interval,
      VisitCycle == 2020 ~ lag(undisturbed_interval) + 1
    )
  ) |>
  ungroup() |>
  group_by(MasterPlotID) |>
  summarize(MaxUndisturbInterval = max(undisturbed_interval), .groups = "drop") |>
  filter(!is.na(MaxUndisturbInterval)) |>
  ggplot(aes(MaxUndisturbInterval)) +
  geom_bar() +
  theme_bw() +
  ggtitle("Number of Plots by Undisturbed Interval") +
  ylab("Number of Plots") +
  xlab("Visits witout disturbance")

```

## Break Diameter

At what diameter do trees ingrow?

DSWP_CFI_METADATA_Appendix_Final, table 22B Tree Status Codes, shows the
varied history of break diameter:
- >= 5.6"
- > 4.9" (>= 5.0")
- > 5.5" (>= 5.6")
- > 5.9" (>= 6.0")


```{r ingrowth diameter over time, eval = FALSE}
qryDWSPCFIPlotVisitTreeDetail |>
  filter(VisitTreeDIAM > 0) |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
  left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
  mutate(IngrowthClass = case_when(
    VisitTreeDIAM < 5 ~ "< 5\"",
    VisitTreeDIAM < 5.6 ~ "< 5.6\"",
    VisitTreeDIAM < 6.0 ~ "< 6\""
  )) |>
  filter(!is.na(IngrowthClass)) |>
  ggplot(aes(VisitTreeDIAM)) +
  geom_histogram(binwidth = 0.1) +
  scale_y_continuous(transform = "log10") +
  coord_cartesian(xlim = c(4.5, 6.0))
```

Minimum diameter is 4.5" - this is important for BRK_DBH - trees smaller
than BRK_DBH will be on the microplot, and will get the microplot TPA
multiplier (385), rather than the plot multiplier (5). There is a history
of using different diameters in different CFI inventories.

From 1970 - 2020, only 2 trees establish on grow-only plots with DIAM < 5.6".

We will use 5" as BRK_DBH, and filter out trees with diameter < 5.

## Grow-Only vs. Harvested vs. Disturbed

How distinct are grow-only, disturbed, harvested and harvested/disturbed plots?

```{r plot comparison by status, eval = FALSE}
tmp_trees <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  filter(VisitCycle == 1970) |>
  filter(cfi_status_live(VisitTreeStatusCode)) |> # Only Live Trees
  left_join(
    species_crosswalk |> select(SPCD, SCIENTIFIC_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    TPA = 1,
    BA = pi * (VisitTreeDIAM / 2)^2
  )

tmp_by_quabbin <- tmp_trees |>
  group_by() |>
  summarize(
    TPA = sum(TPA, na.rm = TRUE),
    BA = sum(BA, na.rm = TRUE),
    .groups = "drop"
  )

tmp_by_species <- tmp_trees |>
  group_by(SCIENTIFIC_NAME) |>
  summarize(
    TPA = sum(TPA, na.rm = TRUE),
    BA = sum(BA, na.rm = TRUE),
    .groups = "drop"
  )

tmp_by_plot <- tmp_trees |>
  group_by(MasterPlotID) |>
  summarize(
    TPA = sum(TPA, na.rm = TRUE),
    BA = sum(BA, na.rm = TRUE),
    .groups = "drop"
  )

tmp_top_species <- tmp_by_species |>
  cross_join(tmp_by_quabbin |> select(BA_Total = BA)) |>
  mutate(BA_Frac = BA / BA_Total) |>
  filter(BA_Frac > 0.1)

tmp_plot_species <- tmp_trees |>
  left_join(
    tmp_by_plot |>
      select(MasterPlotID, BA_Plot = BA),
    by = join_by(MasterPlotID)
  ) |>
  group_by(MasterPlotID, SCIENTIFIC_NAME) |>
  mutate(BA_Frac = sum(BA, na.rm = TRUE) / BA_Plot) |>
  ungroup() |>
  filter(BA_Frac > 0.1) |>
  filter(SCIENTIFIC_NAME %in% tmp_top_species$SCIENTIFIC_NAME) |>
  distinct(MasterPlotID, SCIENTIFIC_NAME) |>
  group_by(MasterPlotID) |>
  summarize(
    Species = do.call(
      paste,
      append(sort(SCIENTIFIC_NAME), list(sep = ", "))
    ),
    .groups = "drop"
  )

tmp_trees |>
  group_by(MasterPlotID) |>
  summarize(
    TPA = sum(TPA, na.rm = TRUE),
    BA = sum(BA, na.rm = TRUE),
    .groups = "drop"
  ) |>
  ungroup() |>
  left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
  left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
  left_join(tmp_plot_species, by = join_by(MasterPlotID)) |>
  mutate(
    Species = if_else(is.na(Species), "Other", Species),
    Status = case_when(
      CFIHarvested & CFIDisturbed ~ "Harvested & Disturbed",
      CFIHarvested ~ "Harvested",
      CFIDisturbed ~ "Disturbed",
      .default = "Grow-Only"
    )
  ) |>
  ggplot(aes(BA, TPA, color = Status)) +
  geom_point() +
  scale_color_manual( values = c(
    "Grow-Only" = "black",
    "Harvested" = "red",
    "Disturbed" = "royalblue",
    "Harvested & Disturbed" = "orange"
  )) +
  scale_x_continuous(transform = "log10") +
  scale_y_continuous(transform = "log10") +
  theme_bw() +
  ggtitle("CFI Plot Overview") +
  xlab(bquote("Basal Area" ~ (ft^2))) +
  ylab(bquote("Population" ~ (stems))) +
  facet_wrap("Species")
```

## Final Formatting

put it in the right shape for FVS.
When FVS processes a stand from FIA data, it says things like
(omitting WAS IGNORED columns):

```
SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'

STAND-LEVEL DATA BASE READ:
  INV_YEAR:               2006 - VisitYear 
  REGION:                    9 - Keep it 9
  FOREST:                   20 - Nearest national forest / ranger district, 20 is Green Mountains
   COMPOSITE LOC:          920 - - See FVSne_Overview 3.1 Location Codes
  LOCATION:                920 - - See FVSne_Overview 3.1 Location Codes
  LONGITUDE:          -73.3379 - GPSLatitude
  LATITUDE:            41.2770 - GPSLongitude
  AGE:                      74 - ??? No Age
  ASPECT:                  6.0 - Aspect
  SLOPE:                  5.00 - Slope; CFI is probably %; FVS wants percent
  ELEVFT:                520.0 CONVERTED TO:    5.2 - join from MassGIS data
  BASAL_AREA_FACTOR:     -24.0 - plot radius for fixed-radius plot; 52.7
  INV_PLOT_SIZE:          300. - plot radius for fixed-size microplot; 6
  BRK_DBH:                 5.0 - Sapling / Tree DBH break; see above
  NUM_PLOTS:                 4 - Number of subplots; 1
  SAM_WT:          6321.345703 - Sample Weight (acres) - not used by FVS
  PHYSIO_REGION:            23 - maybe from fiadb 2.3.35 Physiographic Class; use forest type instead
  STATE:                     9 - State - fill in properly - 25
  COUNTY:                    1 - County - fill in properly - use MassGIS counties
END OF DATA BASE READ.
```

From the manual:
- Plots are 52.7' fixed-radius plots, which is 0.2 acre (0.2003011)
- Four, six-foot radius subplots are taken on each CFI pot along the cardinal directions, 26' from plot center.
- Size classes:
  - 1 - less than one foot in height
  - 2 - 1' to 4.5' in height
  - 3 - 4.5' to 1.0" DBH
  - 4 - 1" to 5" dbh
- Seedlings less than one foot in height (class 1) and thos 1' to 4.5' in height
  (class 2) are counted individually up to ten and in groups of ten (11 to 20 = 20, etc.)
  when their number exceeds ten.
- For the other sizes [sic] classes (3 and 4), individual stems are recorded.

Site index is recorded, but we don't seem to have it. We'll use the limited height
info we have to calibrate FVS.

It looks like forest type / ecoregion will be used if present

ForestTypeDesc might be available - see appendix.

STAND_CN - MasterPlotVisitID
STAND_ID - MasterPlotID
VARIANT - NE
INV_YEAR / INV_MONTH / INV_DAY - VisitMeasuredDate
LATITUDE / LONGITUDE - GPSLatitude / GPSLongitude
DATUM - NA
REGION - 20
FOREST - 920
DISTRICT - ?
ECOREGION - can maybe get this
AGE - ?
ASPECT - ASPECT
SLOPE - SLOPE
ELEVATION - ?
ELEVFT - ELEVATION
INV_PLOT_SIZE - -52.7
BRK_DBH - 5
NUM_PLOTS - 1
SITE_SPECIES - ?
SITE_INDEX - ?
SITE_INDEX_BASE_AG - ?
FOREST_TYPE_FIA - ?
STATE - 25
COUNTY - COUNTY

```{targets cfigro_plot, tar_simple = TRUE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  group_by(MasterPlotID) |>
  mutate(
    FIRST_YEAR = VisitYear,
    LAST_YEAR = max(VisitYear, na.rm = TRUE)
  ) |>
  arrange(VisitCycle) |>
  filter(row_number() == 1) |>
  ungroup() |>
  left_join(
    cfigro_plot_elevft,
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    cfigro_plot_county,
    by = join_by(MasterPlotID)
  ) |>
  mutate(
    STAND_CN = as.character(MasterPlotVisitID),
    STAND_ID = MasterPlotID,
    INV_YEAR = VisitYear,
    REGION = 9,
    FOREST = 22,
    LONGITUDE = GPSLongitude,
    LATITUDE = GPSLatitude,
    AGE = NA,
    ASPECT = Aspect,
    SLOPE = Slope,
    ELEVFT = ELEVFT,
    BASAL_AREA_FACTOR = -5, # 52.7' = 1/5 acre; negative means fixed radius
    INV_PLOT_SIZE = 385, # Microplot area, in inverse fraction of an acre
    BRK_DBH = 5, # ABP uses 6" for break diameter; see ABP 2025
    NUM_PLOTS = 1,
    SAM_WT = 0.2,
    STATE = STATECD,
    COUNTY = COUNTYCD
  ) |>
  select(
    STAND_CN, STAND_ID, INV_YEAR, REGION, STATE, COUNTY, FOREST,
    LONGITUDE, LATITUDE, ASPECT, SLOPE, ELEVFT, AGE,
    BASAL_AREA_FACTOR, INV_PLOT_SIZE, BRK_DBH, NUM_PLOTS,
    SAM_WT, FIRST_YEAR, LAST_YEAR
  )
```

# Trees

It looks like pretty much everything is in the ABP table.
When comparing current to previous status, and for diameter and 
height growth, the VisitTree* values are more densely populated
which works better for change-over-time calculations.

```
SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'
  PLOT_ID            WAS USED - MasterPlotID
  TREE_ID            WAS USED - MasterTreeID
  TREE_COUNT         WAS USED - stemsha.L6
  HISTORY            WAS USED - status.prior6 - no, use VisitTreeStatusCode, except for harvest
  SPECIES            WAS USED - genusp - swizzle through crosswalk
  DIAMETER           WAS USED - dbhcm - no, use VisitTreeDIAM
  HT                 WAS USED - VisitTreeTotalHeight
  HTTOPK             WAS USED - :-(
  CRRATIO            WAS USED - :-( - maybe in supplement; see appendix
  DAMAGE1            WAS USED - X
  SEVERITY1          WAS USED - X
  DAMAGE2            WAS USED - X
  SEVERITY2          WAS USED - X
  DAMAGE3            WAS USED - X
  SEVERITY3          WAS USED - X
  TREEVALUE          WAS USED - X - tree removal priority
  PRESCRIPTION       WAS USED - X - tree removal group
  AGE                WAS USED - X
  SLOPE              WAS USED - Slope
  ASPECT             WAS USED - Aspect
  PV_CODE            WAS USED - ecoregion? - not used
  TOPOCODE           WAS USED - ?
  SITEPREP           WAS USED - ?
  DG                 WAS USED - Diameter growth - dbh.prior.cm; no, use lag(VisitTreeDIAM)
  HTG                WAS USED - height growth - lag(VisitTreeTotalHeight)
NUMBER ROWS PROCESSED:   30
```

FVS TOPOCODE:
1 = bottom
2 = lower slope
3 = mid-slope
4 = upper slope
5 = ridge top

CFI Terrain Position:
1 = Top of slope; convex region.
2 = Upper slope; convex region at upper edge of slope.
3 = Mid-slope; uniform, fairly straight region.
4 = Bench; area of level land with slopes above and below.
5 = Lower slope; concave region at the lower edge of slope.
6 = Bottomland; horizontal region in low-lying areas, may be subject to occasional flooding.
7 = Flatland; regions not part of or related to slopes; may have minimal elevation changes - less than 5% slope.

```{targets cfigro_trees, tar_simple = TRUE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  filter(VisitTreeStatusCode != 4) |> # Skip missing trees
  cfi_abp(cfiabp_trees) |>
  group_by(MasterPlotID, MasterTreeID) |>
  arrange(VisitCycle) |>
  mutate(
    PreviousStatus6 = lag(Status6),
    PreviousDIAM = lag(VisitTreeDIAM),
    PreviousHeight = lag(VisitTreeTotalHeight)
  ) |>
  ungroup() |>
  cfi_topocode() |>
  cfi_history() |>
  left_join(
    species_crosswalk |> select(SPCD, FVS_SPCD),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    STAND_CN = as.character(MasterPlotVisitID),
    STAND_ID = MasterPlotID,
    TREE_CN = as.character(VisitTreeNumberDetail),
    TREE_ID = MasterTreeID,
    PLOT_ID = 1, # CFI does not use subplots, so all PLOT_IDs are 1
    INV_YEAR = VisitYear,
    TREE_COUNT = 1, #conv_unit(1, "acre", "ft2") / (pi * 52.7^2),
    HISTORY = HISTORY,
    SPECIES = FVS_SPCD,
    DIAMETER = VisitTreeDIAM,
    HT = VisitTreeTotalHeight,
    # HTTOPK = VisitTreeTotalHeight, # Height to top kill; we don't ahve that
    # CRRATIO            WAS USED - not available
    # DAMAGE1            WAS USED - not available
    # SEVERITY1          WAS USED - not available
    # DAMAGE2            WAS USED - not available
    # SEVERITY2          WAS USED - not available
    # DAMAGE3            WAS USED - not available
    # SEVERITY3          WAS USED - not avialable
    # TREEVALUE          WAS USED - X - tree removal priority
    # PRESCRIPTION       WAS USED - X - tree removal group
    # AGE                WAS USED - X
    SLOPE = Slope,
    ASPECT = Aspect,
    # PV_CODE            WAS USED - ecoregion? - not used
    TOPOCODE = TOPOCODE, # See EssentialFVS 5.4.1.2
    # SITEPREP           WAS USED - ?
    DG = PreviousDIAM,
    HTG = PreviousHeight
  ) |>
  select(
    STAND_CN, STAND_ID, TREE_CN, TREE_ID, PLOT_ID,
    TREE_COUNT, HISTORY, SPECIES, DIAMETER, HT,
    SLOPE, ASPECT, TOPOCODE, DG, HTG
  )
```

## DWSCFI Observations

Where does that land us in terms of growth?

Look at stand-level BA over time:

```{r plot dwscfi ba, eval = FALSE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
  left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
  filter(!CFIHarvested & !CFIDisturbed) |>
  group_by(MasterPlotID, VisitYear) |>
  summarize(BA = sum(pi * (VisitTreeDIAM/24)^2, na.rm = TRUE), .groups = "drop") |>
  mutate(
    MasterPlotID = factor(MasterPlotID),
    BA_METRIC = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")
  ) |>
  ggplot(aes(VisitYear, BA_METRIC, color = MasterPlotID)) +
  geom_line() +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none") +
  ggtitle("DCR CFI Quabbin Grow-Only Plots Observed BA") +
  ylab(bquote("BA" ~ (m^2 %.% hectare^-1)))

```


And stand-level stem density over time:

```{r plot dwscfi tpa, eval = FALSE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
  left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
  filter(!CFIHarvested & !CFIDisturbed) |>
  group_by(MasterPlotID, VisitYear) |>
  summarize(TPA = n() * conv_unit(1, "acre", "ft2") / (pi * 52.7^2), .groups = "drop") |>
  mutate(
    MasterPlotID = factor(MasterPlotID)
  ) |>
  ggplot(aes(VisitYear, TPA, color = MasterPlotID)) +
  geom_line() +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none") +
  ggtitle("DCR CFI Quabbin Grow-Only Plots Observed TPA") +
  ylab("TPA")

```


# Regeneration

TBD

# Run FVS

## FVS CFIGRO NONE

```{targets cfigro_none}
tar_target(
  cfigro_none,
  {
    # fvs_run wants a table of the form:
    # STAND_ID - arbitrary identifier for a stand
    # STAND_CN - CN for the plot
    # FIRST_YEAR - start of the projection; if this doesn't align with the actual
    #   year (MEASYEAR) of first survey, the stand will be projected from the
    #   survey year to the start of the projection.
    # LAST_YEAR - end of the projection
    timestep <- 10 # years; determined by FVSne variant
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "CFIGrowOnly"
    mgmt_id <- "NONE"
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = NULL,
      title = title,
      mgmt_id = mgmt_id,
      stands = cfigro_plot |>
        left_join(cfigro_plot_harvested, by = join_by(STAND_ID == MasterPlotID)) |>
        left_join(cfigro_plot_disturbed, by = join_by(STAND_ID == MasterPlotID)) |>
        filter(!CFIHarvested & !CFIDisturbed),
      trees = cfigro_trees,
      num_partitions = fvs_num_partitions,
      partition = fvs_partition,
      random_seed = fvs_randseed
    )
  },
  # iteration = "vector" branches execution for each partition value (see below)
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here.
  # cross() ensures that every combination of values for its arguments is processed
  # map() distributes each value of its argument to a separate sub-target (branch)
  # so cross(randseed, map(partition)) will run each partition in a separate branch,
  # and each branch will run with each value of randseed
  pattern = cross(fvs_randseed, map(fvs_partition))
)
```

## FVS CFIGRO SRVY

```{targets cfigro_srvy}
tar_target(
  cfigro_srvy,
  {
    # Find all the VisitYears for each plot,
    # and expand the plots to visit in each year
    visits <- cfiabp_trees |>
      left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
      left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
      filter(!CFIHarvested & !CFIDisturbed) |>
      distinct(MasterPlotID, VisitCycle) |>
      left_join(
        tblDWSPCFIPlotVisitsComplete |>
          select(MasterPlotID, VisitCycle, MasterPlotVisitID, VisitYear),
        by = join_by(MasterPlotID, VisitCycle)
      ) |>
      mutate(MasterPlotVisitID = as.character(MasterPlotVisitID)) |>
      select(
        STAND_CN = MasterPlotVisitID,
        STAND_ID = MasterPlotID,
        INV_YEAR = VisitYear
      )
    
    plots_for_fvs <- cfigro_plot |>
      left_join(cfigro_plot_harvested, by = join_by(STAND_ID == MasterPlotID)) |>
      left_join(cfigro_plot_disturbed, by = join_by(STAND_ID == MasterPlotID)) |>
      filter(!CFIHarvested & !CFIDisturbed) |>
      select(-STAND_CN, -INV_YEAR) |>
      full_join(visits, by = join_by(STAND_ID)) |>
      mutate(FIRST_YEAR = INV_YEAR, LAST_YEAR = INV_YEAR)

    # No establishment for survey runs

    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "CFIGrowOnly"
    mgmt_id <- "SRVY"

    # We communicate with FVS through files. FVSOnline shows a model in which
    # a "project" (the inputs and outputs of a single FVS run) live in a
    # single directory; we follow that model.
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = NULL,
      title = title,
      mgmt_id = mgmt_id,
      stands = plots_for_fvs,
      trees = cfigro_trees,
      num_partitions = fvs_num_partitions,
      partition = fvs_partition
    )
  },
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here:
  pattern = map(fvs_partition)
)
```


# Results

## Load Results

Load the output from all FVS partitions into a single dataframe

Consolidate outputs that use multiple random seeds;
average the multiple runs with different random seeds.

### CFI GrowOnly NONE

Carbon

```{targets cfigro_none_carbon, tar_simple = TRUE}
fvs_read_output(cfigro_none, "FVS_Carbon") |>
  group_by(StandID, Year) |> # Combine results from different random seeds
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    .groups = "keep"
  ) |>
  ungroup()
```

Summary

```{targets cfigro_none_summary, tar_simple = TRUE}
fvs_read_output(cfigro_none, "FVS_Summary2_East") |>
  group_by(StandID, Year) |>
  summarize(
    BA = mean(BA),
    Tpa = mean(Tpa),
    .groups = 'keep'
  ) |>
  ungroup()
```


## Load Results

Load the output from all FVS partitions into a single dataframe

Consolidate outputs that use multiple random seeds;
average the multiple runs with different random seeds.

### CFI GrowOnly SRVY

Carbon

```{targets cfigro_srvy_carbon, tar_simple = TRUE}
fvs_read_output(cfigro_srvy, "FVS_Carbon") |>
  select(StandID, Year, Aboveground_Total_Live)
```

Summary

```{targets cfigro_srvy_summary, tar_simple = TRUE}
fvs_read_output(cfigro_srvy, "FVS_Summary2_East") |>
  select(StandID, Year, BA, Tpa)
```

# Basal Area Increment

## CFIGRO SRVY BAI

```{r sanity cfigro srvy, eval = FALSE}
cfigro_srvy_summary |>
  filter(Year %% 10 == 0) |>
  mutate(BA_METRIC = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
#  filter(StandID == "10464") |>
  ggplot(aes(Year, BA_METRIC, color = StandID)) +
  geom_line() +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none") +
  ggtitle("Quabbin Grow-Only Plots Observed BA") +
  ylab(bquote("BA" ~ (m^2 %.% hectare^-1)))
```

### The Fate of Plot 10464

```{r plot 10464 ba, eval = FALSE}
cfi_raw <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  filter(MasterPlotID == 10464) |>
  filter(VisitTreeStatusCode == 1) |>
  group_by(MasterPlotID, VisitYear) |>
  summarize(
    BA = sum(pi * (VisitTreeDIAM/2)^2, na.rm = TRUE),
    Tpa = n() * 5,
    .groups = "drop"
  ) |>
  ungroup() |>
  mutate(
    StandID = factor(MasterPlotID),
    Year = VisitYear,
    Series = "CFI"
  )

cfi_fvs <- cfigro_srvy_summary |>
  filter(StandID == "10464") |>
  filter(Year %% 10 == 0) |>
  mutate(
    Series = "FVS"
  )

bind_rows(cfi_raw, cfi_fvs) |>
  ggplot(aes(Year, Tpa, fill = Series)) +
  geom_col(position = "dodge") +
  theme_bw() +
  ggtitle("CFI vs. FVS reported TPA for plot 10464") +
  ylab(bquote("TPA" ~ (trees %.% acre^-1))) +
  coord_cartesian(ylim = c(0, NA))
```

## NRSGRO SRVY BAI

Compare to NRSGrowOnly:

```{r sanity nrsgro srvy, eval = FALSE}
nrsgro_srvy_summary |>
  filter(Year %% 10 == 0) |>
  mutate(BA_METRIC = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  ggplot(aes(Year, BA_METRIC, color = StandID)) +
  geom_line() +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none") +
  ggtitle("NRS Grow-Only Plots Observed BA") +
  ylab(bquote("BA" ~ (m^2 %.% hectare^-1)))
```

## CFIGRO NONE BA

```{r sanity none, eval = FALSE}
cfigro_none_summary |>
  filter(Year < 2021) |>
  mutate(BA_METRIC = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  ggplot(aes(Year, BA_METRIC, color = StandID)) +
  geom_line() +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none") +
  ggtitle("Quabbin Grow-Only Plots Projected BA") +
  ylab(bquote("BA" ~ (m^2 %.% hectare^-1)))
```

# Projected vs. Measured

Compare FVS projected values vs. measured values

```{targets cfigro_none_proj_vs_meas, tar_simple = TRUE}
projected_carbon_tmp <- cfigro_none_carbon |>
  select(StandID, Year, Aboveground_Total_Live) |>
  rename(Projected_Carbon = Aboveground_Total_Live)

projected_ba_tmp <- cfigro_none_summary |>
  mutate(Projected_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  mutate(Projected_Tph = conv_unit(Tpa, "hectare", "acre")) |>
  select(StandID, Year, Projected_BA, Projected_Tph)

projected_tmp <- projected_carbon_tmp |>
  full_join(projected_ba_tmp, by = join_by(StandID, Year)) |>
  select(StandID, Year, Projected_Carbon, Projected_BA, Projected_Tph)

surveyed_carbon_tmp <- cfigro_srvy_carbon |>
  select(StandID, Year, Aboveground_Total_Live) |>
  rename(Measured_Carbon = Aboveground_Total_Live)

surveyed_ba_tmp <- cfigro_srvy_summary |>
  mutate(Measured_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  mutate(Measured_Tph = conv_unit(Tpa, "hectare", "acre")) |>
  select(StandID, Year, Measured_BA, Measured_Tph)

surveyed_tmp <- surveyed_carbon_tmp |>
  full_join(surveyed_ba_tmp, by = join_by(StandID, Year)) |>
  filter(!is.na(Measured_Carbon)) |> # other metrics get an extra year
  select(StandID, Year, Measured_Carbon, Measured_BA, Measured_Tph)

#cfigro_none_proj_vs_meas <- qryDWSPCFIPlotVisitTreeDetail |>
#  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
#  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
#  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
#  filter(VisitTreeStatusCode != 4) |> # Skip missing trees
#  cfi_abp(cfiabp_trees) |>
#  mutate(StandID = as.character(MasterPlotID)) |>
#  select(
#    StandID,
#    Year = VisitYear
#  ) |>
#  left_join(surveyed_tmp, by = join_by(StandID, Year)) |>
cfigro_none_proj_vs_meas <- surveyed_tmp |>
  left_join(projected_tmp, by = join_by(StandID, Year)) |>
  group_by(StandID) |>
  mutate(
    First_Year = min(Year, na.rm = TRUE),
    Last_Year = max(Year, na.rm = TRUE),
    Starting_Carbon = min(
      if_else(Year == First_Year, Measured_Carbon, NA),
      na.rm = TRUE
    ),
    Projected_Carbon_Delta = Projected_Carbon - Starting_Carbon,
    Projected_Carbon_Flux = if_else(
      Year == First_Year,
      0,
      -(Projected_Carbon_Delta / (Year - First_Year))
    ),
    Measured_Carbon_Delta = Measured_Carbon - Starting_Carbon,
    Measured_Carbon_Flux = if_else(
      Year == First_Year,
      0,
      -(Measured_Carbon_Delta / (Year - First_Year))
    ),
    Starting_BA = min(
      if_else(Year == First_Year, Measured_BA, NA),
      na.rm = TRUE
    ),
    Projected_BA_Delta = Projected_BA - Starting_BA,
    Projected_BAI = if_else(
      Year == First_Year,
      0,
      Projected_BA_Delta / (Year - First_Year)
    ),
    Measured_BA_Delta = Measured_BA - Starting_BA,
    Measured_BAI = if_else(
      Year == First_Year,
      0,
      Measured_BA_Delta / (Year - First_Year))
  ) |>
  ungroup() |>
  filter(Year == First_Year | Year == Last_Year) |>
  filter(!is.na(Projected_Carbon) & !is.na(Measured_Carbon)) |>
  mutate(Projection_Years = Year - First_Year) |>
  mutate(BA_Residual = Projected_BA - Measured_BA) |>
  mutate(BA_Error = 2 * abs(BA_Residual) / (Projected_BA + Measured_BA)) |>
  mutate(BA_Delta_Residual = Projected_BA_Delta - Measured_BA_Delta) |>
  mutate(BAI_Residual = BA_Delta_Residual / Projection_Years) |>
  mutate(Carbon_Residual = Projected_Carbon - Measured_Carbon) |>
  mutate(Carbon_Error = 2 * abs(Carbon_Residual) / (Projected_Carbon + Measured_Carbon)) |>
  mutate(Carbon_Delta_Residual = Projected_Carbon_Delta - Measured_Carbon_Delta) |>
  mutate(Carbon_Flux_Residual = Projected_Carbon_Flux - Measured_Carbon_Flux)
```


```{r plot bai density, eval = FALSE}
cfigro_none_proj_vs_meas |>
  filter(Projection_Years > 0) |>
  select(
    StandID,
    Projected_BAI,
    Measured_BAI) |>
  pivot_longer(
    cols = c("Projected_BAI", "Measured_BAI"),
    names_to = "Series",
    values_to = "BAI"
  ) |>
  ggplot(aes(BAI, fill = Series)) +
  geom_density(alpha = 0.5) +
  geom_vline(xintercept = 0, color = "black", linewidth = 0.25) +
  theme_bw() +
  xlab(bquote("Basal Area Increment" ~ (m^2 %.% ha^-1 %.% year^-1))) +
  ylab("Density") +
  scale_fill_brewer(palette="Set1") +
  ggtitle("Basal Area Increment Projection") #+
  #coord_cartesian(xlim = c(-2.5, 0))
```


```{r plot carbon flux density, eval = FALSE}
cfigro_none_proj_vs_meas |>
  filter(Projection_Years > 0) |>
  select(
    StandID,
    Projected_Carbon_Flux,
    Measured_Carbon_Flux) |>
  pivot_longer(
    cols = c("Projected_Carbon_Flux", "Measured_Carbon_Flux"),
    names_to = "Series",
    values_to = "Carbon_Flux"
  ) |>
  ggplot(aes(Carbon_Flux, fill = Series)) +
  geom_density(alpha = 0.5) +
  geom_vline(xintercept = 0, color = "black", linewidth = 0.25) +
  theme_bw() +
  xlab(bquote("Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% year^-1))) +
  ylab("Density") +
  scale_fill_brewer(palette="Set1") +
  ggtitle("Carbon Flux Projection") +
  coord_cartesian(xlim = c(-2.5, 0))
```
