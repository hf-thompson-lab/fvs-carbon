---
title: "Nunery Keeton Revisited"
author: "Nikolaus Bates-Haus"
output:
  html_document: default
  word_document: default
  pdf_document: default
editor_options:
  markdown:
    wrap: 72
---

# Setup

```{r setup, include=FALSE}
library(tidyverse)
library(reshape2) # melt()
library(RSQLite)
library(measurements) # conv_unit and conv_multiunit
library(maps)
library(pbapply) # Progress bar for long operations
options(scipen = 9) # Use integer notation for numbers under 9 digits
```

```{r source-functions}
source('R/functions.R')
```

## Use Cache

Some datasets take a long time to compute; these are normally cached and
read from cache. Set `USE_CACHE` to `FALSE` to re-compute everything, and
`TRUE` to use cached values if available.

```{r USE_CACHE}
USE_CACHE <- TRUE
```

## Species Crosswalk

Different systems use different ways of encoding species. Here's a single
crosswalk for them all.

```{r species_mixin}
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

jenkins_spgrpcd_mixin <- read_csv(
    "data/raw/FIADB_11.5.17_JENKINS_SPGRPCD.csv", 
    col_types = cols(JENKINS_SPGRPCD = col_integer())
  ) |>
  select(JENKINS_SPGRPCD, NAME) |>
  rename(JENKINS_SPGRP_NAME = NAME)

fvs_spcd_mixin <- read_csv(
    "data/raw/FVSne_Overview_Table_3.2.1.csv",
    col_types = "iiciccc"
  ) |>
  select(`FIA Code`, `Species Number`, `Species Code`) |>
  rename(
    SPCD = `FIA Code`,
    FVS_SPNO = `Species Number`,
    FVS_SPCD = `Species Code`
  )

species_mixin <- tbl(fia, 'REF_SPECIES') |>
  select(SPCD, GENUS, SPECIES, E_SPGRPCD, JENKINS_SPGRPCD, SCIENTIFIC_NAME, COMMON_NAME) |>
  left_join(
    tbl(fia, 'REF_SPECIES_GROUP') |> distinct(SPGRPCD, NAME),
    by = join_by(E_SPGRPCD == SPGRPCD)
  ) |>
  rename(SPGRPCD = E_SPGRPCD, SPGRP_NAME = NAME) |>
  collect() |>
  left_join(jenkins_spgrpcd_mixin, by = join_by(JENKINS_SPGRPCD)) |>
  left_join(fvs_spcd_mixin, by = join_by(SPCD)) |>
  # From FIADB User Guides
  # Volume Database Description (version 9.2)
  # Appendix E: Tree Species Group Codes
  # Softwoods: 1 - 24
  # Hardwoods: 25 - 48
  # Tropical and subtropical: 51 - 54
  # Urban: 55, 56
  # SPGRP_NAME often has hardwood or softwood in the name;
  # less frequently, JENKINS_SPGRP_NAME does.
  mutate(HARD_SOFT = case_when(
    SPGRPCD %in% 1:24 ~ "SOFTWOOD",
    SPGRPCD %in% 25:48 ~ "HARDWOOD",
    grepl("hardwood", SPGRP_NAME) ~ "HARDWOOD",
    grepl("softwood", SPGRP_NAME) ~ "SOFTWOOD",
    grepl("hardwood", JENKINS_SPGRP_NAME) ~ "HARDWOOD",
    grepl("softwood", JENKINS_SPGRP_NAME) ~ "SOFTWOOD",
    .default = NA
  ))

dbDisconnect(fia)

rm(fia, jenkins_spgrpcd_mixin, fvs_spcd_mixin)
```

# Grow-Only Plots in the Northeast

Find all FIA plots in the northeastern region that are grow-only, that have
a measurement year between 1999 and 2004, and have at least two measurements
between 1999 and 2024. We select 1999 becasue FIA changed
to the 4-subplot structure in 1999; we select 2004 so that we will have
at least 20 years of growth. We require two measurements so that we can compare
projected vs. actual growth between measurements.

Survey filters:

*  PLOT.MEASYEAR > 1999 - really, we want DESIGNCD (plot design) == 1
*  max(PLOT.MEASYEAR) - min(PLOT.MEASYEAR) >= 10
*  BALIVE > 0

Northeastern region:

*  SURVEY.RSCD == 24

Grow-only is described previously:

*  Only one condition: max(FIA.COND.CONDID) == 1
*  Survey was not skipped: COND.COND_STATUS_CD == 1
*  Plot was not disturbed: COND.DSTRBCD1 == 0 & COND.DSTRBCD2 == 0 & COND.DSTRBCD3 == 0
*  Plot was not treated: COND.TRTCD1 == 0 & TRTCD2 == 0 & TRTCD3 == 0

The functions in `functions.R` define these filters

Execute the filters to create a list of matching plots.

```{r plot_grow_only}
rds_file <- 'data/intermediate/plot_grow_only.rds'
if (USE_CACHE & file.exists(rds_file)) {
  plot_grow_only <- read_rds(rds_file)
} else {
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  fia_cond <- tbl(fia, 'COND') |>
    select(
      STATECD, COUNTYCD, PLOT, PLT_CN, CONDID, INVYR,
      COND_STATUS_CD, BALIVE, DSTRBCD1, DSTRBCD2, DSTRBCD3, TRTCD1, TRTCD2, TRTCD3
    )
  fia_plot <- tbl(fia, 'PLOT') |>
    # Narrow and rename columns to facilitate join
    select(CN, DESIGNCD, SRV_CN, MEASYEAR, ECOSUBCD) |>
    rename(PLT_CN = CN)
  fia_plotgeom <- tbl(fia, 'PLOTGEOM') |>
    # Narrow and rename columns to facilitate join
    select(CN, FVS_VARIANT) |>
    rename(PLT_CN = CN)
  
  plot_grow_only <- fia_cond |>
    left_join(fia_plot, by = join_by(PLT_CN)) |>
    left_join(fia_plotgeom, by = join_by(PLT_CN)) |>
    fvsne_plots_filter() |>
    modern_plots_filter() |>
    has_trees_filter() |>
    long_measurement_filter() |>
    forested_plots_filter() |>
    undisturbed_plots_filter() |>
    untreated_plots_filter() |>
    # single_condition_plots_filter() |>
    distinct(STATECD, COUNTYCD, PLOT) |>
    collect() |>
    arrange(STATECD, COUNTYCD, PLOT)
  
  dbDisconnect(fia)
  remove(fia, fia_cond, fia_plot, fia_plotgeom)
  
  write_rds(plot_grow_only, rds_file)
}
nrow(plot_grow_only)
```

Many plots have trees that are not supported by FVSne; filter to plots
where the most recent measurement shows at least 90% of basal area
is in trees supported by FVSne.

```{r}
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

fia_tree_mixin <- tbl(fia, 'tree') |>
  select(PLT_CN, SPCD, DIA)

fvs_species_mixin <- species_mixin |>
  filter(!is.na(FVS_SPCD)) |>
  select(SPCD, FVS_SPCD)

plot_fvs_frac <- tbl(fia, 'PLOT') |>
  semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(MEASYEAR == max(MEASYEAR, na.rm = TRUE)) |>
  ungroup() |>
  select(CN, STATECD, COUNTYCD, PLOT) |>
  rename(PLT_CN = CN) |>
  left_join(fia_tree_mixin, by = join_by(PLT_CN)) |>
  left_join(fvs_species_mixin, by = join_by(SPCD), copy = TRUE) |>
  mutate(DIA_FVS = if_else(!is.na(FVS_SPCD), DIA, 0.0)) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    BA_FVS = sum(6 * pi * DIA_FVS^2, na.rm = TRUE),
    BA_TOTAL = sum(6 * pi * DIA^2, na.rm = TRUE),
    .groups = "keep"
  ) |>
  ungroup() |>
  mutate(BA_FVS_FRAC = BA_FVS / BA_TOTAL) |>
  collect()

dbDisconnect(fia)

rm(fia, fia_tree_mixin, fvs_species_mixin)

# Replace plot_grow_only with the shortened list
plot_grow_only <- plot_fvs_frac |>
  filter(BA_FVS_FRAC > 0.9) |>
  select(STATECD, COUNTYCD, PLOT)
```


## Locations

Where are these plots?

Fetch plots with measyear, invyr, latitude, longitude, and state information.

```{r plot_location}
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

# Survey has the research station code
fia_survey <- tbl(fia, 'SURVEY') |>
  select(CN, RSCD) |>
  rename(SRV_CN = CN)

# plot has invyr, measyr, lat and lon
fia_plot <- tbl(fia, 'PLOT') |>
  # Narrow and rename columns to facilitate join
  select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR, SRV_CN, ECOSUBCD, LAT, LON)

# research station has state name and abbreviation
fia_ref_research_station <- tbl(fia, 'REF_RESEARCH_STATION') |>
  select(STATECD, STATE_NAME, STATE_ABBR)

plot_location <- fia_plot |>
  semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
  left_join(fia_survey, by = join_by(SRV_CN)) |>
  left_join(fia_ref_research_station, by = join_by(STATECD)) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  # Pick just the first inventory year
  filter(min_rank(INVYR) == 1) |> 
  ungroup() |>
  collect() |>
  rename(
    long = LON,
    lat = LAT
  ) |>
  mutate(group = sprintf('%02d%03d%05d', STATECD, COUNTYCD, PLOT))

dbDisconnect(fia)
remove(fia, fia_plot, fia_survey, fia_ref_research_station)
```

How many plots are in each state?

```{r state_plot_counts}
state_plot_counts <- plot_location |>
  group_by(STATE_NAME) |>
  summarize(COUNT = n()) |>
  ungroup() |>
  arrange(desc(COUNT))
knitr::kable(state_plot_counts)
```

Show the plots on a map.

```{r map_states}
northeastern_states <- plot_location |>
  distinct(STATE_NAME) |>
  mutate(region = str_to_lower(STATE_NAME))
map_states <- map_data('state', northeastern_states$region)

ggplot(map_states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(data = plot_location, color = alpha("blue", alpha = 0.5)) +
  coord_quickmap()
```

## Stand Statistics

We can gather per-stand statistics such as BALIVE and CARBON_AG from the FIA
data for these plots over time.

```{r stand_stats}
rds_file <- 'data/intermediate/stand_stats.rds'
if (USE_CACHE & file.exists(rds_file)) {
  stand_stats <- read_rds(rds_file)
} else {
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  
  measyear <- tbl(fia, 'PLOT') |>
    select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR, DESIGNCD, ECOSUBCD)
  
  forest_type <- tbl(fia, 'REF_FOREST_TYPE') |>
    select(VALUE, MEANING) |>
    rename(FORTYPCD = VALUE) |>
    rename(FORTYPE = MEANING)
  
  tree_stats <- tbl(fia, 'TREE') |>
    select(STATECD, COUNTYCD, PLOT, CONDID, INVYR, DIA, CARBON_AG, TPA_UNADJ) |>
    group_by(STATECD, COUNTYCD, PLOT, CONDID, INVYR) |>
    summarize(
      CARBON_AG = sum(CARBON_AG, na.rm = TRUE),
      CPA = sum(CARBON_AG * TPA_UNADJ, na.rm = TRUE),
      BA_TREES = sum(if_else(DIA >= 1, TPA_UNADJ, 0), na.rm = TRUE),
      .groups = "keep"
    )
  
  stand_stats <- tbl(fia, 'COND') |>
    select(STATECD, COUNTYCD, PLOT, INVYR, STDAGE, BALIVE, FORTYPCD) |>
    semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
    group_by(STATECD, COUNTYCD, PLOT, INVYR) |>
    # QMD = sqrt(sum(DIA^2) / n)
    # Which is equivalent to
    # QMD = sqrt(sum(BALIVE * TPA_UNADJ) / (n * k)), where n is number of trees,
    # and k is π/576 ≅ 0.005454 for B in square feet and QMD in inches;
    # and k is π/40000 ≅ 0.0000785 for B in square meters and QMD in centimeters.
    # (see https://www.sciencedirect.com/science/article/pii/S2197562023000453 ,
    # https://doi.org/10.1016/j.fecs.2023.100114 )
    # When computing QMD from BA we need to use the same trees for BA and n;
    # FIADB data dictionary 2.5.51 BALIVE says "Basal area in square feet per
    # acre of all live trees ω1.0 inch d.b.h/d.r.c sampled in the condition."
    summarize(
      BALIVE = sum(BALIVE, na.rm = TRUE),
      FORTYPCD = max(FORTYPCD, na.rm = TRUE),
      STDAGE = max(STDAGE, na.rm = TRUE),
      .groups = "keep"
    ) |>
    ungroup() |>
    left_join(measyear, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    left_join(tree_stats, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    left_join(forest_type, by = join_by(FORTYPCD)) |>
    rename(`Forest Type` = FORTYPE) |>
    mutate(
      STDAGE = if_else(STDAGE == -999, NA, STDAGE),
      FORTYPCD = floor(FORTYPCD / 10) * 10
    ) |>
    left_join(forest_type, by = join_by(FORTYPCD)) |>
    rename(`Forest Type Group` = FORTYPE) |>
    collect() |>
    modern_plots_filter() |>
    has_trees_filter() |>
    mutate(
      `Forest Type Group` = str_replace(`Forest Type Group`, ' group', ''),
      BALIVE_METRIC = conv_multiunit(BALIVE, "ft2 / acre", "m2 / hectare"),
      QMD = sqrt(BALIVE / (BA_TREES * (pi / 576))),
      QMD_METRIC = sqrt(BALIVE_METRIC / (BA_TREES * (pi / 40000))),
      CARBON_METRIC = conv_multiunit(CPA, "lbs / acre", "Mg / hectare")
    ) |> 
    group_by(STATECD, COUNTYCD, PLOT) |>
    mutate(
      BALIVE_START = if_else(MEASYEAR == min(MEASYEAR, na.rm = TRUE), BALIVE_METRIC, NA),
      BALIVE_DELTA = BALIVE_METRIC - max(BALIVE_START, na.rm = TRUE),
      YEARS = MEASYEAR - min(MEASYEAR, na.rm = TRUE)
    ) |> 
    ungroup()
  
  dbDisconnect(fia)
  remove(fia, measyear, forest_type, tree_stats)
  
  write_rds(stand_stats, rds_file)
}
```

Plot location with visual distinction by ecotype and forest type

```{r plot_location_by_ecotype}
plot_location_tmp <- plot_location |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, long, lat, group)

plot_location_type <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  consolidate_forest_type_groups_filter() |>
  select(STATECD, COUNTYCD, PLOT, INVYR, ECOSUBCD, `Forest Type`, `Forest Type Group`) |>
  left_join(plot_location_tmp, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  mutate(
    # If we're just stripping off subregion, could also do this as
    #   substr(ECOSUBCD, 1, nchar(ECOSUBCD) - 1)
    # but using sub() gives us more flexibility.
    ECOCD = sub(
      x = ECOSUBCD,
      # M? - Mountain
      # \d+ - Region
      # [A-Z] - Ecoregion
      # [a-z] - Ecosubregion
      pattern = "(M?)(\\d+)([A-Z])([a-z])",
      replacement = "\\1\\2\\3"
    )
  )

ggplot(map_states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
#  geom_point(plot_location_type, mapping = aes(long, lat, group = group, color = `Forest Type Group`)) +
  geom_point(
    plot_location_type,
    mapping = aes(long, lat, group = group, color = ECOCD),
#    show.legend = FALSE
  ) +
  coord_quickmap() +
  ggtitle("Plot Location with Ecoregion")

remove(plot_location_tmp)
```

```{r plot_location_by_forest_type}
ggplot(map_states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(
    plot_location_type,
    mapping = aes(long, lat, group = group, color = `Forest Type Group`)) +
  coord_quickmap() +
  ggtitle("FIA Grow-Only Plots in the Northeast Region")
```

Look at BA over time; first, by stand age, then as change over calendar time.

```{r balive_vs_stdage}
ggplot(
    data = stand_stats |>
      consolidate_forest_type_groups_filter() |>
      filter(!is.na(STDAGE)),
    mapping = aes(x = STDAGE, y = BALIVE_METRIC)
  ) +
  geom_bin2d() +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nMeasured BA (m²/ha) vs Stand Age")
```

```{r balive_delta_vs_years}
ggplot(
    stand_stats |>
      consolidate_forest_type_groups_filter() |>
      group_by(STATECD, COUNTYCD, PLOT) |>
      filter(MEASYEAR == max(MEASYEAR)) |>
      ungroup(),
    aes(x = YEARS, y = BALIVE_DELTA)
  ) +
  geom_bin2d() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  #scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20, 22)) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nChange in FIA Measured BA (m² / ha) vs. Projection Years")
```

```{r seen_types}
latest_measyear <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    MEASYEAR = max(MEASYEAR),
    .groups = "keep"
  ) |>
  ungroup()

seen_types <- stand_stats |>
  semi_join(latest_measyear, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR)) |>
  group_by(`Forest Type Group`) |>
  summarize(
    CARBON_AG_METRIC = sum(conv_unit(CARBON_AG, "lbs", "Mg")),
    .groups = "keep"
  )

seen_types |>
  ggplot(
    aes(y = fct_reorder(`Forest Type Group`, CARBON_AG_METRIC), x = CARBON_AG_METRIC)
  ) +
  scale_x_log10() +
  geom_col() +
  ggtitle("Total Carbon by Forest Type Group (Mg)") +
  ylab("Forest Type") +
  xlab("Carbon")
```

## Regeneration, Ingrowth, and Establishment

The Northeastern variant is a partial establishment model, so it does not
automatically perform natural regeneration. We will therefore use actual
ingrowth from the FIA data.

### Observed Ingrowth

fia.TREE_GRM_COMPONENT will mark a tree as 'INGROWTH' when
the tree is judged to be 'established', with a corresponding TREE record.
A tree marked 'INGROWTH' may have multiple TREE records if it is inventoried
after ingrowth, and if it grows on a microplot, in which case it will be
tracked from the time it is 1" DBH. If the tree grows on the microplot, then
its ingrowth is marked in MICR_COMPONENT_AL_FOREST; otherwise it is marked
in SUBP_COMPONENT_AL_FOREST. Multiple TREE_GRM_COMPONENT records for the tree
can be marked 'INGROWTH', in different inventories. It may also have other
records with other components, e.g. trees on the microplot will have a
'SURVIVOR' record in each inventory prior to ingrowth.

```{r grm_ingrown}
# We want ingrowth for all the plots in plot_grow_only
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

# Get PLT_CN for all plots in plot_grow_only, for all valid INVYR
plt_cns_mixin <- tbl(fia, 'PLOT') |>
  semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
  select(CN, MEASYEAR) |>
  distinct() |> # should be redundant, but doesn't appear to be
  rename(PLT_CN = CN)

tree_mixin <- tbl(fia, 'TREE') |>
  select(CN, STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR, SPCD) |>
  rename(TRE_CN = CN)

# Get all the Tree Growth, Removal, and Mortality entries for those plots that
# are marked as INGROWTH, either on a microplot or subplot.
grm_ingrown <- tbl(fia, 'TREE_GRM_COMPONENT') |>
  inner_join(plt_cns_mixin, by = join_by(PLT_CN)) |>
  ingrowth_filter() |>
  select(
    TRE_CN, PREV_TRE_CN, PLT_CN, MEASYEAR,
    DIA_BEGIN, DIA_MIDPT, DIA_END, ANN_DIA_GROWTH, ANN_HT_GROWTH,
    MICR_COMPONENT_AL_FOREST, MICR_TPAGROW_UNADJ_AL_FOREST,
    SUBP_COMPONENT_AL_FOREST, SUBP_TPAGROW_UNADJ_AL_FOREST
  ) |>
  # Pick only the first ingrowth record
  left_join(tree_mixin, by = join_by(TRE_CN)) |>
  group_by(STATECD, COUNTYCD, PLOT, SUBP, TREE) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  collect()
dbDisconnect(fia)
rm(fia, plt_cns_mixin)
print(paste0("Ingrown trees: ", grm_ingrown |> nrow()))
print(paste0(
  "  ",
  nrow(grm_ingrown) /
    nrow(plot_grow_only) /
    (max(grm_ingrown$MEASYEAR) - min(grm_ingrown$MEASYEAR)),
  " ingrown trees / plot / year"))
print(paste0("Ingrown trees over 3\" DBH: ", grm_ingrown |> filter(DIA_END > 3) |> nrow()))
```

### FVS Restrictions on Ingrowth

FIA marks a tree as INGROWTH when it reaches 5" DBH; FVS Establishment
is restricted to trees <= 3" DBH:

Trees are injected into FVS via the Regeneration and Establishment model,
using the `Estab` keyword. This allows trees to be added to a plot during
a run. Normally these trees are seedlings, which the model will then grow;
the HTADJ keyword overrides the seedling processing and allows injection of
saplings.

The FVS guide to the Regeneration and Establishment model,
Appendix C on details for keywords, for HTADJ, says:

> Adjust regeneration tree heights before they are passed
> to the Prognosis Model. Heights after adjustment are
> bounded between the minimum establishment height
> listed in table 1 and the height of a tree 3 inches d.b.h.

```{r grm_ingrown_histogram}
grm_ingrown |>
  mutate(
    `> 3" DBH` = if_else(DIA_END > 3, MEASYEAR, NA),
    `≤ 3" DBH` = if_else(DIA_END <= 3, MEASYEAR, NA)
  ) |>
  select(TRE_CN, `> 3" DBH`, `≤ 3" DBH`) |>
  melt(
    id.vars = c('TRE_CN'),
    variable.name = 'Diameter at Ingrowth',
    value.name = 'Year'
  ) |>
  filter(!is.na(Year)) |>
  ggplot(aes(Year, fill = `Diameter at Ingrowth`)) +
    geom_histogram(binwidth = 1) +
    scale_fill_manual(values = c("red", "blue")) +
    ggtitle('Ingrown trees on NRS grow-only plots') +
    xlab('Year') +
    ylab('Count')

```

```{r grm_ingrown_boxplot}
grm_ingrown |>
  select(DIA_END) |>
  ggplot(aes(DIA_END)) +
  geom_histogram(binwidth = 1) +
  scale_y_continuous(transform = "log10") +
  xlab('Diameter at Ingrowth (inches)') +
  geom_vline(xintercept = 3, color = 'red')
```

There are ~55,000 trees that ingrow over the 25 years, so about 2 trees per
plot per 3 years.
Most of these trees are over the 3"DBH diameter limit on ingrowth set by FVS.

### Tree History

Trees >=1" DBH that grow on the microplot are in the TREE table in FIA,
so in some cases we should be able to follow a tree back to the point when it
was <=3" DBH. The microplot is ~8% of the plot, so we would expect ~8% of
ingrown trees to have observations prior to ingrowth, assuming that it
normally takes more than the average inter-inventory timespan (5 years) for
a tree to reach ingrowth size.

For this section, we'll use the following terminology, aligned with the FIA
database:

- Tree - an individual observation of a tree; a single record in the TREE table
- Tree History - a sequence of Trees linked by CN / PREV_TRE_CN in the TREE table
- First Tree - the Tree in a Tree History with the earliest INVYEAR
- Last Tree - the Tree in a Tree History with the latest INVYEAR

We identify a Tree History by the CN of the last tree in the history.

tree_ingrown - all tree records for ingrown trees, including pre- and
               post-ingrowth

NB: This takes about 5 minutes on a laptop.

```{r tree_ingrown}
rds_file <- 'data/intermediate/tree_ingrown.rds'
if (USE_CACHE & file.exists(rds_file)) {
  tree_ingrown <- read_rds(rds_file)
} else {
  # CNs of the ingrown trees; these will be the heads of the tree histories
  grm_ingrown_cns <- grm_ingrown |>
    select(TRE_CN) |>
    rename(CN = TRE_CN)
  
  # Re-use the database connection
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

  # fetch_trees - fetch all of the trees that have ever been live on a plot
  fetch_trees <- function(row) {
    statecd <- row[["STATECD"]]
    countycd <- row[["COUNTYCD"]]
    plot <- row[["PLOT"]]

    measyear_mixin <- tbl(fia, 'PLOT') |>
      select(CN, MEASYEAR) |>
      rename(PLT_CN = CN)
  
    all_trees <- tbl(fia, 'TREE') |>
      filter(
        STATECD == statecd &
        COUNTYCD == countycd &
        PLOT == plot
      ) |>
      # Only live trees
      filter(CONDID == 1) |>
      left_join(measyear_mixin, by = join_by(PLT_CN)) |>
      select(
        CN, PLT_CN, PREV_TRE_CN,
        INVYR, MEASYEAR, STATECD, COUNTYCD, PLOT, SUBP, TREE, CONDID,
        STATUSCD, SPCD, DIA, DIAHTCD, HT, HTCD, ACTUALHT, BHAGE, TOTAGE, SITREE,
        PREVDIA, P2A_GRM_FLG, PREV_STATUS_CD, TPA_UNADJ
      ) |>
      collect()
    
    # Start with the trees at the time of ingrowth
    tree_ingrown <- all_trees |>
      semi_join(grm_ingrown_cns, by = join_by(CN))

    prev_tre_cns <- tree_ingrown |>
      select(PREV_TRE_CN) |>
      filter(!is.na(PREV_TRE_CN)) |>
      distinct() 

    while (nrow(prev_tre_cns) > 0) {
      more_trees <- all_trees |>
        semi_join(prev_tre_cns, by = join_by(CN == PREV_TRE_CN))
      tree_ingrown <- rbind(tree_ingrown, more_trees) |>
        distinct() # Should be redundant, but isn't
      prev_tre_cns <- more_trees |>
        select(PREV_TRE_CN) |>
        filter(!is.na(PREV_TRE_CN)) |>
        distinct()
    }
    return(tree_ingrown)
  }

  tree_ingrown <- reduce(
    pbapply(plot_grow_only, 1, fetch_trees),
    bind_rows
  )
  
  next_tre_mixin <- tree_ingrown |>
    select(CN, PREV_TRE_CN) |>
    rename(NEXT_TRE_CN = CN, CN = PREV_TRE_CN)

  tree_ingrown <- tree_ingrown |>
    left_join(next_tre_mixin, by = join_by(CN))
  
  dbDisconnect(fia)

  remove(fia, grm_ingrown_cns, next_tre_mixin)

  write_rds(tree_ingrown, rds_file)
}
```

Walk the tree history to see what diameter we can get to.

```{r tree_ingrown_last}
# CN - the latest CN for this tree
# DIA - the latest DIA for this tree
# PREV_TRE_CN - the next earlier CN in this tree history, if any
# FRST_DIA - the earliest available DIA in this tree history
# FRST_TRE_CN - the earliest available CN in this tree history
tree_ingrown_last <- grm_ingrown |>
  select(TRE_CN, PREV_TRE_CN, DIA_END) |>
  rename(CN = TRE_CN, DIA = DIA_END) |>
  # Initialize FRST_TRE_CN to CN; we'll overwrite this
  # as we walk the chain of PREV_TRE_CNs
  mutate(FRST_DIA = DIA, FRST_TRE_CN = CN)

trees_rhs <- tree_ingrown |>
  select(CN, PREV_TRE_CN, DIA)

tree_cns_todo <- tree_ingrown_last |>
  select(PREV_TRE_CN) |>
  filter(!is.na(PREV_TRE_CN)) |>
  distinct()

iterations <- 0
while (nrow(tree_cns_todo) > 0) {
  print(paste0(
    "Iteration: ",
    iterations <- iterations + 1,
    ", CNs: ",
    nrow(tree_cns_todo)
  ))
  tmp_trees <- tree_ingrown_last |>
    left_join(trees_rhs, by = join_by(PREV_TRE_CN == CN))
  tree_ingrown_last <- tmp_trees |>
    rename(DIA = DIA.x) |>
    mutate( # Update FRST_DIA
      FRST_DIA = if_else(is.na(DIA.y), FRST_DIA, DIA.y)
    ) |>
    mutate( # Update FRST_CN
      FRST_TRE_CN = if_else(is.na(PREV_TRE_CN), FRST_TRE_CN, PREV_TRE_CN)
    ) |>
    mutate( # Move PREV_TRE_CN one time hop
      PREV_TRE_CN = PREV_TRE_CN.y
    ) |>
    select(CN, PREV_TRE_CN, DIA, FRST_TRE_CN, FRST_DIA)
  tree_cns_todo <- tmp_trees |>
    select(PREV_TRE_CN.y) |>
    rename(PREV_TRE_CN = PREV_TRE_CN.y) |>
    filter(!is.na(PREV_TRE_CN))
}

measyear_mixin <- tree_ingrown |>
  select(CN, MEASYEAR)

tree_ingrown_last <- tree_ingrown_last |>
  left_join(measyear_mixin, by = join_by(CN)) |>
  left_join(
    measyear_mixin |> rename(FRST_MEASYEAR = MEASYEAR),
    by = join_by(FRST_TRE_CN == CN)
  )

rm(trees_rhs, tree_cns_todo, tmp_trees, iterations)
```

How many trees ingrow with DBH>3?
```{r dbh_gt_3}
tree_ingrown_last |> filter(DIA > 3) |> nrow()
```

How many of those are traceable back to when they had DBH <= 3?
```{r dbh_le_3}
tree_ingrown_last |> filter(DIA > 3 & FRST_DIA <= 3) |> nrow() 
```

For the remaining trees we will need to back-project.

### Back-Projecting Trees

#### FIA Estimated Growth Rate

fia.TREE_GRM_COMPONENT.ANN_DIA_GROWTH specifies annual diameter growth rate.
Looking at the values in this column, they seem small. We can check the
growth rate for trees where we have a previous observation by projecting
diameter growth backwards to the first MEASYEAR and seeing how close we
get to the first observed diameter.

```{r tree_growth_fia}
tree_growth_fia <- tree_ingrown_last |>
  filter(FRST_DIA < DIA) |>
  # Add on FIA growth rate
  left_join(grm_ingrown |> select(TRE_CN, ANN_DIA_GROWTH), by = join_by(CN == TRE_CN)) |>
  mutate(DIA_EST = DIA - (MEASYEAR - FRST_MEASYEAR) * ANN_DIA_GROWTH) |>
  mutate(DIA_ERR = abs(100 * (DIA_EST - FRST_DIA) / FRST_DIA)) |>
  filter(!is.na(DIA_ERR)) |>
  arrange(DIA_ERR)

ggplot(tree_growth_fia, aes(DIA_ERR, after_stat(100 * count / sum(count)))) +
  geom_histogram(binwidth = 10, position = position_nudge(5)) +
  #geom_freqpoly() +
  ggtitle("Diameter Projection Error using FIA Growth Rate") +
  ylab("Frequency (%)") +
  xlab("Error (%) (binwidth = 10%)")
```

This shows that using the FIA growth rate, only 20% of trees back-project
to within 10% of their first surveyed diameter, so we can't rely on the FIA
growth rate when we don't have previous tree records for an ingrown tree.

Notes:

* Regeneration is heavily influenced by many things, from canopy structure
  to seed availability to predation to timing of canopy opening
* See competing articles on "Oh no! We get only sugar maple and no beech!"
  vs. "Oh no! We get only beech and no sugar maple!"
* "composition is stabilized by local landforms and [...] diversity increases
  with hydrologic catchment area"
* The best indicator of regeneration will unquestionably be actual regeneration

#### Observed Growth Rates

To estimate the time at which an ingrown tree was 3" DBH, we can project
growth backward in time based on the growth rates of similar trees. Defining
"similar" needs to be done with care. We can validate a model using the 8% of
ingrown trees for which we have measurements prior to ingrowth. We can use
our method to project these trees back in time to the earliest measurement,
and see how close we get to the measured value.

To do this, we need to caputre how much each tree grew in each inventory.

tree_growth - adds to each tree:

 - SZCLCD - Size Class Code, 0 = Sapling, 1 = Seedling, 2 = Poletimber, 3 = Sawlog
 - *_DELTA - diameter/height/age change since previous inventory
 - ANN_*_DELTA - annualize rate of diameter change since previous inventory
  
Note that tree_growth is all trees, not just ingrown trees.

This also fetches trees with only a single observation; these are useful
for calculating ingrowth.

```{r tree_growth}
rds_file <- 'data/intermediate/tree_growth.rds'
if (USE_CACHE & file.exists(rds_file)) {
  tree_growth <- read_rds(rds_file)
} else {
  # FIA.TREE.CN - sequence number
  # FIA.TREE.TREE - TREE number
  # FIA.TREE.CONDID - condition class; 1 = live tree
  # FIA.TREE.SPCD - species code
  # FIA.TREE.DIA - current diameter
  # FIA.TREE.DIAHTCD - where diameter was taken, 1 = DBH
  # FIA.TREE.HT - height
  # FIA.TREE.SPGRPCD is broader than SPCD, group by that instead
  # FIA.TREE.CCLCD - Crown Class code
  # FIA.TREE.TPA_UNADJ - Trees Per Acre (Unadjusted)
  # We want ingrowth for all the plots in plot_grow_only
  
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  measyear_mixin <- tbl(fia, 'PLOT') |>
    select(CN, MEASYEAR) |>
    rename(PLT_CN = CN)
  
  prev_tre_mixin <- tbl(fia, 'TREE') |>
    select(CN, PLT_CN, DIA, HT) |>
    left_join(measyear_mixin, by = join_by(PLT_CN)) |>
    rename(
      PREV_TRE_CN = CN,
      PREV_PLT_CN = PLT_CN,
      PREV_MEASYEAR = MEASYEAR,
      PREV_DIA = DIA,
      PREV_HT = HT
    )

  tree_growth <- tbl(fia, 'TREE') |>
    semi_join(
      plot_grow_only |> arrange(STATECD, COUNTYCD, PLOT),
      by = join_by(STATECD, COUNTYCD, PLOT),
      copy = TRUE
    ) |>
    # Live trees
    filter(CONDID == 1) |>
    # Many trees will have no previous tree, don't filter those out.
    # filter(!is.na(PREV_TRE_CN)) |>
    # Self-join to previous tree to get growth increment
    left_join(prev_tre_mixin, by = join_by(PREV_TRE_CN)) |>
    left_join(measyear_mixin, by = join_by(PLT_CN)) |>
    mutate(
      DIA_DELTA = DIA - PREV_DIA,
      AGE_DELTA = MEASYEAR - PREV_MEASYEAR,
      ANN_DIA_DELTA = DIA_DELTA / AGE_DELTA,
      HT_DELTA = HT - PREV_HT,
      ANN_HT_DELTA = HT_DELTA / AGE_DELTA
    ) |>
    select(
      CN, PREV_TRE_CN, PLT_CN, PREV_PLT_CN,
      STATECD, COUNTYCD, PLOT, SUBP, TREE, SPCD, TPA_UNADJ,
      MEASYEAR, PREV_MEASYEAR, CCLCD, DIA, PREV_DIA, HT, PREV_HT,
      AGE_DELTA, DIA_DELTA, ANN_DIA_DELTA, HT_DELTA, ANN_HT_DELTA
    ) |>
    arrange(STATECD, COUNTYCD, PLOT, SUBP, TREE, MEASYEAR) |>
    collect()
  
  dbDisconnect(fia)

  tree_growth <- tree_growth |>
    left_join(species_mixin, by = join_by(SPCD)) |>
    mutate(SZCLCD = case_when(
      DIA < 1 ~ 0,
      DIA < 5 ~ 1,
      HARD_SOFT == "SOFTWOOD" & DIA < 9 ~ 2,
      HARD_SOFT == "HARDWOOD" & DIA < 11 ~ 2,
      .default = 3
    ))

  rm(fia, measyear_mixin, prev_tre_mixin)

  write_rds(tree_growth, rds_file)
}
```

Measurement is imperfect, leading to some outliers in the growth table. We
can look at different outlier removal strategies and the resulting distribution
of observations:

```{r plot_tree_growth}
tree_growth |>
  select(CN, SPGRPCD, JENKINS_SPGRP_NAME, ANN_DIA_DELTA) |>
  filter(!is.na(ANN_DIA_DELTA)) |>
  group_by(SPGRPCD) |>
  arrange(ANN_DIA_DELTA) |>
  mutate(
    ONE_OUTLIER = (row_number() < (n() * 0.01)) | (row_number() > (n() - n() * 0.01)),
    TWO_OUTLIER = (row_number() < (n() * 0.025)) | (row_number() > (n() - n() * 0.025))
  ) |>
  ungroup() |>
  group_by(JENKINS_SPGRP_NAME) |>
  mutate(
    GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())
  ) |>
  ungroup() |>
  mutate(
    `1%` = if_else(!ONE_OUTLIER, ANN_DIA_DELTA, NA),
    `2.5%` = if_else(!TWO_OUTLIER, ANN_DIA_DELTA, NA),
    `0%` = ANN_DIA_DELTA
  ) |>
  select(CN, GROUP_NAME, `1%`, `2.5%`, `0%`) |>
  melt(
    id.vars = c("CN", "GROUP_NAME"),
    variable.name = "Outliers Removed",
    value.name = "Growth Rate"
  ) |>
  filter(!is.na(`Growth Rate`)) |>
  mutate(`Outliers Removed` = factor(`Outliers Removed`, levels = c("0%", "1%", "2.5%"))) |>
  ggplot(
      aes(`Growth Rate`, fct_rev(fct_infreq(GROUP_NAME)), fill = `Outliers Removed`)
    ) +
    geom_boxplot() +
    scale_fill_discrete(breaks = c("2.5%", "1%", "0%")) +
    ggtitle("Measured Annual Growth with Outliers Removed by Species") +
    xlab(bquote("Annual Growth " ~(inch %.% yr^-1))) +
    ylab("Species Group")

```

#### Estimated Growth Rate

From the observed growth with outliers removed, we can compute per-species,
per-plot, per-inventory growth rates. We can then apply these growth rates
to ingrown trees to back-project them to their starting diameter.

For each plot/species/inventory, we compute the growth rate of that species
on that plot in that inventory, based on the trees of that species on that plot
during that inventory. Some variations filter out growth outliers.

For growth rate, we prioritize:

1. The mean growth rate of at least 3 dominant trees of the species during the inventory;
2. The mean growth rate of at least 3 trees of any dominance of the species during the inventory;
3. The mean growth rate of at least 3 trees of any dominance of the species group during the inventory;
4. The mean growth rate of at least 3 trees of any dominance of the species group on the plot during any inventory.

tree_growth_rate - all computable growth rates for all plot/species/inventory

```{r tree_growth_rate}
tree_growth_with_outliers <- tree_growth |>
  filter(!is.na(ANN_DIA_DELTA)) |>
  group_by(SPCD) |>
  arrange(ANN_DIA_DELTA) |>
  mutate(
    OUTLIER_ONE = (row_number() > (n() * 0.01)) & (row_number() < (n() - n() * 0.01)),
    DIA_DELTA_ONE = if_else(OUTLIER_ONE, DIA_DELTA, NA),
    OUTLIER_TWO = (row_number() > (n() * 0.025)) & (row_number() < (n() - n() * 0.025)),
    DIA_DELTA_TWO = if_else(OUTLIER_TWO, DIA_DELTA, NA)
  ) |>
  ungroup()

tree_growth_dom <- tree_growth_with_outliers |>
  filter(CCLCD <= 3) |>
  group_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD) |>
  summarize(
    DIA_DELTA = mean(DIA_DELTA, na.rm = TRUE),
    COUNT = n(),
    COUNT_ONE = sum(OUTLIER_ONE, na.rm = TRUE),
    COUNT_TWO = sum(OUTLIER_TWO, na.rm = TRUE),
    DIA_DELTA_DOM = mean(DIA_DELTA, na.rm = TRUE),
    DIA_DELTA_DOM_ONE = mean(DIA_DELTA_ONE, na.rm = TRUE),
    DIA_DELTA_DOM_TWO = mean(DIA_DELTA_TWO, na.rm = TRUE),
    .groups = 'keep'
  ) |>
  ungroup() |>
  mutate(
    DIA_DELTA_DOM = if_else(COUNT >= 3, DIA_DELTA_DOM, NA),
    DIA_DELTA_DOM_ONE = if_else(COUNT_ONE >= 3, DIA_DELTA_DOM_ONE, NA),
    DIA_DELTA_DOM_TWO = if_else(COUNT_TWO >= 3, DIA_DELTA_DOM_TWO, NA)
  ) |>
  select(
    STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
    DIA_DELTA_DOM, DIA_DELTA_DOM_ONE, DIA_DELTA_DOM_TWO
    )

tree_growth_spcd <- tree_growth_with_outliers |>
  group_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD) |>
  summarize(
    DIA_DELTA = mean(DIA_DELTA, na.rm = TRUE),
    COUNT = n(),
    COUNT_ONE = sum(OUTLIER_ONE, na.rm = TRUE),
    COUNT_TWO = sum(OUTLIER_TWO, na.rm = TRUE),
    DIA_DELTA_SPCD = mean(DIA_DELTA, na.rm = TRUE),
    DIA_DELTA_SPCD_ONE = mean(DIA_DELTA_ONE, na.rm = TRUE),
    DIA_DELTA_SPCD_TWO = mean(DIA_DELTA_TWO, na.rm = TRUE),
    .groups = 'keep'
  ) |>
  ungroup() |>
  mutate(
    DIA_DELTA_SPCD = if_else(COUNT >= 3, DIA_DELTA_SPCD, NA),
    DIA_DELTA_SPCD_ONE = if_else(COUNT_ONE >= 3, DIA_DELTA_SPCD_ONE, NA),
    DIA_DELTA_SPCD_TWO = if_else(COUNT_TWO >= 3, DIA_DELTA_SPCD_TWO, NA)
  ) |>
  select(
    STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
    DIA_DELTA_SPCD, DIA_DELTA_SPCD_ONE, DIA_DELTA_SPCD_TWO
  )

tree_growth_spgrpcd <- tree_growth_with_outliers |>
  group_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPGRPCD) |>
  summarize(
    DIA_DELTA = mean(DIA_DELTA, na.rm = TRUE),
    COUNT = n(),
    COUNT_ONE = sum(OUTLIER_ONE, na.rm = TRUE),
    COUNT_TWO = sum(OUTLIER_TWO, na.rm = TRUE),
    DIA_DELTA_SPGRPCD = mean(DIA_DELTA, na.rm = TRUE),
    DIA_DELTA_SPGRPCD_ONE = mean(DIA_DELTA_ONE, na.rm = TRUE),
    DIA_DELTA_SPGRPCD_TWO = mean(DIA_DELTA_TWO, na.rm = TRUE),
    .groups = 'keep'
  ) |>
  ungroup() |>
  mutate(
    DIA_DELTA_SPGRPCD = if_else(COUNT >= 3, DIA_DELTA_SPGRPCD, NA),
    DIA_DELTA_SPGRPCD_ONE = if_else(COUNT_ONE >= 3, DIA_DELTA_SPGRPCD_ONE, NA),
    DIA_DELTA_SPGRPCD_TWO = if_else(COUNT_TWO >= 3, DIA_DELTA_SPGRPCD_TWO, NA)
  ) |>
  select(
    STATECD, COUNTYCD, PLOT, MEASYEAR, SPGRPCD,
    DIA_DELTA_SPGRPCD, DIA_DELTA_SPGRPCD_ONE, DIA_DELTA_SPGRPCD_TWO
  )

tree_growth_multiyear <- tree_growth_with_outliers |>
  mutate(
    ANN_DIA_DELTA = DIA_DELTA / (MEASYEAR - PREV_MEASYEAR),
    ANN_DIA_DELTA_ONE = DIA_DELTA_ONE / (MEASYEAR - PREV_MEASYEAR),
    ANN_DIA_DELTA_TWO = DIA_DELTA_TWO / (MEASYEAR - PREV_MEASYEAR)
  ) |>
  group_by(STATECD, COUNTYCD, PLOT, SPGRPCD) |>
  summarize(
    COUNT = n(),
    COUNT_ONE = sum(OUTLIER_ONE, na.rm = TRUE),
    COUNT_TWO = sum(OUTLIER_TWO, na.rm = TRUE),
    ANN_DIA_DELTA_MULTIYEAR = mean(ANN_DIA_DELTA, na.rm = TRUE),
    ANN_DIA_DELTA_MULTIYEAR_ONE = mean(ANN_DIA_DELTA_ONE, na.rm = TRUE),
    ANN_DIA_DELTA_MULTIYEAR_TWO = mean(ANN_DIA_DELTA_TWO, na.rm = TRUE),
    .groups = 'keep'
  ) |>
  ungroup() |>
  mutate(
    ANN_DIA_DELTA_MULTIYEAR = if_else(COUNT >= 3, ANN_DIA_DELTA_MULTIYEAR, NA),
    ANN_DIA_DELTA_MULTIYEAR_ONE = if_else(COUNT_ONE >= 3, ANN_DIA_DELTA_MULTIYEAR_ONE, NA),
    ANN_DIA_DELTA_MULTIYEAR_TWO = if_else(COUNT_TWO >= 3, ANN_DIA_DELTA_MULTIYEAR_TWO, NA)
  ) |>
  select(
    STATECD, COUNTYCD, PLOT, SPGRPCD,
    ANN_DIA_DELTA_MULTIYEAR, ANN_DIA_DELTA_MULTIYEAR_ONE, ANN_DIA_DELTA_MULTIYEAR_TWO
  )

tree_growth_rate <- tree_growth_with_outliers |>
  distinct(STATECD, COUNTYCD, PLOT, MEASYEAR, PREV_MEASYEAR, SPCD) |>
  left_join(species_mixin, by = join_by(SPCD)) |>
  left_join(tree_growth_dom, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)) |>
  left_join(tree_growth_spcd, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)) |>
  left_join(tree_growth_spgrpcd, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPGRPCD)) |>
  left_join(tree_growth_multiyear, by = join_by(STATECD, COUNTYCD, PLOT, SPGRPCD)) |>
  mutate(
    DIA_DELTA = coalesce(
      DIA_DELTA_DOM,
      DIA_DELTA_SPCD,
      DIA_DELTA_SPGRPCD
    ),
    ANN_DIA_DELTA = coalesce(
      DIA_DELTA / (MEASYEAR - PREV_MEASYEAR),
      ANN_DIA_DELTA_MULTIYEAR
    ),
    DIA_DELTA_ONE = coalesce(
      DIA_DELTA_DOM_ONE,
      DIA_DELTA_SPCD_ONE,
      DIA_DELTA_SPGRPCD_ONE
    ),
    ANN_DIA_DELTA_ONE = coalesce(
      DIA_DELTA_ONE / (MEASYEAR - PREV_MEASYEAR),
      ANN_DIA_DELTA_MULTIYEAR_ONE
    ),
    DIA_DELTA_TWO = coalesce(
      DIA_DELTA_DOM_TWO,
      DIA_DELTA_SPCD_TWO,
      DIA_DELTA_SPGRPCD_TWO
    ),
    ANN_DIA_DELTA_TWO = coalesce(
      DIA_DELTA_TWO / (MEASYEAR - PREV_MEASYEAR),
      ANN_DIA_DELTA_MULTIYEAR_TWO
    )
  )
```

```{r tree_growth_rate_boxplot}
tree_growth_rate |>
  group_by(JENKINS_SPGRP_NAME) |>
  mutate(
    GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())
  ) |>
  ungroup() |>
  select(GROUP_NAME, ANN_DIA_DELTA, ANN_DIA_DELTA_ONE, ANN_DIA_DELTA_TWO) |>
  rename(`0%` = ANN_DIA_DELTA, `1%` = ANN_DIA_DELTA_ONE, `2.5%` = ANN_DIA_DELTA_TWO) |>
  melt(id.vars = c("GROUP_NAME"), value.name = "ANN_DIA_DELTA", variable.name = "Outliers Removed") |>
  filter(!is.na(ANN_DIA_DELTA)) |>
  ggplot(
      aes(ANN_DIA_DELTA, fct_rev(fct_infreq(GROUP_NAME)), fill = `Outliers Removed`)
    ) +
    geom_boxplot() +
    geom_vline(xintercept = 0, linetype = "dashed") +
    scale_fill_discrete(breaks = c("2.5%", "1%", "0%")) +
    coord_cartesian(xlim = c(-1, 1)) +
    theme_bw() +
    ggtitle("Measured Annual Diameter Growth of Ingrown Trees") +
    xlab(bquote("Annual Diameter Growth " ~(inch %.% yr^-1))) +
    ylab("Species Group")

```

```{r tree_growth_rate_boxplot_metric}
tree_growth_rate |>
  group_by(JENKINS_SPGRP_NAME) |>
  mutate(
    GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())
  ) |>
  ungroup() |>
  select(GROUP_NAME, ANN_DIA_DELTA, ANN_DIA_DELTA_ONE, ANN_DIA_DELTA_TWO) |>
  rename(`0%` = ANN_DIA_DELTA, `1%` = ANN_DIA_DELTA_ONE, `2.5%` = ANN_DIA_DELTA_TWO) |>
  melt(id.vars = c("GROUP_NAME"), value.name = "ANN_DIA_DELTA", variable.name = "Outliers Removed") |>
  filter(!is.na(ANN_DIA_DELTA)) |>
  mutate(ANN_DIA_DELTA = conv_unit(ANN_DIA_DELTA, "inch", "meter") * pi * 2) |>
  ggplot(
      aes(ANN_DIA_DELTA, fct_rev(fct_infreq(GROUP_NAME)), fill = `Outliers Removed`)
    ) +
    geom_boxplot() +
    geom_vline(xintercept = 0, linetype = "dashed") +
    scale_fill_discrete(breaks = c("2.5%", "1%", "0%")) +
    coord_cartesian(xlim = c(-0.2, 0.2)) +
    theme_bw() +
    ggtitle("Measured Annual Basal Area Growth of Ingrown Trees") +
    xlab(bquote("Annual Basal Area Growth " ~(m^2 %.% yr^-1))) +
    ylab("Species Group")

```

#### One-Shot Back-Projection

Can we use that to back-project ingrown trees?

```{r manual_back_projection}
location_mixin <- tree_ingrown |>
  select(CN, STATECD, COUNTYCD, PLOT, SPCD)

manual_back_projection <- tree_ingrown_last |>
  filter(FRST_DIA < DIA) |> # Trees that grow
  left_join(location_mixin, by = join_by(CN)) |>
  # Add on growth rate
  left_join(tree_growth_rate, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)) |>
  mutate(
    DIA_EST = DIA - (MEASYEAR - FRST_MEASYEAR) * ANN_DIA_DELTA_MULTIYEAR,
    DIA_ERR = (DIA_EST - FRST_DIA) / FRST_DIA,
    DIA_EST_ONE = DIA - (MEASYEAR - FRST_MEASYEAR) * ANN_DIA_DELTA_MULTIYEAR_ONE,
    DIA_ERR_ONE = (DIA_EST_ONE - FRST_DIA) / FRST_DIA,
    DIA_EST_TWO = DIA - (MEASYEAR - FRST_MEASYEAR) * ANN_DIA_DELTA_MULTIYEAR_TWO,
    DIA_ERR_TWO = (DIA_EST_TWO - FRST_DIA) / FRST_DIA
  ) |>
  arrange(DIA_ERR)

manual_back_projection |>
  group_by() |>
  summarize(
    COUNT = n(),
    MISSING = sum(is.na(DIA_EST), na.rm = TRUE) / COUNT,
    MISSING_ONE = sum(is.na(DIA_EST_ONE), na.rm = TRUE) / COUNT,
    MISSING_TWO = sum(is.na(DIA_EST_TWO), na.rm = TRUE) / COUNT,
    HIT = sum(abs(DIA_ERR) < 0.1, na.rm = TRUE) / COUNT,
    HIT_ONE = sum(abs(DIA_ERR_ONE) < 0.1, na.rm = TRUE) / COUNT,
    HIT_TWO = sum(abs(DIA_ERR_TWO) < 0.1, na.rm = TRUE) / COUNT,
    .groups = 'keep'
  ) |>
  ungroup() |>
  pivot_longer(everything()) |>
  knitr::kable()
```

Still less than half the trees back-project to within 10% of their first
measured diameter.

#### Stepwise Back-Projection

Rather than try to project back to starting diameter in one step, we can
project the diameter back to the estimated diameter at the previous measurement,
and repeat back in time until we get to the starting diameter. This will
better use per-inventory diameters.

tree_ingrown has one tree record for each year an ingrown tree was inventoried.
We can fill in a DIA_EST using the growth interval, and iterate until
they're all filled in.

```{r init_stepwise_manual_back_projection}
manual_back_projection <- tree_ingrown |>
  # Start with actually ingrown trees
  semi_join(grm_ingrown, by = join_by(CN == TRE_CN)) |>
  select(CN, STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD, PREV_TRE_CN, DIA) |>
  left_join(
    tree_growth_rate |>
      select(
        STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
        DIA_DELTA, DIA_DELTA_ONE, DIA_DELTA_TWO
      ),
    by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)
  ) |>
  # We can get a perfect estimate if we know the actual value :-D
  mutate(
    DIA_EST = DIA,
    DIA_EST_ONE = DIA,
    DIA_EST_TWO = DIA
  ) |>
  mutate(
    PREV_DIA_EST = DIA - DIA_DELTA,
    PREV_DIA_EST_ONE = DIA - DIA_DELTA_ONE,
    PREV_DIA_EST_TWO = DIA - DIA_DELTA_TWO
  ) |>
  mutate(
    DIA_ERR = abs((DIA - DIA_EST) / DIA),
    DIA_ERR_ONE = abs((DIA - DIA_EST_ONE) / DIA),
    DIA_ERR_TWO = abs((DIA - DIA_EST_TWO) / DIA),
  )

# Back-projectable trees:
manual_back_projection |> nrow()
```

```{r stepwise_manual_back_projection}
prev_tre_cns <- manual_back_projection |>
  select(PREV_TRE_CN) |>
  filter(!is.na(PREV_TRE_CN))

iterations <- 0
while (nrow(prev_tre_cns) > 0) {
  print(paste0(
    "Iteration: ",
    iterations <- iterations + 1,
    ", CNs: ",
    nrow(prev_tre_cns)
  ))
  tmp_trees <- tree_ingrown |>
    semi_join(prev_tre_cns, by = join_by(CN == PREV_TRE_CN)) |>
    select(CN, STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD, PREV_TRE_CN, DIA) |>
        # Join on growth rates
    left_join(
      tree_growth_rate |>
        select(
          STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
          DIA_DELTA, DIA_DELTA_ONE, DIA_DELTA_TWO
        ),
      by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)
    ) |>
    # Join on previously estimated diameter
    left_join(
      manual_back_projection |>
        select(PREV_TRE_CN, PREV_DIA_EST, PREV_DIA_EST_ONE, PREV_DIA_EST_TWO) |>
        rename(
          CN = PREV_TRE_CN,
          DIA_EST = PREV_DIA_EST,
          DIA_EST_ONE = PREV_DIA_EST_ONE,
          DIA_EST_TWO = PREV_DIA_EST_TWO
        ),
      by = join_by(CN)
    ) |>
    mutate(
      DIA_ERR = abs(DIA - DIA_EST) / DIA,
      DIA_ERR_ONE = abs(DIA - DIA_EST_ONE) / DIA,
      DIA_ERR_TWO = abs(DIA - DIA_EST_TWO) / DIA
    ) |>
    # Estimate the next previous tree diameter
    mutate(
      PREV_DIA_EST = DIA_EST - DIA_DELTA,
      PREV_DIA_EST_ONE = DIA_EST_ONE - DIA_DELTA_ONE,
      PREV_DIA_EST_TWO = DIA_EST_TWO - DIA_DELTA_TWO
    )
  # Apparently, some trees can be tracked back before the end of time
  # or something, so we can end up with some PREV_TRE_CNs that are
  # dangling refrences.
  if (nrow(tmp_trees) == 0) {
    break
  }
  manual_back_projection <- bind_rows(manual_back_projection, tmp_trees)
  num_duplicate_cns <- manual_back_projection |>
    group_by(CN) |>
    filter(n() > 1) |>
    ungroup() |> nrow()
  stopifnot(num_duplicate_cns == 0)
  # The next set of prev_tre_cns is:
  prev_tre_cns <- manual_back_projection |>
    # All PREV_TRE_CN mentioned
    select(PREV_TRE_CN) |>
    filter(!is.na(PREV_TRE_CN)) |>
    distinct() |>
    # that have not already been processed
    anti_join(
      manual_back_projection |>
        select(CN) |>
        filter(!is.na(CN)) |>
        distinct(),
      by = join_by(PREV_TRE_CN == CN)
    )
}
manual_back_projection |>
  group_by() |>
  summarize(
    COUNT = n(),
    MISSING = sum(is.na(DIA_EST), na.rm = TRUE) / COUNT,
    MISSING_ONE = sum(is.na(DIA_EST_ONE), na.rm = TRUE) / COUNT,
    MISSING_TWO = sum(is.na(DIA_EST_TWO), na.rm = TRUE) / COUNT,
    HIT = sum(abs(DIA_ERR) < 0.1, na.rm = TRUE) / COUNT,
    HIT_ONE = sum(abs(DIA_ERR_ONE) < 0.1, na.rm = TRUE) / COUNT,
    HIT_TWO = sum(abs(DIA_ERR_TWO) < 0.1, na.rm = TRUE) / COUNT,
    .groups = 'keep'
  ) |>
  ungroup() |>
  pivot_longer(everything()) |>
  knitr::kable()

```

Apply Back-Projection

```{r projected_vs_measured_annual_growth}
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

projected_annual_growth <- tree_ingrown_last |>
  filter(MEASYEAR != FRST_MEASYEAR) |>
  left_join(
    manual_back_projection |>
      select(CN, SPCD, DIA_EST, DIA_EST_ONE, DIA_EST_TWO),
    by = join_by(FRST_TRE_CN == CN)
  ) |>

  # Be metric
  mutate(
    DIA = conv_unit(DIA, "in", "cm"),
    FRST_DIA = conv_unit(FRST_DIA, "in", "cm"),
    DIA_EST = conv_unit(DIA_EST, "in", "cm"),
    DIA_EST_ONE = conv_unit(DIA_EST_ONE, "in", "cm"),
    DIA_EST_TWO = conv_unit(DIA_EST_TWO, "in", "cm"),
  ) |>

  mutate(
    ANN_DIA = (DIA - FRST_DIA) / (MEASYEAR - FRST_MEASYEAR),
    DIA_ERR = (FRST_DIA - DIA_EST),
    ANN_DIA_EST = (DIA - DIA_EST) / (MEASYEAR - FRST_MEASYEAR),
    ANN_DIA_ERR = DIA_ERR / (MEASYEAR - FRST_MEASYEAR),
    DIA_ERR_ONE = (FRST_DIA - DIA_EST_ONE),
    ANN_DIA_EST_ONE = (DIA - DIA_EST_ONE) / (MEASYEAR - FRST_MEASYEAR),
    ANN_DIA_ERR_ONE = DIA_ERR_ONE / (MEASYEAR - FRST_MEASYEAR),
    DIA_ERR_TWO = (FRST_DIA - DIA_EST_TWO),
    ANN_DIA_EST_TWO = (DIA - DIA_EST_TWO) / (MEASYEAR - FRST_MEASYEAR),
    ANN_DIA_ERR_TWO = DIA_ERR_TWO / (MEASYEAR - FRST_MEASYEAR),
  ) |>
  filter(!is.na(DIA_ERR)) |>
  left_join(species_mixin, by = join_by(SPCD)) |>
  group_by(JENKINS_SPGRP_NAME) |>
  mutate(GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())) |>
  ungroup() |>
  select(CN, GROUP_NAME, ANN_DIA, ANN_DIA_EST, ANN_DIA_EST_ONE, ANN_DIA_EST_TWO) |>
  rename(
    `Measured` = ANN_DIA,
    `Estimated` = ANN_DIA_EST,
    `Est - 1%` = ANN_DIA_EST_ONE,
    `Est - 2.5%` = ANN_DIA_EST_TWO
  ) |>
  melt(
    id.vars = c("CN", "GROUP_NAME"),
    variable.name = "Series",
    value.name = "Growth"
  ) |>
  filter(!is.na(Growth)) |>
  mutate(Growth = conv_unit(Growth, "in", "m") * pi * 2)
ggplot(
  projected_annual_growth,
  aes(Growth, fct_rev(fct_infreq(GROUP_NAME)), fill = `Series`)
) +
  geom_boxplot(outlier.size = 0.1) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_fill_discrete(breaks = rev(levels(projected_annual_growth$Series))) +
  #coord_cartesian(xlim = c(-0.2, 0.2)) +
  theme_bw() +
  ggtitle("Projected Annual Growth of Ingrown Trees") +
  xlab(bquote("Change in Basal Area " ~(m^2 %.% yr^-1))) +
  ylab("Species Group")
```

This looks usable.

#### Back-Project to <= 3" DBH

Using estimated diameter, what portion of ingrown trees
can we project back to 3" DBH before the first MEASYEAR?

```{r init_tree_ingrown_three}
tree_ingrown_three <- tree_ingrown |>
  # Start with actually ingrown trees
  semi_join(grm_ingrown, by = join_by(CN == TRE_CN)) |>
  select(CN, STATECD, COUNTYCD, PLOT, SUBP, TREE, MEASYEAR, SPCD, DIA) |>
  left_join(
    tree_growth_rate |>
      select(
        STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
        PREV_MEASYEAR,
        DIA_DELTA, DIA_DELTA_ONE, DIA_DELTA_TWO
      ),
    by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)
  ) |>
  # Fill in estimated diameters
  mutate(
    FRST_MEASYEAR = if_else(DIA > 3, PREV_MEASYEAR, MEASYEAR),
    FRST_DIA_EST = if_else(DIA > 3, DIA - DIA_DELTA, DIA),
    FRST_DIA_EST_ONE = if_else(DIA > 3, DIA - DIA_DELTA_ONE, DIA),
    FRST_DIA_EST_TWO = if_else(DIA > 3, DIA - DIA_DELTA_TWO, DIA)
  ) |>
  mutate(
    PREV_MEASYEAR = if_else(FRST_DIA_EST > 3, PREV_MEASYEAR, NA)
  )
```

```{r tree_ingrown_three}
# Graft on the growth for the previous inventory
# project back that growth
# calculate the estimated diameter
# anything that's at 3", or that doesn't have a prev_measyear, gets filtered out
# (set to NULL?)
# move prev_measyear back a notch
# repeat
prev_measyears <- tree_ingrown_three |>
  filter(!is.na(PREV_MEASYEAR)) |>
  select(CN, PREV_MEASYEAR)

# Less efficient, but amusing and probably worth it:
# run prev_measyear back by max(prev_measyears), so
# we can print the year we're projecting. Then
# do the join on tree_ingrown_three and tree_growth_rate
# with appropriate measyears.
iterations <- 0
while (nrow(prev_measyears) > 0) {
  print(paste0(
    "Iteration: ",
    iterations <- iterations + 1,
    ", Trees: ",
    nrow(prev_measyears),
    ", Years: ",
    min(prev_measyears$PREV_MEASYEAR),
    " - ",
    max(prev_measyears$PREV_MEASYEAR)
  ))

  tree_ingrown_three <- tree_ingrown_three |>
    select(!starts_with("DIA_DELTA")) |>
    left_join(
      tree_growth_rate |>
        select(
          STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
          PREV_MEASYEAR,
          DIA_DELTA, DIA_DELTA_ONE, DIA_DELTA_TWO
        ),
      by = join_by(STATECD, COUNTYCD, PLOT, PREV_MEASYEAR == MEASYEAR, SPCD)
    ) |>
    select(!"PREV_MEASYEAR") |>
    rename(PREV_MEASYEAR = PREV_MEASYEAR.y) |>
    # Update estimated diameters, but only if growth joined on
    mutate(
      FRST_MEASYEAR = if_else(!is.na(DIA_DELTA), PREV_MEASYEAR, FRST_MEASYEAR),
      FRST_DIA_EST =
        if_else(!is.na(DIA_DELTA), FRST_DIA_EST - DIA_DELTA, FRST_DIA_EST),
      FRST_DIA_EST_ONE =
        if_else(!is.na(DIA_DELTA), FRST_DIA_EST_ONE - DIA_DELTA_ONE, FRST_DIA_EST_ONE),
      FRST_DIA_EST_TWO =
        if_else(!is.na(DIA_DELTA), FRST_DIA_EST_TWO - DIA_DELTA_TWO, FRST_DIA_EST_TWO)
    ) |>
    mutate(
      PREV_MEASYEAR = if_else(!is.na(DIA_DELTA) & FRST_DIA_EST > 3, PREV_MEASYEAR, NA)
    )

  # This generally completes in 4 iterations; if we hit 10 something's wrong.
  if (iterations > 10) {
    print("Too many iterations")
    break
  }

  prev_measyears <- tree_ingrown_three |>
    filter(!is.na(PREV_MEASYEAR)) |>
    select(CN, PREV_MEASYEAR)
}

tree_ingrown_three |>
  group_by() |>
  summarize(
    COUNT = n(),
    MISSING = sum(is.na(FRST_DIA_EST), na.rm = TRUE) / COUNT,
    MISSING_ONE = sum(is.na(FRST_DIA_EST_ONE), na.rm = TRUE) / COUNT,
    MISSING_TWO = sum(is.na(FRST_DIA_EST_TWO), na.rm = TRUE) / COUNT,
    HIT = sum(FRST_DIA_EST <= 3, na.rm = TRUE) / COUNT,
    HIT_ONE = sum(FRST_DIA_EST_ONE <= 3, na.rm = TRUE) / COUNT,
    HIT_TWO = sum(FRST_DIA_EST_TWO <= 3, na.rm = TRUE) / COUNT,
    .groups = 'keep'
  ) |>
  ungroup() |>
  pivot_longer(everything()) |>
  knitr::kable()
```

How'd we do?

```{r plot_tree_ingrown_three}
tree_ingrown_three_validation <- tree_ingrown_three |>
  select(CN, MEASYEAR, SPCD, # STATECD, COUNTYCD, PLOT, SUBP, TREE, MEASYEAR, SPCD,
         FRST_MEASYEAR, FRST_DIA_EST, FRST_DIA_EST_ONE, FRST_DIA_EST_TWO) |>
  filter(FRST_MEASYEAR != MEASYEAR) |>
  #head(1000) |>
#  left_join(
#    tree_ingrown |> select(STATECD, COUNTYCD, PLOT, SUBP, TREE, MEASYEAR, DIA),
#    by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE, FRST_MEASYEAR == MEASYEAR)
#  ) |>
  left_join(species_mixin, by = join_by(SPCD)) |>
  group_by(JENKINS_SPGRP_NAME) |>
  mutate(GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())) |>
  ungroup() |>
  select(CN, GROUP_NAME, FRST_DIA_EST, FRST_DIA_EST_ONE, FRST_DIA_EST_TWO) |>
  rename(
#    `Measured` = DIA,
    `Estimated` = FRST_DIA_EST,
    `Est - 1%` = FRST_DIA_EST_ONE,
    `Est - 2.5%` = FRST_DIA_EST_TWO
  ) |>
  melt(
    id.vars = c("CN", "GROUP_NAME"),
    variable.name = "Series",
    value.name = "Growth"
  ) |>
  filter(!is.na(Growth))
ggplot(
  tree_ingrown_three_validation,
  aes(Growth, fct_rev(fct_infreq(GROUP_NAME)), fill = `Series`)
) +
  geom_vline(xintercept = 3, linetype = "dashed") +
  geom_vline(xintercept = 5, linetype = "dotted") +
  geom_boxplot(outlier.size = 0.1) +
  scale_fill_discrete(breaks = rev(levels(tree_ingrown_three_validation$Series))) +
  theme_bw() +
  ggtitle("Smallest Projected Diameter in Simulation Window") +
  xlab(bquote("Diameter " ~(inch))) +
  ylab("Species Group")
```

So the majority of trees that establish are projected to be over 3" diameter
at all times within the simulation window.

We will need to use a different method of calculating ingrowth.

### Ingrowth Rate

Possible ways of doing ingrowth by rate:

* Ingrowth by Stem Rate
* Ingrowth by BAI

_Ingrowth by Stem Rate_

Compute a per-species, per-plot "trees-per-year" rate of ingrowth. Then, for each timestep, I can compute the number of trees that should ingrow during that timestep. They would be added as maximum size trees: 3" DBH.

Advantages:

- Tree-level simulation plays well with FVS
- In the long term, this will converge on a population of trees indistinguishable from the "inject specific trees" approach.

Disadvantages:

- At the start of simulation there may be a dip in stand-level biomass since pre-simulation trees ingrow at 5" DBH, and once the simulation starts they ingrow at 3" DBH. Essentially, all the trees between 3" and 5" DBH at the start of the simulation are "forgotten", unless we do something to try to make up for that. But see below for the caveat re: crowding.

_Ingrowth by BAI_

Compute a per-species, per-plot "basal area per year" rate of ingrowth. Then, for each timestep, I can compute the number of 3" DBH trees that should ingrow during that timestep to provide the target BA.

BAI - Basal Area Increment - m^2 x ha^-1 x yr^-1

Advantages:

- No dip in biomass at the start of simulation, since we're adding the right amount of biomass.

Disadvantages:

- Adds more trees. FVS is pretty assertive about killing trees due to crowding, so this is likely to result in more trees dying than would be observed on the plot. This could result in net lower biomass in the long term, especially since FVS will kill larger trees as well as smaller trees.

#### Stem Ingrowth Rate

We want:

* stems
* of each species
* per acre
* per year (or does this vary over time?)
* on each plot

Complications:

* Some saplings have unidentified species, flagged as SPECIES == "spp."
  In theory we could walk forward in time for some of these trees and
  find a later record for the tree that identifies the specific species.
  This will not work for trees that ingrow in the latest inventory.
  For now, we impute the most common non-spp. species of the genus on the plot.

* Some species that ingrow are not supported by FVSne.
  When finding the most common species on a plot, restrict to those
  species supported by FVSne.
  
* Some genuses (Amelanchier, Crataegus, Malus) are handled only at the genus
  level by FVSne. There are many more that have both genus and species level
  handling. For things that are handled at the genus level, we have the option
  of invoking that.

We find the most common thing that is both inventoried on the plot AND
supported by FVSne, and move things that are not supported into the most
common.

```{r tree_growth_with_fixed_spcd}
# mcs == Most Common Species
mcs_plot <- tree_growth |>
  filter(!is.na(FVS_SPCD)) |>
  group_by(STATECD, COUNTYCD, PLOT, GENUS, SPCD) |>
  summarize(COUNT = n(), .groups = "keep") |>
  ungroup() |>
  group_by(STATECD, COUNTYCD, PLOT, GENUS) |>
  filter(COUNT == max(COUNT)) |>
  filter(SPCD == min(SPCD)) |> # break ties by SPCD
  ungroup() |>
  select(!COUNT) |>
  rename(SPCD_PLOT = SPCD)

mcs_county <- tree_growth |>
  filter(!is.na(FVS_SPCD)) |>
  group_by(STATECD, COUNTYCD, GENUS, SPCD) |>
  summarize(COUNT = n(), .groups = "keep") |>
  ungroup() |>
  group_by(STATECD, COUNTYCD, GENUS) |>
  filter(COUNT == max(COUNT)) |>
  filter(SPCD == min(SPCD)) |> # break ties by SPCD
  ungroup() |>
  select(!COUNT) |>
  rename(SPCD_COUNTY = SPCD)

mcs_state <- tree_growth |>
  filter(!is.na(FVS_SPCD)) |>
  group_by(STATECD, GENUS, SPCD) |>
  summarize(COUNT = n(), .groups = "keep") |>
  ungroup() |>
  group_by(STATECD, GENUS) |>
  filter(COUNT == max(COUNT)) |>
  filter(SPCD == min(SPCD)) |> # break ties by SPCD
  ungroup() |>
  select(!COUNT) |>
  rename(SPCD_STATE = SPCD)

mcs_overall <- tree_growth |>
  filter(!is.na(FVS_SPCD)) |>
  group_by(GENUS, SPCD) |>
  summarize(COUNT = n(), .groups = "keep") |>
  ungroup() |>
  group_by(GENUS) |>
  filter(COUNT == max(COUNT)) |>
  filter(SPCD == min(SPCD)) |> # break ties by SPCD
  ungroup() |>
  select(!COUNT) |>
  rename(SPCD_OVERALL = SPCD)

# Note that this leaves Crataegus (Hawthorn) as spp. - apparently FIA has
# passed on trying to identify species in Crataegus.
tree_growth_with_fixed_spcd <- tree_growth |>
  left_join(mcs_plot, by = join_by(STATECD, COUNTYCD, PLOT, GENUS)) |>
  left_join(mcs_county, by = join_by(STATECD, COUNTYCD, GENUS)) |>
  left_join(mcs_state, by = join_by(STATECD, GENUS)) |>
  left_join(mcs_overall, by = join_by(GENUS)) |>
  rename(SPCD_ORIG = SPCD) |>
  mutate(SPCD = coalesce(SPCD_PLOT, SPCD_COUNTY, SPCD_STATE, SPCD_OVERALL, SPCD_ORIG)) |>
  select(SPCD | !any_of(names(species_mixin))) |>
  left_join(species_mixin, by = join_by(SPCD))
```

How'd we do?

```{r check fix to spcd}
rbind(
  tree_growth |>
    filter(is.na(FVS_SPCD)) |>
    group_by(GENUS) |>
    summarize(TREE_COUNT = n()) |>
    ungroup() |>
    mutate(SERIES = "Uncorrected"),
  tree_growth_with_fixed_spcd |>
    filter(is.na(FVS_SPCD)) |>
    group_by(GENUS) |>
    summarize(TREE_COUNT = n()) |>
    ungroup() |>
    mutate(SERIES = "Corrected")
) |>
  group_by(SERIES) |>
  summarise(SPECIES_COUNT = n(), TREE_COUNT = sum(TREE_COUNT))
```

These are the cases where we're unable to find a species code for FVSne:
```{r fvsne_unhandled_trees}
plot_count_mixin <- tree_growth_with_fixed_spcd |>
  filter(is.na(FVS_SPCD)) |>
  distinct(STATECD, COUNTYCD, PLOT, SPCD) |>
  group_by(SPCD) |>
  summarize(PLOT_COUNT = n()) |>
  ungroup()

fvsne_unhandled_trees <- tree_growth_with_fixed_spcd |>
  # Filter to the most recent record for each tree
  group_by(STATECD, COUNTYCD, PLOT, SUBP, TREE) |>
  arrange(desc(MEASYEAR)) |>
  filter(row_number() == 1) |>
  ungroup() |>
  mutate(BA = conv_multiunit(6 * pi * DIA ^ 2, "ft2 / acre", "m2 / hectare")) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  mutate(TOTAL_STAND_BA = sum(BA, na.rm = TRUE)) |>
  ungroup() |>
  filter(is.na(FVS_SPCD)) |>
  mutate(BA_FRAC = BA / TOTAL_STAND_BA) |>
  group_by(STATECD, COUNTYCD, PLOT, SPCD) |>
  summarize(
    BA = sum(BA, na.rm = TRUE),
    TOTAL_STAND_BA = max(TOTAL_STAND_BA, na.rm = TRUE),
    BA_FRAC = sum(BA_FRAC, na.rm = TRUE),
    .groups = 'keep'
  ) |>
  ungroup() |>
#  group_by(SPCD) |>
#  summarize(
#    TREE_COUNT = n(),
#    BA_FRAC = max(BA_FRAC, na.rm = TRUE)
#  ) |>
#  ungroup() |>
  filter(BA_FRAC > 0) |>
  left_join(plot_count_mixin, by = join_by(SPCD)) |>
  left_join(species_mixin, by = join_by(SPCD)) |>
  mutate(SCIENTIFIC_NAME = factor(SCIENTIFIC_NAME)) |>
  select(SCIENTIFIC_NAME, BA, BA_FRAC, TOTAL_STAND_BA)
```

```{r plot fvsne_unhandled_trees}
fvsne_unhandled_trees |>
  group_by(SCIENTIFIC_NAME) |>
  mutate(Species = paste0(SCIENTIFIC_NAME, ", n=", n())) |>
  ungroup() |>
  ggplot(aes(y = BA_FRAC, fill = Species)) +
  geom_boxplot() +
  scale_x_continuous(breaks = NULL) +
  scale_y_log10() +
  theme_bw() +
  ggtitle("Basal Area of tree species not handled by FVSne") +
  xlab("Species") +
  ylab("Basal Area (fraction of total plot BA)")
  
  
```

Let's find out how many stems of each (corrected) species ingrow per year.

```{r ingrowth_stem_rate}
time_mixin <- stand_stats |>
  distinct(STATECD, COUNTYCD, PLOT, MEASYEAR) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    FIRST_YEAR = min(MEASYEAR),
    LAST_YEAR = max(MEASYEAR),
    .groups = "keep"
  ) |>
  ungroup()

ingrowth_stem_rate <- tree_growth_with_fixed_spcd |>
  semi_join(grm_ingrown, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE, MEASYEAR)) |>
  left_join(time_mixin, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  group_by(STATECD, COUNTYCD, PLOT, SPCD, FIRST_YEAR, LAST_YEAR) |>
  summarize(
    COUNT = n(),
    # Don't use TPA_UNADJ; microplot multipliers are inaccurate here.
    # Reason: once a tree reaches 5" DBH, its peers on the rest of the subplot
    # are inventoried in the TREE table, so multiplying by the microplot
    # multiplier would replicate microplot trees across the subplots AND
    # count the trees on subplots, which is double-counting, which is wrong.
    COUNT_PER_ACRE = COUNT * 6,
    .groups = "keep"
  ) |>
  ungroup() |>
  left_join(species_mixin, by = join_by(SPCD)) |>
  group_by(JENKINS_SPGRPCD) |>
  mutate(
    NUM_PLOTS = n(),
    GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", NUM_PLOTS)
  ) |>
  ungroup() |>
  mutate(
    COUNT_PER_HECTARE = conv_unit(COUNT_PER_ACRE, "hectare", "acre"),
    RATE = COUNT / (LAST_YEAR - FIRST_YEAR),
    RATE_PER_ACRE = COUNT_PER_ACRE / (LAST_YEAR - FIRST_YEAR),
    RATE_PER_HECTARE = COUNT_PER_HECTARE / (LAST_YEAR - FIRST_YEAR)
  )
```

```{r plot-ingrowth_stem_rate}
stand_stats_mixin <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  arrange(MEASYEAR) |>
  filter(row_number() == 1) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, STDAGE, BALIVE_METRIC, QMD)

ingrowth_stem_rate |>
  left_join(stand_stats_mixin, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  ggplot(aes(x = QMD, y = RATE_PER_HECTARE)) +
  geom_bin2d(bins = 50) +
  scale_fill_continuous(name = "Number of Plots", transform = "log10", limits = c(1, 1000)) +
  facet_wrap(~GROUP_NAME) +
  theme_bw() +
  #xlab(bquote("Basal Area" ~(m^2 %.% ha^-1))) +
  xlab(bquote("QMD (cm)")) +
  ylab(bquote("Ingrowth Rate" ~(stems %.% ha^-1 %.% yr^-1))) +
  ggtitle("Per-Plot Ingrowth Stem Rate")
```

Ok, who are these outliers?
```{r stem rate outliers}
knitr::kable(
  ingrowth_stem_rate |>
  arrange(desc(RATE)) |>
  head(10) |>
  left_join(stand_stats_mixin, by = join_by(STATECD, COUNTYCD, PLOT)) 
)
```

Looking, for example, at ALSTKCD we find that these plots are fully stocked
or overstocked, indicating that they have large cohorts of young trees all
coming of age at the same time.


```{r stem rate summary}
summary(ingrowth_stem_rate)
```

Looks good, but what we actually needed was height, not diameter.

#### Ingrowth Height

For FVS ingrowth, we also need height when the tree is 3" DBH. FVS will 
adjust this, so it only needs to be close.

We pick fro 3 to 9 trees closest to 3" DBH, do a linear interpolation of their
height to what it might be at 3" DBH, and average them.

> Poletimber-sized trees
> - softwoods 5 inches and <9 inches d.b.h.
> - hardwoods 5 inches and <11 inches d.b.h.

- HT_PLOT - per-species height at 3" DBH modeled only from trees on the plot
- HT_STATE - per-species height at 3" DBH modeled from trees in the state
- HT_NE - per-species height at 3" DBH for the entire northeast
- HT_MIN - same as HT_NE, but populated even if fewer than 3 trees can be found

```{r tree_growth_ht}
ecosubcd_mixin <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  arrange(MEASYEAR) |>
  filter(row_number() == 1) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, ECOSUBCD) |>
  mutate(ECOCD = substr(ECOSUBCD, 1, nchar(ECOSUBCD) - 1))

trees_for_ht_estimation <- tree_growth_with_fixed_spcd |>
  filter(2.5 < DIA & DIA < 6) |>
  group_by(STATECD, COUNTYCD, PLOT, SUBP, TREE) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() == 1) |>
  ungroup() |>
  # Overcome a data issue: some trees have no HT, but have PREV_HT
  mutate(HT = coalesce(HT, PREV_HT), DIA = coalesce(DIA, PREV_DIA)) |>
  filter(!is.na(HT) & !is.na(DIA)) |>
  left_join(ecosubcd_mixin, by = join_by(STATECD, COUNTYCD, PLOT))

tree_growth_ht_ecosubcd <- trees_for_ht_estimation |>
  group_by(ECOSUBCD, SPCD) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() <= 9) |>
  mutate(HT_ECOSUBCD = HT * 3 / DIA) |>
  filter(n() >= 3) |>
  summarize(HT_ECOSUBCD = mean(HT_ECOSUBCD), .groups = "keep") |>
  ungroup()

tree_growth_ht_ecocd <- trees_for_ht_estimation |>
  group_by(ECOCD, SPCD) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() <= 9) |>
  mutate(HT_ECOCD = HT * 3 / DIA) |>
  filter(n() >= 3) |>
  summarize(HT_ECOCD = mean(HT_ECOCD), .groups = "keep") |>
  ungroup()

tree_growth_ht_ne <- trees_for_ht_estimation |>
  group_by(SPCD) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() <= 9) |>
  mutate(HT_NE = HT * 3 / DIA) |>
  filter(n() >= 3) |>
  summarize(HT_NE = mean(HT_NE), .groups = "keep") |>
  ungroup()

tree_growth_ht_min <- trees_for_ht_estimation |>
  group_by(SPCD) |>
  arrange(abs(DIA - 3)) |> # closest to 3" first
  filter(row_number() <= 9) |> 
  mutate(HT_MIN = HT * 3 / DIA) |>
  summarize(HT_MIN = mean(HT_MIN)) |>
  ungroup()

tree_growth_ht <- tree_growth_with_fixed_spcd |> # unfiltered tree growth
  semi_join(grm_ingrown, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE)) |>
  distinct(STATECD, COUNTYCD, PLOT, SPCD) |>
  left_join(ecosubcd_mixin, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  left_join(tree_growth_ht_ecosubcd, by = join_by(ECOSUBCD, SPCD)) |>
  left_join(tree_growth_ht_ecocd, by = join_by(ECOCD, SPCD)) |>
  left_join(tree_growth_ht_ne, by = join_by(SPCD)) |>
  left_join(tree_growth_ht_min, by = join_by(SPCD)) |>
  mutate(HT = coalesce(HT_ECOSUBCD, HT_ECOCD, HT_NE, HT_MIN))
```

What diameters of trees are we selecting?

```{r ht dia selection limited dia}
min_tree <- tree_growth_with_fixed_spcd |>
  filter(2.5 < DIA & DIA < 6) |>
  group_by(STATECD, COUNTYCD, PLOT, SUBP, TREE) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() == 1) |>
  ungroup() |>
  # Overcome a data issue: some trees have no HT, but have PREV_HT
  mutate(HT = coalesce(HT, PREV_HT), DIA = coalesce(DIA, PREV_DIA)) |>
  filter(!is.na(HT) & !is.na(DIA)) |>
  left_join(ecosubcd_mixin, by = join_by(STATECD, COUNTYCD, PLOT))

ht_ecosubcd_mixin <- min_tree |>
  group_by(ECOSUBCD, SPCD) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() <= 9) |>
  mutate(HT_ECOSUBCD = HT * 3 / DIA) |>
  filter(n() >= 3) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, SUBP, TREE, HT_ECOSUBCD)

ht_ecocd_mixin <- min_tree |>
  group_by(ECOCD, SPCD) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() <= 9) |>
  mutate(HT_ECOCD = HT * 3 / DIA) |>
  filter(n() >= 3) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, SUBP, TREE, HT_ECOCD)

ht_ne_mixin <- min_tree |>
  group_by(SPCD) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() <= 9) |>
  mutate(HT_NE = HT * 3 / DIA) |>
  filter(n() >= 3) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, SUBP, TREE, HT_NE)

ht_min_mixin <- min_tree |>
  group_by(SPCD) |>
  arrange(abs(DIA - 3)) |> # closest to 3" first
  filter(row_number() <= 9) |> 
  mutate(HT_MIN = HT * 3 / DIA) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, SUBP, TREE, HT_MIN)

tree_growth_ht_whence <- min_tree |>
  select(STATECD, COUNTYCD, PLOT, SUBP, TREE, SPCD, DIA) |>
  left_join(ht_ecosubcd_mixin, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE)) |>
  left_join(ht_ecocd_mixin, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE)) |>
  left_join(ht_ne_mixin, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE)) |>
  left_join(ht_min_mixin, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE)) |>
  mutate(HT = coalesce(HT_ECOSUBCD, HT_ECOCD, HT_NE, HT_MIN)) |>
  filter(!is.na(HT)) |>
  left_join(species_mixin, by = join_by(SPCD))
```

```{r plot ht dia distribution}
tree_growth_ht_whence |>
  ggplot(aes(y = DIA, fill = JENKINS_SPGRP_NAME)) +
  geom_boxplot(outlier.size = 0.1) +
  scale_fill_discrete(
    name = "Species Group"
  ) +
  scale_x_continuous(labels = NULL) +
  theme_bw() +
  ylab("Measured Diameter (inches)") +
  ggtitle("Diameter of trees selected for estimation")
```

```{r plot estab ht vs dia}
bins = (max(tree_growth_ht_whence$DIA) - min(tree_growth_ht_whence$DIA)) * 10
tree_growth_ht_whence |>
  ggplot(aes(x = DIA, y = HT)) +
  geom_bin_2d(bins = bins) +
  geom_vline(xintercept = 3, color = "red", linetype = "dashed") +
  scale_fill_continuous(name = "Number of Trees", transform = "log10") +
  facet_wrap(~JENKINS_SPGRP_NAME) +
  #scale_color_discrete(
  #  name = "Species Group"
  #) +
  theme_bw() +
  xlab("Measured Diameter (inches)") +
  ylab("Estimated Height at 3\" DBH (feet)") +
  ggtitle("Estimated Height vs. Diameter of trees selected for estimation")
```

Are we missing height for any ingrowth?
```{r validate height projection}
stopifnot(
  ingrowth_stem_rate |>
    distinct(STATECD, COUNTYCD, PLOT, SPCD) |> 
    left_join(tree_growth_ht, by = join_by(STATECD, COUNTYCD, PLOT, SPCD)) |>
    # Remove the one shellbark hickory tree that doesn't get a height
    filter(SPCD != 405) |>
    filter(is.na(HT)) |>
    nrow() == 0
)
```

### Ingrowth Model

Combining these, we can gather per-plot the nuber of stems of each species
that establish each year, and the height at establishment.

```{r ingrowth_by_stem}
ingrowth_by_stem <- ingrowth_stem_rate |>
  left_join(tree_growth_ht, by = join_by(STATECD, COUNTYCD, PLOT, SPCD))

ingrowth_by_stem |>
  group_by(JENKINS_SPGRPCD) |>
  mutate(
    PLOT_COUNT = n(),
    GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())
  ) |>
  ungroup() |>
  ggplot(aes(
    fct_rev(reorder(GROUP_NAME, PLOT_COUNT)),
    HT,
    fill = fct_rev(reorder(GROUP_NAME, PLOT_COUNT))
  )) +
  geom_boxplot(outlier.size = 0.1) +
  scale_x_discrete(labels = NULL) +
  theme_bw() +
  xlab("Species Group") +
  ylab("Height at 3\" DBH (feet)") +
  scale_fill_discrete(name = "Species Group") +
  ggtitle("Estimated Tree Height at 3\" DBH")
```

```{r summary ingrowth_by_stem}
summary(ingrowth_by_stem)
```

# Run FVS

> TODO nik: use Stand replication for random seeds.

We run FVS on the same stands in many different ways. The FVS UI
has a method of replicating stands so that the same stand can be
run in different ways in the same run. To do this, it creates a copy
of the keyword file section, adding the replica number to the stand
identifier using "_N" format. So, for example, replica 2 of stand
"230202502686" becomes "230202502686_2"

## Generate Keyfile

An FVS run is scripted by a keyfile. The keyfile describes how to run the
model and extensions, including where to read input, all parameters to
control processing, and where to write output.

The keyfile is structured by stand; each stand is a separate run of the
model.

To run in parallel, a separate keyfile must be generated for each partition
to be run in parallel. Each partition must send its output to a separate
location, and these can be assembled into a single output as a post-
processing step.

### Stand Identification

For each stand, we need:

-  StdIdent: Stand Identifier, from fia.FVS_STANDINIT_PLOT.FVS_STAND_ID
-  StandCN: Stand control number, from fia.PLOT.CN
-  MgmtId: Management ID, for no treatment, this is NONE

### Time

We will run the model from first measurement year to last measurement year,
with as many 10-year timesteps as we can get. We will add an initial timestep
that is less than 10 years to get to a 10 year boundary. We choose a 10-year
timestep because FVSne is calibrated to 10 years, and running with a different
length timestep introduces bias. The bias is less with shorter timesteps than
with longer timesteps, so using a short timestep to adjust length introduces
less bias than using a long timestep.

There are two years of interest for each plot: FIRSTYEAR, which is
the minimum fia.PLOT.MEASYEAR for the modern plot design; and
LASTYEAR, which is the maximum of the same.

-  InvYear: Inventory Year, set to FIRSTYEAR
-  TimeInt: Time Interval, there may be two entries:
   -  TimeInt 0: Default time interval, 10 years
   -  TimeInt 1: First cycle time interval, (LASTYEAR - FIRSTYEAR) %% 10
-  NumCycle: Number of cycles to run, int((LASTYEAR - FIRSTYEAR) / 10) + 1,
   and +1 again if there is a TimeInt 1.

Note that the number of cycles is the number of full 10-year cycles
plus one if there is a short first cycle. Since metrics are printed at the start
of each cycle, we need LASTYEAR to be the first year of a cycle, and work
backwards from that.

### FIA Inputs

There are two inputs, Stand and Tree. Both are configured to use a database
query.

Within a Database subsection:

-  DSNIn: Data Source Name (DSN) for input; SQLite filename
-  StandSQL: SQL query to fetch a stand, given %Stand_CN%
-  TreeSQL: SQL query to fetch all trees for a stand, given %Stand_CN%

### Regeneration, Ingrowth, and Establishment

The Northeastern variant is a partial establishment model, so it does not
automatically perform natural regeneration. We will therefore use modeled
ingrowth from the FIA data.

Example from estab model docs:
```
IF
(FRAC(CYCLE/2) EQ 0 AND CYCLE GT 3)
THEN
ESTAB
NATURAL 0.0 10.0 50.0
NATURAL 0.0 3.0 20.0
MERCHPREP 0.0 0.0
TALLYONE 9.0
END
ENDIF
```

> This
> Event Monitor file will add the 70 trees per acre every 20 years after
> cycle 3. Cycle lengths are assumed to be 10 years. A MECHPREP or
> BURNPREP keyword record specifying 0.0 percent site preparation is
> needed to keep all plots untreated.

Under the NATURAL keyword:

> Heights are bounded
> between the minimum establishment height
> listed in table 1 and the height of a tree
> 3 inches d.b.h. Heights are assigned at the
> end of the cycle unless the cycle length is
> longer than 5 years. In this case, tree heights
> are assigned at 6 years, then a height incre-
> ment is predicted for years 6 through the end
> of the cycle. See figure 6 for an example of
> assigning heights.

Figure 6:
```
STDIDENT
EXAMPLE2 USING THE “NATURAL” KEYWORD
DESIGN 10.0 0.0
STDINFO 104.0 260.0 0.0 315.0 30.0 45.0
INVYEAR 2000.0
TIMEINT 1.0 5.0
TIMEINT 2.0 5.0
NUMCYCLE 10.0
NOTREES
ESTAAB 2000.0
NATURAL 2009.0 3.0 250.0 . . 5.5
NATURAL 2009.0 7.0 75.0  . . 8.0
NATURAL 2009.0 10.0 120.0 . . 6.0
END
PROCESS
STOP
```

In this example, STOCKADJ is ignored / not needed - STOCKADJ only affects
built-in regeneration. TALLYONE 9.0 ensures that all NATURAL trees are
promoted prior to the end of the cycle. From the example output, a TALLYTWO
is automatically scheduled, presumably in response to the TALLYONE.

NB: The structure of the NATURAL keyword is:
> NATURAL 1:YEAR 2:SPECIES 3:TPA 4:SURVIVAL 5:AGE 6:HEIGHT 7:SHADE_CODE

So, I think we need:

- IF ... (every cycle)
- THEN
- ESTAB
- NATURAL 0 SPECIES TPA [no survival] [no age] HEIGHT [no shade]
- MERCHPREP 0
- BURNPREP 0
- TALLYONE 9
- END
- ENDIF

...which will insert TPA trees of SPECIES at HEIGHT at year 6 of the cycle,
and establish them at year 9.

### Fire and Fuels

Carbon is calculated by the fire and fuels extension.

-  FMIn: Starts configuration of Fire and Fuels extension
-  CarbRept: Carbon Report; save to database (2)
-  CarbCut: Harvested Carbon Report; disable (0)
-  CarbCalc: Carbon calculation; metric (1)
-  FuelOut: Fuel Output, disable (0)
-  FuelRept: Fuel Report, disable (0)

Fire and Fuels also interacts with the database extension; it provides additional
Database keywords to configure Fire and Fuels output to the database.

Within a Database section:

-  CarbReDB: FVS_Carbon and FVS_Hrv_Carbon tables: database (2)
-  FuelReDB: FVS_Consumption table: database (2)
-  FuelsOut: FVS_Fuels table: database (2)


### Translating to FVS

For each timestep, we will find the trees that establish during that timestep,
and add a record describing the tree at the time of establishment.

Note that FIA establishes at 5" DBH, whereas FVS establishes at 3" DBH,
and FVS puts an upper bound on height based on expectations for 3" DBH trees.
We can follow PREV_TRE_CN backward to find when the tree was 3" DBH; note
that this might be a long time ago. As an alternative, we could multiply TPA
by DIA^2 / 3^2 and set the height to (3/DIA)*HT - this would give us the same
total basal area in trees of reduced height.

Because of the way time is set up in FVS, establishment is scheduled for the
year prior to the start of a cycle. Within the cycle, each tree that is
established gets its own Natural keyword. This specifies:

-  Year: The (actual) year in which the tree is marked as INGROWTH
-  Species: The 2-character FVS species code
-  TPA: Trees per acre; prefer the TPA from the tree record over TPAGROW_UNADJ
   from the establishment record (the two should be the same)
-  Survivorship: Always 100%
-  Age: average age at the year of establishment. Leave this blank.
-  Height: Average height.  Use fia.TREE.HT, but see above note.
-  Shade: 0 = uniform, 1 = prefer shade; 2 = prefer sun. Use 0.

FVS is semi-spatial; it is aware of subplots and microplots, and how many
trees are on each. There does not appear to be a way to designate which
subplot a tree establishes on; presumably, the TPA is distributed across
subplots.

### Output

We use database output; it is easiest to work with. Many output options take
a parameter that is 0 to disable output, 1 for file output, 2 for database
output, and 3 for both file and database output.

Within a Database section:

-  DSNOut: Data Source Name (DSN) for output; SQLite filename
-  Summary: Configure FVS_Summary; use version 2
-  Computdb: Configure FVS_Compute; disable
-  MisRpts: Configure Mistletoe reports; disable

### Processing Order

Each stand has its own section of the keyword file, including everything from
StdIdent to Process. Each stand is processed before moving to the next stand.

At the end of all stands, the Stop keyword tells FVS to exit cleanly.

### Example

```
StdIdent
230202502686        NoManagement
StandCN
52967848010538
MgmtId
NONE
InvYear         2002
TimeInt            0        10
TimeInt            1         2
NumCycle           3

FMIn
CarbRept           2
CarbCut            2
CarbCalc           0         1    0.0425         9        11
FuelOut            2
FuelRept           2
End

Database

DSNIn
SQLite_FIADB_ENTIRE.db

StandSQL
SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL

TreeSQL
SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL

DSNOut
FVS_NoManagement_NONE.db

Summary            2
Computdb           0         1
MisRpts            2
CarbReDB           2
FuelReDB           2
FuelsOut           2

END

Process

Stop
```

### Keword File Generation

Gather stand IDs and CNs for keywordfile generation.

We gather two series of stands:

-  stands_projected is a list of stands and inventory years to grow out to 2025
-  stands_surveyed is a list of stands and inventory years to grow for 0 years
   in each survey year.


Find the stands we want to project; these are the grow-only stands starting
in their first measurement year.

```{r stands_projected}
timeframe <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    INVYR = min(INVYR),
    FIRSTYEAR = min(MEASYEAR, na.rm = TRUE),
    LASTYEAR = max(MEASYEAR, na.rm = TRUE),
    .groups = "keep"
  ) |>
  ungroup()


fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
fia_fvs_standinit_plot <- tbl(fia, 'FVS_StandInit_Plot') |>
  select(STAND_CN, STAND_ID)

stands_projected <- tbl(fia, 'PLOT') |>
  select(CN, STATECD, COUNTYCD, PLOT, INVYR) |>
  rename(STAND_CN = CN) |>
  inner_join(timeframe, by = join_by(STATECD, COUNTYCD, PLOT, INVYR), copy = TRUE) |>
  left_join(fia_fvs_standinit_plot, by = join_by(STAND_CN)) |>
  collect()

dbDisconnect(fia)
remove(fia, fia_fvs_standinit_plot)
```


```{r regen_table}
regen_table <- ingrowth_by_stem |>
  filter(!is.na(FVS_SPCD)) |>
  left_join(stands_projected, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  rename(
    species = FVS_SPCD,
    density = COUNT_PER_ACRE,
    height = HT
  ) |>
  select(STAND_ID, species, density, height)
keyfile_regen_section <- function(StandID, Timestep) {
  pertinent <- regen_table |>
    filter(STAND_ID == as.character(StandID)) |>
    mutate(
      density = floor(density * Timestep),
      # Cap density at 1000 TPA no matter what
      # the timestep - this is an FVS limitation.
      density = case_when(
        density > 1000 ~ 1000,
        .default = density
      ),
      height = floor(height)
    ) |>
    filter(density > 0)
  if (nrow(pertinent) > 0) {
    fvs_Estab(pertinent)
  } else {
    ''
  }
}
```

When generating keyword files, we create one per partition,
distributing across partitions using round-robin on STAND_ID.

keywordfile_section is a function to generate a keywordfile section from
information about a run and a stand.

It cooks a StdIdent that can be parsed later:

- The input StandID
- _Y followed by the number of years in a timestep
- _R followed by the random seed


```{r keywordfile_section}
keywordfile_section <- function(
    Title, MgmtId, StandID, StandCN,
    FirstYear, LastYear, Timestep,
    Partition, RandSeed = NA
  ) {
  if (!is.na(RandSeed)) {
    StdIdent <- c(
      fvs_kwd0("StdIdent"),
      paste0(StandID, "_Y", Timestep, "_R", RandSeed, " ", Title)
    )
    # Careful: RannSeed != RandSeed
    RannSeed <- fvs_kwd1("RANNSEED", RandSeed)
  } else {
    StdIdent <- c(
      fvs_kwd0("StdIdent"),
      # RannSeed isn't 0, but 0 is an illegal random seed so a fine flag value
      paste0(StandID, "_Y", Timestep, "_R0", " ", Title))
    # Careful: RannSeed != RandSeed
    RannSeed <- c()
  }
  TimeConfig <- fvs_TimeConfig(FirstYear, LastYear, Timestep)
  if (FirstYear == LastYear) {
    Regen <- c() # Don't do regen for 0-year runs
  } else {
    Regen <- keyfile_regen_section(StandID, Timestep)
  }
  c(
    StdIdent,
    fvs_kwd0("StandCN"),
    StandCN,
    fvs_kwd0("MgmtId"),
    MgmtId,
    TimeConfig,
    RannSeed,
    fvs_kwd0("FMIn"), # Fire and Fuels Extension
    fvs_kwd0("CarbRept"),
    fvs_kwd0("CarbCut"),
    fvs_kwd5("CarbCalc", 1, 1, 0.0425, 9, 11),
    fvs_kwd0("FuelOut"),
    fvs_kwd0("FuelRept"),
    fvs_kwd0("End"), # FMIn
    fvs_kwd0("Database"), # Database extension
    fvs_kwd0("DSNIn"),
    "SQLite_FIADB_ENTIRE.db",
    fvs_kwd0("StandSQL"),
    "SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'",
    fvs_kwd0("EndSQL"), # StandSQL
    fvs_kwd0("TreeSQL"),
    "SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'",
    fvs_kwd0("EndSQL"), # TreeSQL
    fvs_kwd0("DSNOut"),
    paste0("FVS_", Title, "_", MgmtId, "_", Partition, ".db"),
    fvs_kwd1("Summary",  2),
    fvs_kwd2("Computdb", 0, 1),
    fvs_kwd1("MisRpts",  2),
    fvs_kwd1("CarbReDB", 2),
    fvs_kwd1("FuelReDB", 2),
    fvs_kwd1("FuelsOut", 2),
    fvs_kwd0("End"), # Database
    Regen,
    fvs_kwd0("Process")
  )
}

```

The first set of keyword files is to project from the first measurement year to 2025.

```{r NRSGrowOnly GROW}
num_partitions <- 30 # The number of simultaneous processes to use
title <- "NRSGrowOnly"
mgmtid <- "GROW"
for (partition in 1:num_partitions) {
  filename <- paste0("data/fvs/FVS_", title, "_", mgmtid, "_", partition, ".key")
  if (!USE_CACHE | !file.exists(filename)) {
    unlink(filename)
    print(paste0("Writing ", filename))
    pbapply(
      expand.grid(timestep = c(1, 10), rannseed = c(1, 3, 5)),
      1,
      \(runconfig) {
        timestep <- runconfig["timestep"]
        rannseed <- runconfig["rannseed"]
        apply(
          stands_projected |> 
            filter((as.numeric(STAND_ID) %% num_partitions) == (partition - 1)) |>
            arrange(STAND_ID, FIRSTYEAR),
          1,
          function(row) {
            write_lines(
              keywordfile_section(
                title,
                mgmtid,
                row['STAND_ID'],
                row['STAND_CN'],
                row['FIRSTYEAR'],
                row['LASTYEAR'],
                timestep,
                partition,
                rannseed
              ),
              filename,
              append = TRUE
            )
          }
        )
      }
    )
    write_lines("Stop", filename, append = TRUE)
  }
}
```

The second run is a zero-year projection to have FVS calculate the carbon
in surveyed stands in each year they are surveyed.

```{r stands_surveyed}
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
fia_fvs_standinit_plot <- tbl(fia, 'FVS_StandInit_Plot') |>
  select(STAND_CN, STAND_ID)

stands_surveyed <- tbl(fia, 'PLOT') |>
  select(CN, STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR, DESIGNCD) |>
  filter(DESIGNCD == 1) |>
  rename(STAND_CN = CN) |>
  semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
  left_join(fia_fvs_standinit_plot, by = join_by(STAND_CN)) |>
  collect()

dbDisconnect(fia)
remove(fia, fia_fvs_standinit_plot)
```

The second run is to do a 0-year projection for each measurement year. These
are given management ID "SRVY".

```{r NRSGrowOnly SRVY}
# We're running 0-year timesteps, but FVS requires us to run at least one
# year, so we run 0-year timesteps for 1 year.
timestep <- 1
title <- "NRSGrowOnly"
mgmtid <- "SRVY"
for (partition in 1:num_partitions) {
  filename <- paste0("data/fvs/FVS_", title, "_", mgmtid, "_", partition, ".key")
  if (!USE_CACHE | !file.exists(filename)) {
    unlink(filename)
    print(paste0("Writing ", filename))
    apply(
      stands_surveyed |>
        filter((as.numeric(STAND_ID) %% num_partitions) == (partition - 1)) |>
        arrange(STAND_ID, MEASYEAR),
      1,
      function(row) {
        write_lines(
          keywordfile_section(
            title,
            mgmtid,
            row['STAND_ID'],
            row['STAND_CN'],
            row['MEASYEAR'],
            row['MEASYEAR'],
            timestep,
            partition
          ),
          filename,
          append = TRUE
        )
      }
    )
    write_lines("Stop", filename, append = TRUE)
  }
}
```

### Run FVS

```{r run_fvs}
# TODO nik: Run FVS directly from R.
# Batch file to run FVS in parallel:
# for %%p in (FVS_%1_%2_*.key) do del %%~np.db
# for %%p in (FVS_%1_%2_*.key) do start \FVS\FVSbin\FVSne.exe --keywordfile=%%p
# Run it as:
# runfvs.bat NRSGrowOnly GROW
# Could be clever and create a ".done" file for each ".key" file when done,
# and poll for existence of all of them.
```

# Results

## Fault Analysis

### Parse Problems

What errors and warnings do we get?
```{r fvs warnings}
mgmtid <- "GROW"
fvs_warnings <- NULL
for (partition in 1:num_partitions) {
  filename <- paste0("data/fvs/FVS_", title, "_", mgmtid, "_", partition, ".out")
  fvs_warnings <- bind_rows(
    fvs_warnings,
    read_lines(filename) |>
      as.data.frame(nm="text") |>
      # Filter to just initial STAND ID and WARNING lines
      filter(
        grepl("^ +STAND ID=", text) |
          grepl("WARNING:", text) |
          grepl("ERROR:", text)
      ) |>
      # Parse out the STAND ID and fill it into the following lines
      mutate(
        STAND_ID = case_when(
          grepl("^ +STAND ID=", text) ~ sub("^ +STAND ID= *([^ ]+) .*$", "\\1", text)
        )
      ) |>
      fill(STAND_ID) |>
      # Remove everything but warnings (which now have STAND_ID)
      filter(
        grepl("WARNING:", text) |
          grepl("ERROR:", text)
      )
  )
}
```

Find the distinct warnings
```{r distinct fvs warnings}
fvs_warnings_distinct <- fvs_warnings |>
  # Warnings have some leading text, the tag WARNING:,
  # then descriptive text; if there's a number in the descriptive text,
  # it's probably pulled from the data, so we chop off the descriptive
  # text starting at the first number to find the truly distinct warnings
  mutate(
    PROBLEM = case_when(
      grepl("WARNING:", text) ~ sub("^[*. ]*(.*WARNING: [^0-9]+)([0-9].*)?$", "\\1", text),
      grepl("ERROR:", text) ~ sub("^[*. ]*(.*ERROR: [^0-9]+)([0-9].*)?$", "\\1", text)
    ),
    PROBLEM = sub("\\s+$", "", PROBLEM)
  ) |>
  distinct(PROBLEM) |>
  arrange(PROBLEM)
knitr::kable(fvs_warnings_distinct)
```
### Keyword in Wrong Context

The keyword in wrong context could be a keyword file generation error; let's
track it down.
```{r keyword context}
debug_stand_id <- fvs_warnings |>
  filter(grepl(" WRONG CONTEXT ", text)) |>
  head(1) |>
  pull("STAND_ID")
fvs_warnings |>
  filter(STAND_ID == debug_stand_id)
```

RECORDS READ=4884 likely means the number of lines in the keyword file
(this is a FORTRAM program, where each line is a record).

Which partition is it in?
```{r keyword context partition}
as.numeric(sub("^([^_]+)_.*$", "\\1",debug_stand_id)) %% num_partitions
```

so the 26th partition, which is partition 27.

Here's the keyword file section:
```
StdIdent  
540003101366_Y1_R1 NRSGrowOnly
StandCN   
7554111010661
MgmtId    
GROW
InvYear         2000
TimeInt            0         1
TimeInt           19         1
NumCycle          19
RANNSEED           1
FMIn      
CarbRept  
CarbCut   
CarbCalc           1         1    0.0425         9        11
FuelOut   
FuelRept  
End       
Database  
DSNIn     
SQLite_FIADB_ENTIRE.db
StandSQL  
SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL    
TreeSQL   
SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL    
DSNOut    
FVS_NRSGrowOnly_GROW_27.db
Summary            2
Computdb           0         1
MisRpts            2
CarbReDB           2
FuelReDB           2
FuelsOut           2
End       
If                 0
mod(cycle,1) eq 0
Then      
Estab              0
MechPrep           0         0
BurnPrep           0         0
Sprout    
Natural            0        RM         6       100                  29         0
Natural            0        BG        42       100                  26         0
End       
EndIf     
Process   

```

Reading the full text of the output file gives more context:
```
********   FVS16 ERROR:  KEYWORD ENTERED IS USED IN WRONG CONTEXT AND WAS IGNORED.  RECORDS READ=4884
           DSNOUT DATA BASE CAN NOT BE REDEFINED. DSN FOR OUTPUT REMAINS: FVS_NRSGrowOnly_GROW_27.db
```

This appears after reporting the results of TreeSQL. So it looks like
there's an extra DSNOUT somewhere, but I don't see it.

This happens 6 times, only in partitions 27 and 29. All are for DSNOut, and
all report that the DSNOut is left as what I want it to be.

So we can ignore these errors.

### Keyword Ignored

Let's look at the KEYWORD IGNORED errors:
```{r keyword ignored}
debug_stand_id <- fvs_warnings |>
  filter(grepl(" KEYWORD IGNORED.", text)) |>
  head(1) |>
  pull("STAND_ID")
fvs_warnings |>
  filter(STAND_ID == debug_stand_id)
```

```{r keyword ignored partition}
as.numeric(sub("^([^_]+)_.*$", "\\1",debug_stand_id)) %% num_partitions
```

The relevant section of the output is:
```
STDIDENT
           STAND ID= 338300300218_Y1_R1                NRSGrowOnly                                                             

STANDCN    DATA BASE CONTROL NUMBER=22870841010661

MGMTID  
           MANAGEMENT ID= GROW

INVYEAR    INVENTORY YEAR= 1983

TIMEINT    ALL CYCLES;  PERIOD LENGTH=  1

 CARD NUM = 1957; KEYWORD FIELD = 'TIMEINT '
      PARAMETERS ARE:    41.0000000     1.0000000     0.0000000     0.0000000     0.0000000     0.0000000     0.0000000
      COL 11 TO 80 ='        41         1                                                  '

********   FVS04 ERROR:  A REQUIRED PARAMETER IS MISSING OR A PARAMETER IS INCORRECT; KEYWORD IGNORED.

 CARD NUM = 1958; KEYWORD FIELD = 'NUMCYCLE'
      PARAMETERS ARE:    41.0000000     0.0000000     0.0000000     0.0000000     0.0000000     0.0000000     0.0000000
      COL 11 TO 80 ='        41                                                            '

********   FVS04 ERROR:  A REQUIRED PARAMETER IS MISSING OR A PARAMETER IS INCORRECT; KEYWORD IGNORED.

RANNSEED   RANDOM SEED IS:           1.0

```

STAND ID 338300300218_Y1_R1 has STAND CN 22870841010661; it is the first
stand in the file.

SAND CN 22870841010661 is for STAND ID 338300300218_Y1_R1, which is 30 some
odd stands down.

Aha - NUMCYCLE is 41; from the FVS Keyword Reference:

> The maximum number of cycles in a projection is 40.

Are there any others?

Nope, just this one stand, only for the single-year projection, once for
each of the random seeds. Ignore.

### One Thousand Trees

The TPA fault may indicate a keyword file generation error; let's track it down.
```{r}
debug_stand_id <- fvs_warnings |>
  filter(grepl(" TPA ", text)) |>
  head(1) |>
  pull("STAND_ID")
fvs_warnings |>
  filter(STAND_ID == debug_stand_id)
```

a'ight, what's species 9?

```{r fvs species 9}
debug_species <- species_mixin |>
  filter(FVS_SPNO == 9)
debug_species
```

There's a record for this plot for eastern white pine with TPA > 1000.
Is it regen?

```{r fault analysis}
fvs_spcd <- debug_species[["FVS_SPCD"]]
regen_table |>
  filter(STAND_ID == "090400500390") |>
  filter(species == fvs_spcd)
```

Doesn't look like it.

Is it in the tree table?

```{r white pine in stand 390}
debug_stand <- stands_projected |>
  filter(STAND_ID == "090400500390")
standcn <- debug_stand[["STAND_CN"]]
statecd <- debug_stand[["STATECD"]]
countycd <- debug_stand[["COUNTYCD"]]
plot <- debug_stand[["PLOT"]]
invyr <- debug_stand[["FIRSTYEAR"]]
spcd <- debug_species[["SPCD"]]

fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
debug_trees <- tbl(fia, "FVS_TreeInit_Plot") |>
  filter(
    STAND_CN == standcn &
      SPECIES == spcd
  ) |>
  collect()
DBI::dbDisconnect(fia)
debug_trees |>
  arrange(DIAMETER, desc(TREE_COUNT))
```

Yup, there it is - TREE_COUNT = 1124.479237 and DIAMETER = 0.1

I think we note that these exist, and ignore them.

```{r}
fvs_warnings |>
  filter(grepl(" TPA ", text)) |>
  nrow()
```

4167 is a lot. What species are they?

```{r tpa warning species}
fvs_warnings |>
  filter(grepl("TREE_ID", text)) |>
  mutate(
    FVS_SPNO = as.integer(sub(".*SPECIES=[^0-9]*([0-9]+) .*", "\\1", text)),
    DIA = as.double(sub(".*DIAMETER=[^0-9]*([0-9.]+) .*", "\\1", text)),
    TREE_CLASS = case_when(
      DIA < 1 ~ "SEEDLING",
      DIA < 3 ~ "SAPLING",
      .default = "TREE"
    )
  ) |>
  group_by(FVS_SPNO, TREE_CLASS) |>
  summarize(COUNT = n(), .groups = "keep") |>
  ungroup() |>
  arrange(desc(COUNT)) |>
  left_join(species_mixin, by = join_by(FVS_SPNO))
```

All seedlings, and all read directly from FIA.
We can decide to not worry about them.

## Load Results

Load the output from all FVS partitions into a single dataframe

```{r FVS_Carbon}
FVS_Carbon <- NULL
FVS_Summary2_East <- NULL

title <- "NRSGrowOnly"
for (mgmtid in c("GROW", "SRVY")) {
  for (partition in 1:num_partitions) {
    filename <- paste0("data/fvs/FVS_", title, "_", mgmtid, "_", partition, ".db")
    if (file.exists(filename)) {
      print(paste0("Reading ", filename))
      fvs_out_db <- DBI::dbConnect(RSQLite::SQLite(), filename)
      fvs_carbon_tbl = tbl(fvs_out_db, 'FVS_Carbon') |>
        collect() |>
        mutate(
          Title = title,
          MgmtId = mgmtid,
          Timestep = sub("^.*_Y([0-9]+).*$", "\\1", StandID), # Extract timestep
          RanNSeed = sub("^.*_R([0-9]+).*$", "\\1", StandID), # Extract random seed
          Partition = partition,
          StandID = sub("^([^_]+)_.*$", "\\1", StandID) # Extract stand ID
        )
      FVS_Carbon <- bind_rows(FVS_Carbon, fvs_carbon_tbl)
  
      fvs_summary2_east_tbl = tbl(fvs_out_db, 'FVS_Summary2_East') |>
        collect() |>
        mutate(
          Title = title,
          MgmtId = mgmtid,
          Timestep = sub("^.*_Y([^_]+)_.*$", "\\1", StandID), # Extract timestep
          RanNSeed = sub("^.*_R([^_]+)_.*$", "\\1", StandID), # Extract random seed
          Partition = partition,
          StandID = sub("^([^_]+)_.*$", "\\1", StandID) # Extract stand ID
        )
        FVS_Summary2_East <- bind_rows(FVS_Summary2_East, fvs_summary2_east_tbl)
    
        dbDisconnect(fvs_out_db)
    } else {
      print(paste0("Skipping ", filename))
    }
  }
}

remove(fvs_out_db, fvs_carbon_tbl, fvs_summary2_east_tbl)
```
Consolidate outputs; average the multiple runs with different random seeds.

```{r FVS_Carbon_NONE}
FVS_Carbon_NONE <- FVS_Carbon |>
  filter(MgmtId == "GROW" & Timestep == 10) |>
  group_by(StandID, Year) |>
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    Total_Stand_Carbon = mean(Total_Stand_Carbon),
    .groups = 'keep'
  ) |>
  ungroup()

FVS_Carbon_ANNL <- FVS_Carbon |>
  filter(MgmtId == "GROW" & Timestep == 1) |>
  group_by(StandID, Year) |>
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    Total_Stand_Carbon = mean(Total_Stand_Carbon),
    .groups = 'keep'
  ) |>
  ungroup()

# There is no projection for the observed run, so no need to average
FVS_Carbon_SRVY <- FVS_Carbon |>  
  filter(MgmtId == "SRVY")
```

Sanity check: did we get the outputs we requested?

```{r sanity-check-expected-output}
matched_carbon_tmp <- stands_projected |>
  left_join(
    FVS_Carbon_NONE |>
      select(StandID, Year, Aboveground_Total_Live) |> 
      rename(
        STAND_ID = StandID,
        FIRSTYEAR = Year,
        Starting_Carbon = Aboveground_Total_Live
      ),
    by = join_by(STAND_ID, FIRSTYEAR)
  ) |>
  left_join(
    FVS_Carbon_NONE |>
      select(StandID, Year, Aboveground_Total_Live) |>
      rename(
        STAND_ID = StandID,
        LASTYEAR = Year,
        Ending_Carbon = Aboveground_Total_Live
        ),
    by = join_by(STAND_ID, LASTYEAR)
  ) |>
  mutate(partition = (as.numeric(STAND_ID) %% num_partitions) + 1)
missing_start <- matched_carbon_tmp |>
  filter(is.na(Starting_Carbon)) |> 
  nrow()
print(missing_start)
missing_end <- matched_carbon_tmp |>
  filter(is.na(Ending_Carbon)) |> 
  nrow()
print(missing_end)
stopifnot(missing_start == 0)
stopifnot(missing_end == 0)
remove(
  matched_carbon_tmp,
  missing_start,
  missing_end
)
```

## Annual vs. Decadal Projections

```{r annual_vs_decadal}
decadal_carbon_tmp <- FVS_Carbon_NONE |>
  rename(Decadal_Carbon = Aboveground_Total_Live) |>
  mutate(STAND_ID = paste0(
     substring(StandID, 1, 2),
     substring(StandID, 5, 12)
  )) |>
  select(STAND_ID, Year, Decadal_Carbon)

annual_carbon_tmp <- FVS_Carbon_ANNL |>
  rename(Annual_Carbon = Aboveground_Total_Live) |>
  mutate(STAND_ID = paste0(
     substring(StandID, 1, 2),
     substring(StandID, 5, 12)
  )) |>
  select(STAND_ID, Year, Annual_Carbon)

annual_vs_decadal <- stand_stats |>
  filter(DESIGNCD == 1) |>
  mutate(STAND_ID = sprintf(paste0(
    '%02d',  '%03d',   '%05d'),
    STATECD, COUNTYCD, PLOT
  )) |>
  rename(Year = MEASYEAR) |>
  select(
    STAND_ID, Year,
    STDAGE, `Forest Type`, `Forest Type Group`, ECOSUBCD
  ) |>
  left_join(decadal_carbon_tmp, by = join_by(STAND_ID, Year)) |>
  left_join(annual_carbon_tmp, by = join_by(STAND_ID, Year)) |>
  # There's something funny going on with plots; i've yet to figure it out.
  filter(!is.na(Decadal_Carbon) & !is.na(Annual_Carbon)) |>
  consolidate_forest_type_groups_filter() |>
  group_by(STAND_ID) |>
  mutate(
    ECOCD = substr(ECOSUBCD, 1, nchar(ECOSUBCD) - 1),
    First_Year = min(Year, na.rm = TRUE),
    Last_Year = max(Year, na.rm = TRUE),
    Decadal_Starting_Carbon = max(if_else(Year == First_Year, Decadal_Carbon, 0), na.rm = TRUE),
    Decadal_Carbon_Delta = Decadal_Carbon - Decadal_Starting_Carbon,
    Decadal_Carbon_Flux = if_else(Year == First_Year, 0, Decadal_Carbon_Delta / (Year - First_Year)),
    Annual_Starting_Carbon = max(if_else(Year == First_Year, Annual_Carbon, 0), na.rm = TRUE),
    Annual_Carbon_Delta = Annual_Carbon - Annual_Starting_Carbon,
    Annual_Carbon_Flux = if_else(Year == First_Year, 0, Annual_Carbon_Delta / (Year - First_Year))
  ) |>
  ungroup() |>
  filter(First_Year != Last_Year) |>
  filter(Year == Last_Year | Year == First_Year) |>
  mutate(Projection_Years = Year - First_Year) |>
  mutate(Carbon_Residual = Decadal_Carbon - Annual_Carbon) |>
  mutate(Carbon_Error = 2 * abs(Carbon_Residual) / (Decadal_Carbon + Annual_Carbon)) |>
  mutate(Carbon_Delta_Residual = Decadal_Carbon_Delta - Annual_Carbon_Delta) |>
  mutate(Carbon_Flux_Residual = Decadal_Carbon_Flux - Annual_Carbon_Flux)

remove(
  decadal_carbon_tmp,
  annual_carbon_tmp
)
```

```{r plot_decadal_vs_annual}
ggplot(
    annual_vs_decadal |>
      filter(Projection_Years > 0),
    aes(x = Decadal_Carbon_Flux, y = Annual_Carbon_Flux)
  ) +
  geom_bin2d(binwidth = 0.25) +
  scale_fill_continuous(name = "Number of Plots", transform = "log10") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") +
  #facet_wrap(~`Forest Type Group`) +
  theme_bw() +
  ggtitle(bquote("Annual Carbon Flux for 1- vs. 10-year Timestep")) +
  coord_cartesian(xlim = c(-1, 8), ylim = c(-1, 8)) +
  ylab(bquote("1-Year Timestep Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  xlab(bquote("10-Year Timestep Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1)))
```

```{r}
annual_vs_decadal |>
  filter(Decadal_Carbon_Flux > 0) |>
  mutate(Ratio = Decadal_Carbon_Flux / Annual_Carbon_Flux) |>
  ggplot(aes(x = Ratio)) +
  geom_histogram(bins = 50) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
  scale_x_continuous(transform = "log10", breaks = c(1, 2, 3, 5, 10, 20, 30, 50)) +
#  facet_wrap(~`Forest Type Group`) +
  theme_bw() +
  ggtitle("Ratio of Projected Carbon using 10 vs. 1 year timestep") +
  ylab("Number of Plots") +
  xlab("Ratio (10-Year / 1-Year)")

```

```{r carbon_flux_stats}
summary(annual_vs_decadal[,c("Annual_Carbon_Flux", "Decadal_Carbon_Flux")])
```

## Projected vs. Measured

Filter projections to corresponding observations.

projected_vs_measured has the projection and measurement for the quantities
of interest in the first and last year, and nothing in between.

```{r projected_vs_measured}
projected_carbon_tmp <- FVS_Carbon_NONE |>
  select(StandID, Year, Total_Stand_Carbon) |>
  rename(Projected_Carbon = Total_Stand_Carbon)

FVS_Summary2_East_NONE <- FVS_Summary2_East |>
  filter(MgmtId == "GROW" & Timestep == 10) |>
  group_by(StandID, Year) |>
  summarize(
    BA = mean(BA),
    Tpa = mean(Tpa),
    .groups = 'keep'
  ) |>
  ungroup()

FVS_Summary2_East_SRVY <- FVS_Summary2_East |>  
  filter(MgmtId == "SRVY")

projected_ba_tmp <- FVS_Summary2_East_NONE |>
  select(StandID, Year, BA, Tpa) |>
  mutate(Projected_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  rename(Projected_Tpa = Tpa)

projected_tmp <- projected_carbon_tmp |>
  full_join(projected_ba_tmp, by = join_by(StandID, Year)) |>
  mutate(STAND_ID = paste0(
     substring(StandID, 1, 2),
     substring(StandID, 5, 12)
  )) |>
  select(STAND_ID, Year, Projected_Carbon, Projected_BA, Projected_Tpa)

surveyed_carbon_tmp <- FVS_Carbon_SRVY |>
  select(StandID, Year, Total_Stand_Carbon) |>
  rename(Measured_Carbon = Total_Stand_Carbon)

surveyed_ba_tmp <- FVS_Summary2_East_SRVY |>
  select(StandID, Year, BA, Tpa) |>
  mutate(Measured_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  rename(Measured_Tpa = Tpa)

surveyed_tmp <- surveyed_carbon_tmp |>
  full_join(surveyed_ba_tmp, by = join_by(StandID, Year)) |>
  mutate(STAND_ID = paste0(
     substring(StandID, 1, 2),
     substring(StandID, 5, 12)
  )) |>
  select(STAND_ID, Year, Measured_Carbon, Measured_BA, Measured_Tpa)

projected_vs_measured <- stand_stats |>
  mutate(STAND_ID = sprintf(paste0(
    '%02d',  '%03d',   '%05d'),
    STATECD, COUNTYCD, PLOT
  )) |>
  rename(Year = MEASYEAR) |>
  select(
    STAND_ID, Year,
    STDAGE, `Forest Type`, `Forest Type Group`, ECOSUBCD,
    QMD, QMD_METRIC
  ) |>
  left_join(projected_tmp, by = join_by(STAND_ID, Year)) |>
  left_join(surveyed_tmp, by = join_by(STAND_ID, Year)) |>
  consolidate_forest_type_groups_filter() |>
  group_by(STAND_ID) |>
  mutate(
    ECOCD = substr(ECOSUBCD, 1, nchar(ECOSUBCD) - 1),
    First_Year = min(Year, na.rm = TRUE),
    Last_Year = max(Year, na.rm = TRUE),
    Starting_Carbon = max(if_else(Year == First_Year, Measured_Carbon, 0), na.rm = TRUE),
    Projected_Carbon_Delta = Projected_Carbon - Starting_Carbon,
    Projected_Carbon_Flux = if_else(Year == First_Year, 0, Projected_Carbon_Delta / (Year - First_Year)),
    Measured_Carbon_Delta = Measured_Carbon - Starting_Carbon,
    Measured_Carbon_Flux = if_else(Year == First_Year, 0, Measured_Carbon_Delta / (Year - First_Year)),
    Starting_BA = max(if_else(Year == First_Year, Measured_BA, 0), na.rm = TRUE),
    Projected_BA_Delta = Projected_BA - Starting_BA,
    Measured_BA_Delta = Measured_BA - Starting_BA
  ) |>
  ungroup() |>
  filter(Year == First_Year | Year == Last_Year) |>
  filter(!is.na(Projected_Carbon) & !is.na(Measured_Carbon)) |>
  mutate(Projection_Years = Year - First_Year) |>
  mutate(BA_Residual = Projected_BA - Measured_BA) |>
  mutate(BA_Error = 2 * abs(BA_Residual) / (Projected_BA + Measured_BA)) |>
  mutate(BA_Delta_Residual = Projected_BA_Delta - Measured_BA_Delta) |>
  mutate(BA_Flux_Residual = BA_Delta_Residual / Projection_Years) |>
  mutate(Carbon_Residual = Projected_Carbon - Measured_Carbon) |>
  mutate(Carbon_Error = 2 * abs(Carbon_Residual) / (Projected_Carbon + Measured_Carbon)) |>
  mutate(Carbon_Delta_Residual = Projected_Carbon_Delta - Measured_Carbon_Delta) |>
  mutate(Carbon_Flux_Residual = Projected_Carbon_Flux - Measured_Carbon_Flux)

remove(
  projected_carbon_tmp,
  projected_ba_tmp,
  projected_tmp,
  surveyed_carbon_tmp,
  surveyed_ba_tmp,
  surveyed_tmp
)
```

Run a quick check to make sure the plots grew during the projection period,
rather than shrank.

```{r sanity-check-plots-grew}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Measured_BA_Delta)
  ) +
  geom_bin2d(bins = 30) +
  geom_abline(intercept = 0, slope = 0, linetype = "dashed", color = "red") +
  scale_fill_continuous(name = "Number of Plots") +
  theme_bw() +
  #scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20, 22)) +
  #facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nChange in FVS Measured BA (m² / ha) vs. Projection Years")
```

## Carbon Projection

```{r projected_carbon_vs_measured_carbon}
projected_vs_measured |>
  filter(Projection_Years > 0) |>
  mutate(Ratio = Projected_Carbon / Measured_Carbon) |>
  ggplot(aes(x = Ratio)) +
  geom_histogram(bins = 50) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
  theme_bw() +
  ggtitle("Ratio of FVS Projected / FIA Measured Carbon") +
  ylab("Number of Plots") +
  xlab("Ratio (FVS Projected / FIA Measured)")
```

```{r summary projected_vs_measured}
projected_vs_measured |>
  filter(Projection_Years > 0) |>
  mutate(Ratio = Measured_Carbon / Projected_Carbon) |>
  summary()
```

```{r projected_carbon_vs_measured_carbon_with_trendline}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_Carbon, y = Projected_Carbon)
  ) +
  geom_bin2d(bins = 50) +
  geom_abline(intercept = 0, slope = 1) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    color = 'brown',
    linetype = 'dashed',
    fullrange = TRUE,
    se = FALSE
  ) +
  scale_fill_continuous(name = "Number of Plots", transform = "log10") +
#  facet_wrap(~`Forest Type Group`) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  ggtitle("FVS Projected vs. FIA Measured Carbon") +
  xlab(bquote("Projected Stand Carbon" ~(`Mg C` %.% ha^-1))) +
  ylab(bquote("Measured Stand Carbon" ~(`Mg C` %.% ha^-1))) +
  coord_cartesian(xlim = c(0, 800), ylim = c(0, 800))
```

```{r}
only_ends <- projected_vs_measured |> filter(Projection_Years > 0)
p <- sum(only_ends$Projected_Carbon) / nrow(only_ends)
m <- sum(only_ends$Measured_Carbon) / nrow(only_ends)
y <- mean(only_ends$Projection_Years)
p
m
(p - m)
(p - m) / m
y
```

### Carbon Flux

Which is great, but for large BA plots, only a small portion will be projected,
so the error is masked by the pre-existing BA. So, instead, look at measured
vs. projected carbon change.

```{r measured_vs_projected_carbon_change}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> arrange(Projection_Years),
    aes(x = Measured_Carbon_Delta, y = Projected_Carbon_Delta)
  ) +
  geom_bin2d(bins = 20) +
  scale_fill_continuous(transform = "log10") +
  geom_abline(intercept = 0, slope = 1) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    color = 'brown',
    linetype = 'dashed',
    fullrange = TRUE,
    se = FALSE
  ) +
  facet_wrap(~`Forest Type Group`) +
  theme(aspect.ratio = 1) +
  theme_bw() +
  ggtitle("Grow-Only Stands FVS Projected vs. Measured Carbon Change") +
  ylab(bquote("Projected Carbon Delta" ~(`Mg C` %.% ha^-1))) +
  xlab(bquote("Measured Carbon Delta" ~(`Mg C` %.% ha^-1))) #+
  #coord_cartesian(xlim = c(-100, 100), ylim = c(-100, 100))
```

```{r measured_vs_projected_carbon_flux}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_Carbon_Flux, y = Projected_Carbon_Flux)
  ) +
  geom_bin2d(bins = 50) +
  geom_abline(intercept = 0, slope = 1) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    color = 'brown',
    linetype = 'dashed',
    fullrange = TRUE,
    se = FALSE
  ) +
  scale_fill_continuous(name = "Number of Plots", transform = "log10") +
  #facet_wrap(~`Forest Type Group`) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  ggtitle("FVS Projected vs. Measured Annual Carbon Flux") +
  xlab(bquote("Measured Annual Carbon Flux" ~(`Mg C` %.% ha^-1 %.% yr^-1))) +
  ylab(bquote("Projected Annual Carbon Flux" ~(`Mg C` %.% ha^-1 %.% yr^-1))) #+
  #coord_cartesian(xlim = c(-10, 10), ylim = c(-10, 10))
```

```{r carbon flux ratio}
projected_vs_measured |>
  filter(Projection_Years > 0) |>
  mutate(Ratio = Projected_Carbon_Flux / Measured_Carbon_Flux) |>
  filter(-10 < Ratio & Ratio < 10) |>
  ggplot(aes(x = Ratio)) +
  geom_histogram(bins = 50) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  ggtitle("Annual Carbon Flux Ratio") +
  ylab("Number of Plots") +
  xlab("Ratio (Projected / Measured)")

```
```{r summary projected vs measured carbon flux}
projected_vs_measured |>
  filter(Projection_Years > 0) |>
  mutate(Ratio = Projected_Carbon_Flux / Measured_Carbon_Flux) |>
  summary()
```

```{r projected-vs-measured-carbon-flux}
projected_vs_measured_with_n <- projected_vs_measured |>
  filter(Projection_Years > 0) |>
  group_by(`Forest Type Group`) |>
  mutate(`Forest Type Group` = paste0(`Forest Type Group`, ", n=", n())) |>
  ungroup()
  
ggplot(
    projected_vs_measured_with_n,
    aes(Projected_Carbon_Flux, fct_reorder(`Forest Type Group`, Measured_Carbon, .fun = sum))
  ) +
  geom_vline(xintercept = 0, color = 'red') +
  geom_boxplot(varwidth = TRUE) +
  # scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  geom_point(
    data = projected_vs_measured_with_n |>
      group_by(`Forest Type Group`) |> 
      summarize(
        Measured_Carbon_Flux = mean(Measured_Carbon_Flux),
        Measured_Carbon = sum(Measured_Carbon),
        .groups = 'keep'
      ) |> 
      ungroup(),
    aes(Measured_Carbon_Flux),
    color = 'blue',
    shape = 4,
    size = 3
  ) +
  theme_bw() +
  ggtitle(bquote("Projected vs. Measured Annual Carbon Flux")) +
  xlab(bquote("Carbon Flux" ~(`Mg C` %.% ha^-1 %.% yr^-1))) +
  ylab("Forest Type Group")

```


### Residuals

Let's look at carbon flux residuals.
This is Mg of carbon per hectare per year.

```{r carbon-flux-by-forest-type}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(Carbon_Flux_Residual, fct_reorder(`Forest Type Group`, Measured_Carbon, .fun = sum))
  ) +
  geom_vline(xintercept = 0, color = 'red') +
  geom_boxplot(varwidth = TRUE) +
  # scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  geom_point(
    data = projected_vs_measured |>
      filter(Projection_Years > 0) |> 
      group_by(`Forest Type Group`) |> 
      summarize(
        Measured_Carbon_Flux = mean(Measured_Carbon_Flux),
        Measured_Carbon = sum(Measured_Carbon),
        .groups = 'keep'
      ) |> 
      ungroup(),
    aes(Measured_Carbon_Flux),
    color = 'blue',
    shape = 4,
    size = 3
  ) +
  theme_bw() +
  ggtitle(paste0(
    "FVS Projected Carbon Flux Residual by Forest Type Group",
    "\n",
    "for Grow-Only FIA Plots in the Northeast"
  )) +
  xlab(paste0(
    "Carbon Flux Residual (Mg C/ha/year)",
    "\n",
    "X = Mean Measured Carbon Flux (Mg C/ha/year)"
  )) +
  ylab("Forest Type Group")

```

```{r carbon-flux-by-forest-type-detail}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(Carbon_Flux_Residual, fct_reorder(`Forest Type Group`, Measured_Carbon, .fun = sum))
  ) +
  geom_vline(xintercept = 0, color = 'red') +
  geom_boxplot(varwidth = TRUE) +
  geom_point(
    data = projected_vs_measured |>
      filter(Projection_Years > 0) |> 
      group_by(`Forest Type Group`) |> 
      summarize(
        Measured_Carbon_Flux = mean(Measured_Carbon_Flux),
        Measured_Carbon = sum(Measured_Carbon),
        .groups = 'keep'
      ) |> 
      ungroup(),
    aes(Measured_Carbon_Flux),
    color = 'blue',
    shape = 4,
    size = 3
  ) +
#  scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  coord_cartesian(xlim = c(0, 10)) +
  theme_bw() +
  #scale_x_continuous(breaks = c(-5, -2.5, 0, 2.5, 5)) +
  ggtitle(paste0(
    "FVS Projected Carbon Flux Residual by Forest Type Group",
    "\n",
    "for Grow-Only FIA Plots in the Northeast"
  )) +
  xlab(paste0(
    "Carbon Flux Residual (Mg C/ha/year)",
    "\n",
    "X = Mean Measured Carbon Flux(Mg C/ha/year)"
  )) +
  ylab("Forest Type Group")
```

```{r carbon-flux-by-ecoregion}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(Carbon_Flux_Residual, fct_reorder(ECOCD, Measured_Carbon, .fun = sum))
  ) +
  geom_vline(xintercept = 0, color = 'red') +
  geom_boxplot(varwidth = TRUE) +
#  scale_y_discrete(guide = guide_axis(n.dodge = 2)) +
  coord_cartesian(xlim = c(-10, 10)) +
#  scale_x_continuous(breaks = c(-10, -2.5, 0, 2.5, 5)) +
  theme_bw() +
  ggtitle("Grow-Only Stands\nCarbon Flux Residual by Ecoregion") +
  xlab(bquote("Carbon Flux Residual" ~(`Mg C` %.% ha^-1 %.% yr^-1))) +
  ylab("Ecosubregion")
```

### Residuals vs. Years Projected

```{r carbon_residual_vs_projection_years}
ggplot(
    projected_vs_measured|> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Carbon_Residual)
  ) +
  geom_bin2d(bins = 20) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  theme_bw() +
  scale_fill_continuous(transform = "log10") +
  ggtitle("Grow-Only Stands\nCarbon Projection Error vs. Projection Years") +
  xlab("Projection Years") +
  ylab(bquote("Carbon Residual" ~(`Mg C` %.% ha^-1)))
```


```{r carbon_error_vs_projection_years}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Carbon_Error)
  ) +
  geom_bin2d(bins = 20) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
#  coord_cartesian(xlim = c(10, 20), ylim = c(0, 1)) +
#  scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20)) +
  scale_fill_continuous(transform = "log10") +
  theme_bw() +
  ggtitle("Grow-Only Stands\nCarbon Projection Error (fraction) vs. Projection years")
  
```

```{r carbon_flux_residual_vs_projection_years}
ggplot(
    projected_vs_measured|> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Carbon_Flux_Residual)
  ) +
  geom_bin2d(bins = 20) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  scale_fill_continuous(transform = "log10") +
  facet_wrap(~`Forest Type Group`) +
  theme_bw() +
  ggtitle("Grow-Only Stands\nCarbon Projection Flux Residual vs. Projection Years") +
  xlab("Projection Years") +
  ylab(bquote("Carbon Flux Residual" ~(`Mg C` %.% ha^-1 %.% yr^-1)))
```

### Residuals vs. BA

```{r carbon_residual_vs_measured_ba}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    mapping = aes(x = Measured_BA, y = Carbon_Residual)
  ) +
  geom_bin2d(bins = 20) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  scale_fill_continuous(transform = "log10") +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Projection Residuals vs. Measured BA") +
  xlab(bquote("Measured BA" ~ (m^2 %.% ha^-1))) +
  ylab(bquote("Carbon Residual" ~ (`Mg C` %.% ha^-1)))
  
```


```{r carbon_error_vs_measured_ba}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      filter(Carbon_Error < 1),
    aes(x = Measured_BA, y = Carbon_Error)
  ) +
  geom_bin2d(bins = 20) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  scale_fill_continuous(transform = "log10") +
  facet_wrap(~`Forest Type Group`) +
  theme_bw() +
  ggtitle("Grow-Only Stands\nCarbon Projection Error vs. Measured BA") +
  xlab(bquote("Measured BA" ~ (m^2 %.% ha^-1))) +
  ylab(bquote("Carbon Projection Error (fraction)"))
```

This omits outliers; looking just at the outliers (error >= 2x value):

```{r carbon_error_vs_measured_ba_outliers}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      filter(Carbon_Error >= 1),
    aes(x = Measured_BA, y = Carbon_Error)
  ) +
  geom_point() +
  coord_cartesian(ylim = c(0, NA)) +
  facet_wrap(~`Forest Type Group`) +
  theme_bw() +
  ggtitle("Grow-Only Stands\nCarbon Projection Error Outliers vs. Measured BA") +
  xlab(bquote("Measured BA" ~ (m^2 %.% ha^-1))) +
  ylab(bquote("Carbon Projection Error (fraction)"))
```

```{r carbon_flux_residual_vs_measured_ba}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    mapping = aes(x = Measured_BA, y = Carbon_Flux_Residual)
  ) +
  geom_bin2d(bins = 20) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  scale_fill_continuous(transform = "log10") +
  facet_wrap(~`Forest Type Group`) +
  theme_bw() +
  ggtitle("Grow-Only Stands\nCarbon Flux Residual vs. Measured BA") +
  xlab(bquote("Measured BA" ~ (m^2 %.% ha^-1))) +
  ylab(bquote("Carbon Flux Residual" ~(`Mg C` %.% ha^-1 %.% yr^-1)))
  
```

### Residuals vs. QMD

```{r carbon_residuals_vs_qmd}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> filter(QMD_METRIC < 100),
    aes(x = QMD_METRIC, y = Carbon_Residual)
  ) +
  geom_bin2d(bins = 20) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  scale_fill_continuous(transform = "log10") +
  facet_wrap(~`Forest Type Group`) +
  theme_bw() +
  ggtitle("Grow-Only Stands\nCarbon Projection Error (Mg/ha) vs. Measured QMD (cm)") +
  xlab(bquote("Measured QMD" ~ (cm))) +
  ylab(bquote("Carbon Residual" ~ (`Mg C` %.% ha^-1)))
  
```

```{r carbon_flux_residuals_vs_qmd}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> filter(QMD_METRIC < 100),
    aes(x = QMD_METRIC, y = Carbon_Flux_Residual)
  ) +
  geom_bin2d(bins = 20) +
  scale_x_log10() +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  scale_fill_continuous(transform = "log10") +
  theme_bw() +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Flux Residual vs. Measured QMD") +
  xlab(bquote("QMD" ~ (cm))) +
  ylab(bquote("Carbon Flux Residual" ~ (`Mg C` %.% ha^-1 %.% yr^-1)))
```

## Basal Area Projection

```{r projected_ba_vs_measured_ba}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_BA, y = Projected_BA)
  ) +
  geom_bin2d(bins = 20) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  theme_bw() +
#  theme(aspect.ratio = 1) +
  scale_fill_continuous(transform = "log10") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjected vs. Measured Basal Area") +
  xlab(bquote("Measured Basal Area" ~(m^2 %.% ha^-1))) +
  ylab(bquote("Projected Basal Area" ~(m^2 %.% ha^-1)))
```

```{r basal_area_trend}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      mutate(
        BA_Range = cut(Measured_BA, 0:19 * 5)
      ) |>
      group_by(`Forest Type Group`) |>
      mutate(`Forest Type Group` = paste0(`Forest Type Group`, ", n=", n())) |>
      ungroup()
    ,
    aes(x = BA_Range, y = BA_Flux_Residual)
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_boxplot(outlier.size = 0.1, varwidth = TRUE) +
  scale_fill_discrete(name = "Forest Type Group") +
  ggtitle("Measured vs. Projected BA") +
  ylab(bquote("BA Residual " (m^2 %.% ha^-1 %.% yr^-1))) +
  xlab(bquote("Measured Stand BA " (m^2 %.% ha^-1))) +
  theme_bw() +
  coord_cartesian(ylim = c(-2, 3))

```

Can we plot plot location with size proportional to BA?

```{r plot_location_by_ecotype_with_carbon}
plot_location_tmp <- plot_location |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, long, lat, group)

plot_location_type <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == max(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  consolidate_forest_type_groups_filter() |>
  select(STATECD, COUNTYCD, PLOT, INVYR, CARBON_METRIC, `Forest Type Group`) |>
  left_join(plot_location_tmp, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  rename(
    `Stand Carbon` = CARBON_METRIC,
    `Forest Type` = `Forest Type Group`
  ) |>
  group_by(`Forest Type`) |>
  mutate(n = n()) |>
  ungroup() |>
  mutate(`Forest Type` = if_else(n < 144, 'Other', `Forest Type`))

ggplot(map_states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(
    plot_location_type,
    mapping = aes(long, lat, group = group, color = fct_infreq(`Forest Type`), size = `Stand Carbon`)
  ) +
  scale_size_binned_area(max_size = 3) +
  coord_quickmap() +
  ggtitle("FIA Grow-Only Plots in the Northeast Region") +
  scale_color_hue(name = "Forest Type", breaks = c(
    'Maple / beech / birch',
    'Elm / ash / cottonwood',
    'Aspen / birch',
    'Oak / hickory',
    'Scarlet oak',
    'Spruce / fir',
    'White / red / jack pine',
    'Other'
  )) +
  theme_bw()

  #scale_fill_discrete(breaks = rev(levels(projected_annual_growth$Series)))

remove(plot_location_tmp)
```


### Residuals vs. Years Projected

```{r ba_residual_vs_projection_years}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = BA_Residual)
  ) +
  geom_bin2d(bins = 20) +
  scale_fill_continuous(transform = "log10") +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
#  scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20, 22)) +
  facet_wrap(~`Forest Type Group`) +
  theme_bw() +
  ggtitle("Grow-Only Stands\nBA Residual vs. Projection Years") +
  xlab(bquote("Projection Years")) +
  ylab(bquote("BA Residual" ~(m^2 %.% ha^-1)))
  
```

```{r ba_error_vs_projection_years}
ggplot(
    projected_vs_measured |> filter(BA_Error < 1),
    aes(x = Projection_Years, y = BA_Error)
  ) +
  geom_bin2d(bins = 20) +
  scale_fill_continuous(transform = "log10") +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  theme_bw() +
  ggtitle("Grow-Only Stands\nBA Projection Error vs. Projection years") +
  xlab("Projection Years") +
  ylab("BA Projection Error (fraction)")
  
```

### Residuals vs. QMD

```{r ba_residual_vs_qmd}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> filter(QMD_METRIC < 100),
    aes(x = QMD_METRIC, y = BA_Residual)
  ) +
  geom_bin2d(bins = 20) +
  scale_fill_continuous(transform = "log10") +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  theme_bw() +
  ggtitle("Grow-Only Stands\nBA Projection Residual vs. Measured QMD") +
  xlab(bquote("QMD" ~(cm))) +
  ylab(bquote("BA Residual" ~(m^2 %.% ha^-1)))
```

```{r qmd_trend}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      mutate(
        QMD_Range = cut(QMD_METRIC, 0:19 * 5)
      ) |>
      group_by(`Forest Type Group`) |>
      mutate(`Forest Type Group` = paste0(`Forest Type Group`, ", n=", n())) |>
      ungroup()
    ,
    aes(x = QMD_Range, y = BA_Flux_Residual)
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_boxplot(outlier.size = 0.1, varwidth = TRUE) +
  scale_fill_discrete(name = "Forest Type Group") +
  theme_bw() +
  ggtitle("Measured QMD vs. BA Residual for Grow-Only Stands") +
  ylab(bquote("BA Residual " ~(m^2 %.% ha^-1 %.% yr^-1))) +
  xlab(bquote("Measured Stand QMD " ~(cm)))

```
### Residuals vs. TPA

```{r ba_residual_vs_qmd}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_Tpa, y = Projected_Tpa)
  ) +
  geom_bin_2d(
    binwidth = 500
    #alpha = 0.25
  ) +
  scale_fill_gradient(
    name = "count",
    trans = "log",
    breaks = c(1, 10, 100),
    labels = c(1, 10, 100)
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  geom_abline(intercept = c(0, 0), slope = 1, linetype = "dashed") +
  coord_cartesian( xlim = c(0, 40000), ylim = c(0, 25000)) +
  theme_bw() +
  #theme(aspect.ratio = 1) +
  #facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjected vs. Measured TPA") +
  xlab(bquote("Measured" ~(trees %.% acre^-1))) +
  ylab(bquote("Projected" ~(trees %.% acre^-1)))
```

```{r qmd_trend}
options(scipen = 9)
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      mutate(
        Tpa_Range = cut(Measured_Tpa, 0:10 * 2000, labels = (1:10 * 2000))
      ) |>
      group_by(`Forest Type Group`) |>
      mutate(`Forest Type Group` = paste0(`Forest Type Group`, ", n=", n())) |>
      ungroup()
    ,
    aes(x = Tpa_Range, y = BA_Flux_Residual)
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_boxplot(outlier.size = 0.1, varwidth = TRUE, position = position_nudge(x = -0.5)) +
  scale_fill_discrete(name = "Forest Type Group") +
  theme_bw() +
  ggtitle("Measured TPA vs. BA Residual for Grow-Only Stands") +
  ylab(bquote("BA Residual" (m^2 %.% ha^-1 %.% yr^-1))) +
  xlab(bquote("Measured Stand TPA" (trees %.% acre^-1)))

```


# Addenda

## Eastern Hemlock


```{r eastern_hemlock}
rds_file <- 'data/intermediate/eastern_hemlock.rds'
if (USE_CACHE & file.exists(rds_file)) {
  eastern_hemlock <- read_rds(rds_file)
} else {
  tsuga_canadensis <- species_mixin |>
    filter(GENUS == "Tsuga" & SPECIES == "canadensis") |>
    select(SPCD) |>
    pull()
  
  # FIA.TREE.CN - sequence number - 0 NA
  # FIA.TREE.TREE - TREE number
  # FIA.TREE.CONDID - condition class; 1 = live tree
  # FIA.TREE.SPCD - species code
  # FIA.TREE.SPGRPCD is broader than SPCD, group by that instead
  # FIA.TREE.DIA - current diameter - 1693 NA
  # FIA.TREE.DIAHTCD - where diameter was taken, 1 = DBH
  # FIA.TREE.HT - height, including height of missing parts - 2605 NA
  # FIA.TREE.ACTUALHT - actual height, excluding height of missing parts - 4076 NA
  # FIA.TREE.CR - Compacted Crown Ratio, relative to ACTUALHT - 3576 NA
  # FIA.TREE.UNCRCD - Uncompacted Crown Ratio - 28268 NA
  # FIA.TREE.CCLCD - Crown Class code - 3421 NA
  #     1 - Open; 2 - Dominant; 3 - Codominant; 4 - Intermediate; 5 - Overtopped
  # FIA.TREE.CPOSCD - Crown Position Code - 29717 NA
  #     1 - Superstory; 2 - Over; 3 - Under; 4 - Open
  # FIA.TREE.CLIGHTCD - Light code - 29717 NA
  #     0 - 5, # of sides and top receiving light
  # FIA.TREE.CDENCD - Crown Density Code, % - 29820 NA

  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  measyear_mixin <- tbl(fia, 'PLOT') |>
    select(CN, MEASYEAR) |>
    rename(PLT_CN = CN)
  
  canopy_height_mixin <- tbl(fia, 'TREE') |>
    semi_join(
      plot_grow_only |> arrange(STATECD, COUNTYCD, PLOT),
      by = join_by(STATECD, COUNTYCD, PLOT),
      copy = TRUE
    ) |>
    # Live trees
    filter(CONDID == 1) |>
    # Codominant
    filter(CCLCD == 3) |>
    group_by(PLT_CN) |>
    summarize(CANOPY_HT = mean(HT, na.rm = TRUE)) |>
    ungroup()
  
  eastern_hemlock <- tbl(fia, 'TREE') |>
    semi_join(
      plot_grow_only |> arrange(STATECD, COUNTYCD, PLOT),
      by = join_by(STATECD, COUNTYCD, PLOT),
      copy = TRUE
    ) |>
    # Live trees
    filter(CONDID == 1) |>
    # Eastern Hemlock
    filter(SPCD == tsuga_canadensis) |>
    left_join(measyear_mixin, by = join_by(PLT_CN)) |>
    left_join(canopy_height_mixin, by = join_by(PLT_CN)) |>
    select(
      CN,
      STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR, MEASYEAR,
      SPCD,
      DIA, DIAHTCD,
      HT, ACTUALHT, CANOPY_HT,
      CR, UNCRCD, CCLCD, CPOSCD, CLIGHTCD, CDENCD
    ) |>
    arrange(STATECD, COUNTYCD, PLOT, SUBP, TREE, MEASYEAR) |>
    collect()
  
  dbDisconnect(fia)

  eastern_hemlock <- eastern_hemlock |>
    left_join(species_mixin, by = join_by(SPCD)) |>
    large_end_diameter_class_filter() |>
    decode_cclcd_filter()

  rm(fia, measyear_mixin, tsuga_canadensis)

  write_rds(eastern_hemlock, rds_file)
}
```

Looks like we have a meaningful number of trees with CCLCD and CR, so let's
compare those.

```{r plot_ccl_vs_cr}
eastern_hemlock |>
  filter(!is.na(CCL) & !is.na(CR)) |>
  mutate(CCL = factor(CCL, levels = c("Open grown", "Dominant", "Codominant", "Intermediate", "Overtopped"))) |>
  ggplot(aes(x = CCL, y = CR)) +
  geom_boxplot(outlier.size = 0.1, varwidth = TRUE) +
  theme_bw() +
  ylab("Crown Ratio (%)") +
  xlab("Crown Class") +
  ggtitle("Eastern Hemlock Crown Ratio vs. Crown Class")
  
```

> TODO: Danelle points out that e.g. for two trees that are 40' tall, the
> Codominant one will be in a forest with a 40' canopy, whereas the Intermediate
> one will be under a higher canopy. So, instead of plotting this by tree height,
> we could plot it by canopy height.
> We could estimate canopy height for a plot by looking at the mean height of
> codominant trees.

> TODO: Danelle thinks that the missing bars are due to missing data. Can I insert
> something for missing classes?


```{r plot_cr_vs_ht_by_ccl}
plot_eastern_hemlock <- eastern_hemlock |>
  filter(!is.na(CCL) & !is.na(CANOPY_HT) & !is.na(CR)) |>
  # filter(CANOPY_HT > 30 & CANOPY_HT < 100) |>
  mutate(CCL = factor(CCL, levels = rev(c("Open grown", "Dominant", "Codominant", "Intermediate", "Overtopped")))) |>
  mutate(HT_GROUP = factor(as.integer(CANOPY_HT / 10) * 10))
missing_classes <- plot_eastern_hemlock |> distinct(CCL) |>
  cross_join(plot_eastern_hemlock |> distinct(HT_GROUP)) |>
  anti_join(plot_eastern_hemlock |> distinct(HT_GROUP, CCL), by = join_by(HT_GROUP, CCL)) |>
  mutate(CR = -10) # Give missing classes a negative crown ratio so it can be cropped out
plot_eastern_hemlock <- plot_eastern_hemlock |>
  select(HT_GROUP, CCL, CR) |>
  union_all(missing_classes)
plot_eastern_hemlock_counts <- plot_eastern_hemlock |>
  group_by(HT_GROUP, CCL) |>
  summarize(COUNT = n(), CR = mean(CR), .groups = "keep") |>
  ungroup()
```

```{r}

plot_eastern_hemlock |>
  ggplot(aes(CR, HT_GROUP, fill = CCL)) +
  theme_bw() +
  geom_boxplot(outlier.size = 0.1) +
  geom_text(
    data = plot_eastern_hemlock_counts,
    mapping = aes(label = COUNT),
    position = position_dodge(width = .75),
    color = 'white'
  ) +
  scale_fill_discrete(name = "Crown Class", breaks = rev(levels(plot_eastern_hemlock$CCL))) +
  coord_cartesian(xlim = c(0, 100)) + # crop out "trees" with a negative crown ratio
  xlab("Crown Ratio (%)") +
  ylab("Canopy Height (feet)") +
  ggtitle("Eastern Hemlock Crown Ratio vs. Canopy Height by Crown Class")
  
```

```{r}
plot_eastern_hemlock <- eastern_hemlock |>
  filter(!is.na(CCL) & !is.na(CANOPY_HT) & !is.na(CDENCD)) |>
  # filter(CANOPY_HT > 30 & CANOPY_HT < 100) |>
  mutate(HT_GROUP = factor(as.integer(CANOPY_HT / 10) * 10))
missing_classes <- eastern_hemlock |> distinct(CCL) |>
  cross_join(plot_eastern_hemlock |> distinct(HT_GROUP)) |>
  anti_join(plot_eastern_hemlock |> distinct(HT_GROUP, CCL), by = join_by(HT_GROUP, CCL)) |>
  mutate(CDENCD = -10) # Give missing classes a negative crown ratio so it can be cropped out
plot_eastern_hemlock <- plot_eastern_hemlock |>
  select(HT_GROUP, CCL, CDENCD) |>
  union_all(missing_classes) |>
  mutate(CCL = factor(CCL, levels = rev(c("Open grown", "Dominant", "Codominant", "Intermediate", "Overtopped"))))

plot_eastern_hemlock_counts <- plot_eastern_hemlock |>
  group_by(HT_GROUP, CCL) |>
  summarize(COUNT = n(), CDENCD = mean(CDENCD), .groups = "keep") |>
  ungroup()

plot_eastern_hemlock |>
  ggplot(aes(CDENCD, HT_GROUP, fill = CCL)) +
  theme_bw() +
  geom_boxplot(outlier.size = 0.1) +
  geom_text(
    data = plot_eastern_hemlock_counts,
    mapping = aes(label = COUNT),
    position = position_dodge(width = .75),
    color = 'white'
  ) +
  scale_fill_discrete(name = "Crown Density", breaks = rev(levels(plot_eastern_hemlock$CCL))) +
  coord_cartesian(xlim = c(0, 100)) + # crop out "trees" with a negative crown ratio
  xlab("Crown Density (%)") +
  ylab("Canopy Height (feet)") +
  ggtitle("Eastern Hemlock Crown Density vs. Canopy Height by Crown Class")
  
```
