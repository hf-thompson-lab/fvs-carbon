---
title: "12_CFICOP"
output: html_document
---

# Setup

```{r setup, include=FALSE}
suppressPackageStartupMessages({
  library(targets)
  library(tarchetypes)
  library(tidyverse)
  library(readxl)
  library(terra)
  library(sf)
  library(rnaturalearth)
  library(measurements)
  library(mlr3verse) # Machine Learning in R framework, larger universe
  library(ggspatial) # annotation_scale, annotation_north_arrow
})
tar_source()
```

## Load targets results from other documents

```{r load tar objects, eval = FALSE}
tar_load(fiadb)
tar_load(species_crosswalk)
tar_load(fvs_num_partitions)
tar_load(fvs_partition)
tar_load(fvs_randseed)
tar_load(fvsne_states)
tar_load(cfigro_bai_model)
tar_load(cfigro_estab)
tar_load(cfigro_none_growth)
```

## Preload everything from 11_CFIGrowOnly.Rmd

```{r load 11 cfigrowonly, eval = FALSE}
get_this_rmd_file() |>
  str_replace(basename(get_this_rmd_file()), "11_CFIGrowOnly.Rmd") |>
  tar_objects_defined_in_rmd() |>
  tar_load()
```

## Preload targets results from this document

When tar_make() has already built the objects defined in this document,
run this block to pre-load them. You can then skip running ```{targets} blocks.

```{r load tar objects defined here, eval = FALSE}
get_this_rmd_file() |>
  tar_objects_defined_in_rmd() |>
  tar_load()
```

# MODEL ALL* THE PLOTS!!!

We want to:
- Model all the plots grow-only
- Apply the model of residuals to get an idea of how much FVS might have over-projected
- Look at harvest, and how much carbon is actually on the landscape
- Multiply by area to get an idea of what COP would be, etc.

* We don't have harvest information except on Audrey's plots, so we'll actually
just use her 283 plots. So it's not _all_ of all the plots, but it's all the
plots for which we have good data.

## Plots

cfigro_plot has all 283 plots.

## Trees

cfigro_tree has trees for all 283 plots.

### All the plots?

We only need trees in 1970; can we use all the plots?

```{r all the plots, eval = FALSE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
#  cfi_abp(cfiabp_trees) |>
  filter(VisitCycle == 1970) |>
  filter(cfi_status_live(VisitTreeStatusCode)) |> # Only Live Trees
  distinct(MasterPlotID) |>
  nrow()
```

There are 337 plots with trees in 1970; the 65 additional plots dont's seem
worth the extra effort.

For the manuscript, "Many plot locations in the Quabbin watershed were adjusted
in 1970, creating a discontinuity in observed data. This study exampines the
period from 1970 - 2020, during which plot location is consistent. There were
337 plots with trees in 1970; of these, detailed information on harvest and
disturbance is available on 277 [Barker-Plotkin 2024]."

## Regeneration

We ignored harvest in CFIGRO; can we continue to ignore it?

```{r plot establishment rate, eval = FALSE}
cfigro_estab |>
  mutate(STAND_CN = as.character(STAND_CN)) |>
  group_by(STAND_CN) |>
  summarize(DENSITY = sum(DENSITY), .groups = "keep") |>
  left_join(cfigro_plot |> select(STAND_CN, STAND_ID), by = join_by(STAND_CN)) |>
  mutate(MasterPlotID = as.numeric(STAND_ID)) |>
  left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
  left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
  mutate(Status = case_when(
    CFIDisturbed & CFIHarvested ~ "Disturbed & Harvested",
    CFIDisturbed ~ "Disturbed",
    CFIHarvested ~ "Harvested",
    .default = "Grow-Only"
  )) |>
  group_by(Status) |>
  mutate(Status = paste0(Status, ", n=", n())) |>
  ggplot(aes(Status, DENSITY)) +
  geom_boxplot() +
  theme_bw() +
  ggtitle("Establishment rate by plot status") +
  ylab(bquote("Establishment rate" ~ (stems %.% acre^-1 %.% year^-1)))
#  scale_y_continuous(transform = "log10")
  
```

non-Grow-Only plots show double and more the establishment rate of grow-only
plots.

Establishment comes from saplings / seedlings, which come from seeds, which
either come into the plot from outside or come from mature trees on the plot.
All of these plots are co-located, so they can trade seeds with each other.
For available seeds from trees on the plot, we can match plots by BA of the
major species, then use the establishment from the matched / sibling plot.

### Plot Matching

Start simple - minimize the delta in the three major species. We can leave "Other" alone.

```{targets cficop_plot_sibling, tar_simple = TRUE}
tmp_trees <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  filter(VisitCycle == 1970) |>
  filter(cfi_status_live(VisitTreeStatusCode)) |> # Only Live Trees
  # Quercus rubra and Quercus velutina are often conflated in surveys; instead
  # of treating them as two separate important species, combine them into one and
  # treat them as a single species.
  # Replace Quercus velutina (837) with Quercus rubra (833)
  mutate(
    SpeciesCode = if_else(SpeciesCode == 837, 833, SpeciesCode)
  ) |>
  left_join(
    species_crosswalk |> select(SPCD, SCIENTIFIC_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    TPA = 5,
    BA = VisitTreeDIAM
  )

tmp_by_plot <- tmp_trees |>
  group_by(MasterPlotID) |>
  summarize(
    TPA_Plot = sum(TPA, na.rm = TRUE),
    BA_Plot = sum(BA, na.rm = TRUE),
    .groups = "drop"
  ) |>
  ungroup() |>
  select(MasterPlotID, TPA_Plot, BA_Plot)

tmp_top_species <- c(
  "Acer rubrum", "Quercus rubra", "Pinus strobus"
)

tmp_plot_fingerprint <- tmp_trees |>
  group_by(MasterPlotID, SCIENTIFIC_NAME) |>
  summarize(
    TPA_Species = sum(TPA, na.rm = TRUE),
    BA_Species = sum(BA, na.rm = TRUE),
    .groups = "keep"
  ) |>
  ungroup() |>
  left_join(tmp_by_plot, by = join_by(MasterPlotID)) |>
  mutate(
    TPA_Frac = TPA_Species / TPA_Plot,
    BA_Frac = BA_Species / BA_Plot
  ) |>
  select(-ends_with("_Species")) |>
#  filter(BA_Frac > 0.1) |>
  filter(SCIENTIFIC_NAME %in% tmp_top_species) |>
  group_by(MasterPlotID) |>
  mutate(
    Species = do.call(
      paste,
      append(sort(SCIENTIFIC_NAME), list(sep = ", "))
    )
  ) |>
  ungroup() |>
  mutate(SCIENTIFIC_NAME = gsub(" ", "_", SCIENTIFIC_NAME)) |>
  pivot_wider(names_from = "SCIENTIFIC_NAME", values_from = c("TPA_Frac", "BA_Frac"))

tmp_plots_grow_only <- cfigro_plot_harvested |>
  filter(!CFIHarvested) |>
  inner_join(
    cfigro_plot_disturbed |> filter(!CFIDisturbed),
    by = join_by(MasterPlotID)
  ) |>
  select(MasterPlotID)

pct_diff <- function(a, b) {
  abs(a - b) / ((a + b) / 2)
}

most_similar_plot <- function(target_plots) {
  target_plots <- target_plots |>
    # Penalize things that differ on whether they have
    # a species on the landscape
    replace_na(list(
      BA_Frac_Pinus_strobus = -1,
      BA_Frac_Acer_rubrum = -1,
      BA_Frac_Quercus_rubra = -1
    ))

  lapply(1:nrow(target_plots), \(n) {
    # Minimize RMS difference in BA
    ba_plot <- target_plots[[n, "BA_Plot"]]
    ba_pist <- target_plots[[n, "BA_Frac_Pinus_strobus"]]
    ba_acru <- target_plots[[n, "BA_Frac_Acer_rubrum"]]
    ba_quru <- target_plots[[n, "BA_Frac_Quercus_rubra"]]
    tmp_plot_fingerprint |>
      inner_join(tmp_plots_grow_only, by = join_by(MasterPlotID)) |>
      replace_na(list(
        BA_Frac_Pinus_strobus = -1,
        BA_Frac_Acer_rubrum = -1,
        BA_Frac_Quercus_rubra = -1
      )) |>
      mutate(
        BA_RMSE = sqrt(
          pct_diff(BA_Plot, ba_plot)^2 +
            (BA_Frac_Pinus_strobus - ba_pist)^2 +
            (BA_Frac_Acer_rubrum - ba_acru)^2 +
            (BA_Frac_Quercus_rubra - ba_quru)^2
        )
      ) |>
      arrange(BA_RMSE) |>
      head(1) |>
      pull(MasterPlotID)    
  }) |>
    unlist()
}

tmp_plot_fingerprint |>
  mutate(sibling_plot = most_similar_plot(tmp_plot_fingerprint)) |>
  select(MasterPlotID, sibling_plot)
```

How's that looks:

```{r plot sibling plots, eval = FALSE}
tmp_top_species <- c(
  "Acer rubrum", "Quercus rubra", "Pinus strobus"
)

tmp_species <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  filter(VisitCycle == 1970) |>
  filter(cfi_status_live(VisitTreeStatusCode)) |> # Only Live Trees
  mutate(
    SpeciesCode = if_else(SpeciesCode == 837, 833, SpeciesCode)
  ) |>
  left_join(
    species_crosswalk |> select(SPCD, SCIENTIFIC_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  filter(SCIENTIFIC_NAME %in% tmp_top_species) |>
  distinct(MasterPlotID, SCIENTIFIC_NAME) |>
  group_by(MasterPlotID) |>
  summarize(
    Species = do.call(
      paste,
      append(sort(SCIENTIFIC_NAME), list(sep = ", "))
    ),
    .groups = "drop"
  ) |>
  select(MasterPlotID, Species)

matched_plots <- cficop_plot_sibling |>
  mutate(
    status = if_else(MasterPlotID == sibling_plot, "reference", "matched")
  ) |>
  left_join(
    cfigro_plot,
    by = join_by(MasterPlotID == STAND_ID)
  ) |>
  rename(
    lat = LATITUDE,
    long = LONGITUDE
  ) |>
  mutate(
    group = as.character(sibling_plot)
  ) |>
  select(
    MasterPlotID, status, lat, long, group
  ) |>
  left_join(
    tmp_species, by = join_by(MasterPlotID)
  ) |>
  group_by(group) |>
  mutate(n = n(), group = paste0(group, ", n=", n())) |>
  ungroup() |>
  filter(n > 12)
#  filter(n > 6)

matched_plot_group_order <- matched_plots |>
  distinct(group, n) |>
  arrange(desc(n))

matched_plots$group <- ordered(matched_plots$group, levels = matched_plot_group_order$group)

cfi_bbox <- st_as_sfc(
  st_bbox(vect(matched_plots, geom = c("long", "lat")))
)
sf_use_s2(FALSE)
st_crs(cfi_bbox) <- "WGS84"
lakes_north_america <- ne_download(
  scale = 10, type = "lakes_north_america", category = "physical"
)
lakes <- lakes_north_america[
  st_intersects(lakes_north_america, cfi_bbox, sparse = FALSE),
]
rivers_north_america <- ne_download(
  scale = 10, type = "rivers_north_america", category = "physical"
)
rivers <- rivers_north_america[
  st_intersects(rivers_north_america, cfi_bbox, sparse = FALSE),
]
ggplot() +
  geom_sf(data = lakes, fill = "blue", inherit.aes = FALSE) +
#  geom_sf(data = rivers, fill = "blue", inherit.aes = FALSE) +
  geom_point(
    data = matched_plots |> filter(status == "reference"),
    aes(long, lat, color = Species, shape = status), size = 2.5
  ) +
  geom_point(
    data = matched_plots |> filter(status == "matched"),
    aes(long, lat, color = Species, shape = status), size = 1.75
  ) +
  facet_wrap("group") +
#  scale_color_discrete(guide = "none") +
  scale_shape_manual(values = list(reference = 17, matched = 16)) +
#  annotation_scale(location = "br") +
#  annotation_north_arrow(
#    location = "tl",
#    width = unit(1, "cm"),
#    pad_x = unit(0.75, "cm"),
#    pad_y = unit(0.5, "cm")
#  ) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = -30, hjust = 0, vjust = 1)) +
  ggtitle("Matching harvested and disturbed CFI plots to grow-only plots")
```


### Copy CFIGRO Estab

We'll duplicate cfigro_estab from the reference plots to their sibling plots.

```{targets cficop_estab, tar_simple = TRUE}
# Each plot has a sibling plot;
# find the estab associated with the sibling plot.
cficop_plot_sibling |>
  left_join(
    cfigro_plot |> select(STAND_CN, MasterPlotID = STAND_ID),
    by = join_by(sibling_plot == MasterPlotID)
  ) |>
  mutate(STAND_CN = as.numeric(STAND_CN)) |>
  left_join(
    cfigro_estab,
    by = join_by(STAND_CN),
    # Each row on the left is a stand; many stands have the same STAND_CN.
    # Each row on the right is a stand-species; many rows on the right will
    # match a single stand. Therefore this is a many-to-many join.
    relationship = "many-to-many"
  ) |>
  # STAND_CN is for the sibling plot; swap that out
  # with the STAND_CN for the matched plot.
  select(-STAND_CN) |>
  left_join(
    cfigro_plot |> select(STAND_CN, MasterPlotID = STAND_ID),
    by = join_by(MasterPlotID)
  )
```

### Growth

cfigro_none_growth is tree-specific; for each tree within a plot, provide the diameter
and height 10 years from the simulation start time.

### Mortality

cfigro_none_death is tree-specific; for each tree within a plot, provide the status
at simulation start time.

## Watershed Area

I think I need to get a polygon for the watershed / districts, then use
land cover to find the forested area ... in 1970. Which I can't. Unless
they have literature that tells me.

But we can start with, what if it's 100% forested.

```{targets cficop_sam_wt, tar_simple = TRUE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  group_by(MasterPlotID) |>
  arrange(VisitCycle, MasterTreeID) |>
  filter(row_number() == 1) |>
  ungroup() |>
  left_join(
    tblSuppPlotForestrySubBasins,
    by = join_by(DWSPForestrySubWatershed == MasterForestryBasinID)
  ) |>
  group_by(EQDISTRICT, EQSUBDISTRICT) |>
  mutate(
    TotalAcres = max(DWSPOwnedAcres, na.rm = TRUE),
    NumPlots = n(),
    AcresPerPlot = TotalAcres / NumPlots,
    .groups = "keep"
  ) |>
  ungroup() |>
  select(
    EQDISTRICT,
    EQSUBDISTRICT,
    MasterPlotID,
    TotalAcres,
    NumPlots,
    AcresPerPlot
  )
```

```{r plot scaling cfi plots to watershed, eval = FALSE}
cficop_sam_wt |>
  group_by(EQSUBDISTRICT) |>
  filter(row_number() == 1) |>
  ggplot(aes(EQSUBDISTRICT, NumPlots, size = AcresPerPlot)) +
  geom_point() +
  coord_cartesian(ylim = c(0, 80)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = -15, hjust = 0, vjust = 1)) +
  ggtitle("Scaling CFI plots to the Watershed") +
  xlab("Subwatershed") +
  ylab("Number of Plots")
```

```{r map cfi plot scaling to watershed, eval = FALSE}
tmp_state_map <- fvsne_states |>
  filter(STATE_NAME == "Massachusetts") |>
  rename(region = STATE_NAME) |>
  _$region |>
  map_data("state", region = _)

tmp_plot_loc <- cfigro_plot |>
  rename(lat = LATITUDE, long = LONGITUDE, group = STAND_CN) |>
  left_join(
    cficop_sam_wt |> select(MasterPlotID, EQSUBDISTRICT, AcresPerPlot),
    by = join_by(STAND_ID == MasterPlotID)
  )

ggplot(tmp_state_map, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") +
  geom_point(
    data = tmp_plot_loc,
    aes(size = AcresPerPlot, color = EQSUBDISTRICT)
  ) +
  coord_cartesian(xlim = c(-72.45, -72.15), ylim = c(42.25, 42.55)) +
  theme_bw()
```

It looks, however, like we want to treat the entire area as one thing.
What's the total area?

```{r total acres, eval = FALSE}
print(277*0.2)
tblSuppPlotForestrySubBasins |>
  filter(Watershed == 1) |>
  summarize(acres = sum(DWSPOwnedAcres)) |>
  pull(acres)
```

So, by area, we've sampled 277*0.2 = 55.4 acres out of 58657 acres, or about 0.1%.

Oh, but probably we only want the subwatersheds that plots are actually present
on, so:

```{r sample weight, eval = FALSE}
cficop_sam_wt |>
  group_by(EQSUBDISTRICT) |>
  filter(row_number() == 1) |>
  ungroup() |>
  summarize(acres = sum(TotalAcres)) |>
  pull(acres)
```

so 19522, or roughly 20,000 acres, or less than half the total.

Or maybe we want not just ABP plots, but all Quabbin plots

```{r total acres another way, eval = FALSE}
tblSuppPlotForestrySubBasins |>
  filter(Watershed == 1) |>
  semi_join(
    tblDWSPCFIPlotsComplete |> distinct(DWSPForestrySubWatershed),
    by = join_by(MasterForestryBasinID == DWSPForestrySubWatershed)
  ) |>
  summarize(acres = sum(DWSPOwnedAcres)) |>
  pull(acres)
```

56816 acres.

# CFICOP_NONE

## Run FVS

```{targets cficop_none}
tar_target(
  cficop_none,
  {
    timestep <- 10 # years; determined by FVSne variant
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "CFICarbonOffsetProgram"
    mgmt_id <- "NONE"
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = NULL,
      title = title,
      mgmt_id = mgmt_id,
      stands = cfigro_plot |>
        # Filter out the 6 plots that do not get a sibling
        semi_join(
          cficop_plot_sibling,
          by = join_by(STAND_ID == MasterPlotID)
        ),
#        left_join(
#          cficop_sam_wt |> select(STAND_ID = MasterPlotID, SAM_WT = AcresPerPlot),
#          by = join_by(STAND_ID)
#        ),
      trees = cfigro_trees,
      regen = cficop_estab,
#      calibration = cfigro_none_growth,
#      calib_mort = cfigro_none_death,
#      calib_years = 10,
      num_partitions = fvs_num_partitions,
      partition = fvs_partition,
      random_seed = fvs_randseed
    )
  },
  # iteration = "vector" branches execution for each partition value (see below)
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here.
  # cross() ensures that every combination of values for its arguments is processed
  # map() distributes each value of its argument to a separate sub-target (branch)
  # so cross(randseed, map(partition)) will run each partition in a separate branch,
  # and each branch will run with each value of randseed
  pattern = cross(fvs_randseed, map(fvs_partition))
)
```

## Load Results

Carbon

```{targets cficop_none_carbon, tar_simple = TRUE}
fvs_read_output(cficop_none, "FVS_Carbon") |>
  group_by(StandID, Year) |> # Combine results from different random seeds
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    .groups = "keep"
  ) |>
  ungroup()
```

Summary

```{targets cficop_none_summary, tar_simple = TRUE}
fvs_read_output(cficop_none, "FVS_Summary2_East") |>
  group_by(StandID, Year) |>
  summarize(
    BA = mean(BA),
    Tpa = mean(Tpa),
    .groups = 'keep'
  ) |>
  ungroup()
```

## BA Over Time

```{r plot ba over time, eval = FALSE}
cficop_none_summary |>
  filter(Year %% 10 == 0) |>
#  group_by(Year) |>
#  summarize(BA = sum(BA) / n()) |>
#  ungroup() |>
  mutate(Series = "Projected") |>
  union_all(
    cfigro_srvy_summary |>
      filter(Year %% 10 == 0) |>
#      group_by(Year) |>
#      summarize(BA = sum(BA) / n()) |>
#      ungroup() |>
      mutate(Series = "Observed")
  ) |>
  mutate(
    Year = as.character(Year),
    BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")
  ) |>
  ggplot(aes(Year, BA, fill = Series)) +
  geom_boxplot(outlier.size = 0.5) +
  theme_bw() +
  ggtitle("CFI Grow-Only Projection") +
  ylab(bquote("Basal Area " ~ (m^2 %.% hectare^-1)))

```

## Carbon Over Time

```{r plot carbon over time, eval = FALSE}
cficop_none_carbon |>
#  group_by(Year) |>
#  summarize(Aboveground_Total_Live = sum(Aboveground_Total_Live) / n()) |>
#  ungroup() |>
  mutate(Series = paste0("Projection, n=", n_distinct(StandID))) |>
  union_all(
    cfigro_srvy_carbon |>
#      group_by(Year) |>
#      summarize(Aboveground_Total_Live = sum(Aboveground_Total_Live) / n()) |>
#      ungroup() |>
      mutate(Series = paste0("Reference, n=", n_distinct(StandID)))
  ) |>
  mutate(Year = as.character(Year)) |>
  ggplot(aes(Year, Aboveground_Total_Live, fill = Series)) +
  geom_boxplot(outlier.size = 0.5) +
  theme_bw() +
  ggtitle("CFI Grow-Only Projection") +
  ylab(bquote("Aboveground Live Carbon " ~ (`Mg C` %.% hectare^-1)))
```

## Error Model

We need:
cfigro_bai_task$select(
  c("Acer_rubrum", "LAT", "Pinus_strobus", "Projected_BA", "Projected_Tph", "Quercus_rubra", "SLOPE")
)

```{targets cficop_none_bai, tar_simple = TRUE}
tmp_top_species <- c("Acer rubrum", "Pinus strobus", "Quercus rubra")

tmp_species_cmp <- fvs_species_composition(cficop_none) |>
  filter(Year == 2020) |>
  mutate(SpeciesCode = as.numeric(SpeciesFIA)) |>
  # Combine black oak and red oak
  mutate(
    SpeciesCode = if_else(SpeciesCode == 837, 833, SpeciesCode)
  ) |>
  group_by(StandID, Year, SpeciesCode, random_seed) |>
  summarize(BA = sum(BA), TPA = sum(TPA), .groups = "drop") |>
  left_join(
    species_crosswalk |> select(SPCD, SCIENTIFIC_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    TPH = conv_unit(TPA, "hectare", "acre"),
    BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare"),
  )

tmp_by_plot <- tmp_species_cmp |>
  group_by(StandID, random_seed) |>
  summarize(
    TPA = sum(TPA),
    BA = sum(BA),
    .groups = "drop"
  )

# Top species by plot
# (only considering tmp_top_species)
tmp_plot_species <- tmp_species_cmp |>
  group_by(StandID, SCIENTIFIC_NAME, random_seed) |>
  summarize(BA = sum(BA), .groups = "drop") |>
  ungroup() |>
  left_join(
    tmp_by_plot |>
      select(StandID, random_seed, BA_Plot = BA),
    by = join_by(StandID, random_seed)
  ) |>
  mutate(BA_Frac = BA / BA_Plot) |>
  filter(SCIENTIFIC_NAME %in% tmp_top_species) |>
  mutate(
    SCIENTIFIC_NAME = sub(" ", "_", SCIENTIFIC_NAME)
  ) |>
  pivot_wider(
    id_cols = c("StandID", "random_seed"),
    names_from = SCIENTIFIC_NAME,
    values_from = BA_Frac,
    values_fill = 0
  )

# cficop_none_summary aggregates over random_seed; we need random_seed
# in the output.
tmp_none_summary <- fvs_read_output(cficop_none, "FVS_Summary2_East")

tmp_plot_starting_ba <- tmp_none_summary |>
  filter(Year == 1970) |>
  mutate(
    Starting_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare"),
    Starting_Tph = conv_unit(Tpa, "hectare", "acre")
  ) |>
  select(StandID, random_seed, Starting_BA, Starting_Tph)

tmp_plot_projected_ba <- tmp_none_summary |>
  filter(Year == 2020) |>
  mutate(
    Projected_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare"),
    Projected_Tph = conv_unit(Tpa, "hectare", "acre")
  ) |>
  select(StandID, random_seed, Projected_BA, Projected_Tph)

# cficop_none_carbon aggregates over random_seed; we need random_seed
# in the output.
tmp_none_carbon <- fvs_read_output(cficop_none, "FVS_Carbon")

tmp_plot_starting_carbon <- tmp_none_carbon |>
  filter(Year == 1970) |>
  rename(Starting_Carbon = Aboveground_Total_Live) |>
  select(StandID, random_seed, Starting_Carbon)

tmp_plot_projected_carbon <- tmp_none_carbon |>
  filter(Year == 2020) |>
  rename(Projected_Carbon = Aboveground_Total_Live) |>
  select(StandID, random_seed, Projected_Carbon)

cficop_none_bai <- tmp_plot_species |>
  left_join(
    cfigro_plot |>
      filter(INV_YEAR == 1970) |>
      mutate(StandID = as.character(STAND_ID)) |>
      select(StandID, LAT = LATITUDE, ASPECT, SLOPE, ELEV = ELEVFT),
    by = join_by(StandID)
  ) |>
  left_join(
    tmp_plot_starting_ba,
    by = join_by(StandID, random_seed)
  ) |>
  left_join(
    tmp_plot_projected_ba,
    by = join_by(StandID, random_seed)
  ) |>
  left_join(
    tmp_plot_starting_carbon,
    by = join_by(StandID, random_seed)
  ) |>
  left_join(
    tmp_plot_projected_carbon,
    by = join_by(StandID, random_seed)
  ) |>
  mutate(
    BAI_Error = cfigro_bai_model$predict_newdata(pick(everything()))$response,
    Carbon_Flux_Error = cfigro_aglcf_model$predict_newdata(pick(everything()))$response
  ) |>
  mutate(
    Projected_BAI = (Projected_BA - Starting_BA) / (2020 - 1970),
    Adjusted_BAI = Projected_BAI - BAI_Error,
    Projected_AGLCF = (Projected_Carbon - Starting_Carbon) / (2020 - 1970),
    Adjusted_AGLCF = Projected_AGLCF - Carbon_Flux_Error
  )
```

Plot it:

```{r plot cficop none bai, eval = FALSE}
cficop_none_bai |>
  rename(
    `FVS Projected` = Projected_BAI,
    `Corrected` = Adjusted_BAI
  ) |>
  pivot_longer(c("FVS Projected", "Corrected")) |>
  ggplot(aes(value, fill = name)) +
  geom_density(alpha = 0.5) +
  theme_bw() +
  scale_fill_discrete(name = "Series") +
  xlab(bquote("Basal Area Increment" ~ (m^2 %.% hectare^-1 %.% year^-1))) +
  ylab("Density") +
  ggtitle("CFI Quabbin All Plots 50 year BAI Projection")
```

```{r plot cficop none aglcf, eval = FALSE}
cficop_none_bai |>
  rename(
    `FVS Projected` = Projected_AGLCF,
    `Corrected` = Adjusted_AGLCF
  ) |>
  pivot_longer(c("FVS Projected", "Corrected")) |>
  ggplot(aes(value, fill = name)) +
  geom_density(alpha = 0.5) +
  theme_bw() +
  scale_fill_discrete(name = "Series") +
  xlab(bquote("Aboveground Live Carbon Flux" ~ (`Mg C` %.% hectare^-1 %.% year^-1))) +
  ylab("Density") +
  ggtitle("CFI Quabbin All Plots 50 year Aboveground Live Carbon Flux Projection")
```

## Error Distribution

```{r plot cficop error distribution, eval = FALSE}
cficop_none_bai |>
  mutate(Series = "Modeled") |>
  ggplot(aes(Carbon_Flux_Error, fill = Series)) +
  geom_density(alpha = 0.5) +
  geom_vline(xintercept = 0, color = "black", linewidth = 0.25) +
  theme_bw() +
  xlab(bquote("Aboveground Live Carbon Flux Residual" ~ (`Mg C` %.% ha^-1 %.% year^-1))) +
  ylab("Density") +
  scale_fill_brewer(palette="Set1") +
  ggtitle("Modeled AGL Carbon Flux Residual")
```


# CFICOP_DFLT

Like CFIGRO_NONE, but use default growth and mortality.

## Regeneration

Ignore plot-specificc regeneration. use a spatial average over the
first survey period to see how many trees of each species establish
in each plot.

Regeneration in Quabbin is fraught. Regen was suppressed in areas
from 1960 into the 1990s by excessive deer browse; hunting was
re-introduced in the 1990s to reduce the deer population.

### 1970 Model Year

Can we use trees that establish in the 1970-1980 cycle to represent
"what would a manager's perspective be on establishment in 1970?".

Start by finding all the trees that establish:

```{r cfiabp_estab, eval = FALSE}
cfiabp_estab <- qryDWSPCFIPlotVisitTreeDetail |>
  filter(VisitTreeStatusCode == 1) |>
  left_join(
    tblDWSPCFIPlotVisitsComplete |>
      select(MasterPlotID, VisitCycle, MasterPlotVisitID),
    by = join_by(MasterPlotVisitID)
  ) |>
  left_join( 
    tblDWSPCFITreesComplete |> select(MasterTreeID, SpeciesCode),
    by = join_by(MasterTreeID)
  ) |>
  inner_join(
    cfiabp_trees |>
      distinct(MasterPlotID, VisitCycle, MasterTreeID, StatusB),
    by = join_by(MasterPlotID, VisitCycle, MasterTreeID)
  ) |>
  filter(StatusB == "R")
```


### CFI Establishment By Year

Let's look at establishment rate - this will be how many trees
establish per 0.2 acre plot in a 10-year interval, on grow-only
plots.

```{r establisment rate, eval = FALSE}
cfiabp_estab |>
  left_join(
    cfigro_plot_harvested,
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    cfigro_plot_disturbed,
    by = join_by(MasterPlotID)
  ) |>
  filter(!CFIHarvested & !CFIDisturbed) |>
  group_by(MasterPlotID, VisitCycle) |>
  summarize(rate = n(), .groups = "keep") |>
  ungroup() |>
  # Convert rate to trees per acre per year
  mutate(rate = rate * 5 / 10) |>
  ggplot(aes(factor(VisitCycle), rate)) +
  geom_boxplot() +
  theme_bw() +
  ggtitle("Grow-Only Quabbin CFI Plot Establisment Rate") +
  ylab("New 5\"dbh trees per acre per year") +
  xlab("Inventory Year")
  
```

This says "no" - 1980 establishment rate is roughly 5x that of 2020.
1990 is still double.

```{r establishment per cycle, eval = FALSE}
cfiabp_estab |>
  left_join(
    cfigro_plot_harvested,
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    cfigro_plot_disturbed,
    by = join_by(MasterPlotID)
  ) |>
  filter(!CFIHarvested & !CFIDisturbed) |>
  group_by(MasterPlotID, VisitCycle) |>
  summarize(rate = n(), .groups = "keep") |>
  ungroup() |>
  mutate(rate = rate * 5 / 10) |>
  group_by(VisitCycle) |>
  summarize(rate = mean(rate))
```

### CFI Grow-Only Recruitment

Maybe we can use Hunt's data for seedling establishment. To do this,
we'd create a stems-per-acre NATURAL block that omits height; the
omission of height says these are seedlings, and FVS should figure
things out from there.

```{r establishment by species, eval = FALSE}
cfiabp_estab |>
  left_join(
    cfigro_plot_harvested,
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    cfigro_plot_disturbed,
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    species_crosswalk,
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(GENUS = if_else(GENUS == "Tree", "Other", GENUS)) |>
  filter(!CFIHarvested & !CFIDisturbed) |>
  mutate(GENUS = fct_lump(GENUS, n = 5, other_level = "Other")) |>
  ggplot(aes(VisitCycle, fill = GENUS, group = GENUS)) +
  geom_bar() +
  theme_bw() +
  ggtitle("Quabbin CFI Recruitment in Grow-Only Plots") +
  ylab("Number of Trees Recruited")
```

### CFI All Recruitment

```{r establishment by species in all plots, eval = FALSE}
cfiabp_estab |>
  left_join(
    cfigro_plot_harvested,
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    cfigro_plot_disturbed,
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    species_crosswalk,
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(GENUS = if_else(GENUS == "Tree", "Other", GENUS)) |>
#  filter(!CFIHarvested & !CFIDisturbed) |>
  mutate(GENUS = fct_lump(GENUS, n = 5, other_level = "Other")) |>
  ggplot(aes(VisitCycle, fill = GENUS, group = GENUS)) +
  geom_bar() +
  theme_bw() +
  ggtitle("Quabbin CFI Recruitment in All Plots") +
  ylab("Number of Trees Recruited")
```


### Fred Hunt's Table 13

Fred Hunt's 1961 Master's Thesis at UMass Amherst describes
a general rate of 254 stems of "establishment" per acre; we can use
this number, distributed according to his table 13, to set up 
background establishment.

Table 13.  Reproduction by Species

Here is a reproduction of Fred Hunt's table 13 showing reproduction in
1960, from Brian Keevan, personal communication, June 12 2025.

Keevan notes:
> "Note that Hunt decided to call anything from 3 foot tall to 4.9”
> diameter ‘reproduction’."

Hunt left some species unspecified; we substitute the most common
in Quabbin for these:
- Red maple = red maple
- Oak = northern red oak
- white pine = eastern white pine
- black birch = sweet birch
- white ash = white ash
- red pine = red pine
- other birch = paper birch
- other hardwoods = black cherry
- sugar maple = sugar maple
- spruce = red spruce

```{targets cficop_dflt_estab, tar_simple = TRUE}
tibble(
  Species = c(
    "White pine", "Hemlock", "Spruce", "Red Pine",
    "Sugar Maple", "Red maple", "Oak", "Black birch",
    "Other birch", "White ash", "Other hardwoods"
  ),
  Stems_Per_Acre = c(
    45, 13, 4, 10,
    8, 63, 54, 21,
    10, 16, 10
  ),
  Percent = c(
    10, 5, 2, 4,
    3, 25, 21, 8,
    4, 6, 4
  )
) |>
  mutate(
    SPCD = case_match(
      Species,
      "Red maple" ~ 316,
      "Oak" ~ 833,
      "White pine" ~ 129,
      "Black birch" ~ 372,
      "White ash" ~ 541,
      "Hemlock" ~ 261,
      "Red Pine" ~ 125,
      "Other birch" ~ 375,
      "Other hardwoods" ~ 762,
      "Sugar Maple" ~ 318,
      "Spruce" ~ 97
    )
  ) |>
  left_join(
    species_crosswalk |> select(SPCD, FVS_SPCD),
    by = join_by(SPCD)
  ) |>
  select(SPECIES = FVS_SPCD, DENSITY = Stems_Per_Acre) |>
  mutate(STAND_CN = NA, YEAR = NA) |>
  arrange(desc(DENSITY))
```

## Run FVS

This should be simple; there's no calibration.

```{targets cficop_dflt}
tar_target(
  cficop_dflt,
  {
    timestep <- 10 # years; determined by FVSne variant
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "CFICarbonOffsetProgram"
    mgmt_id <- "DFLT"
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = NULL,
      title = title,
      mgmt_id = mgmt_id,
      stands = cfigro_plot,
      trees = cfigro_trees,
      regen = cficop_dflt_estab,
      num_partitions = fvs_num_partitions,
      partition = fvs_partition,
      random_seed = fvs_randseed
    )
  },
  # iteration = "vector" branches execution for each partition value (see below)
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here.
  # cross() ensures that every combination of values for its arguments is processed
  # map() distributes each value of its argument to a separate sub-target (branch)
  # so cross(randseed, map(partition)) will run each partition in a separate branch,
  # and each branch will run with each value of randseed
  pattern = cross(fvs_randseed, map(fvs_partition))
)
```

## Load Results


Carbon

```{targets cficop_dflt_carbon, tar_simple = TRUE}
fvs_read_output(cficop_dflt, "FVS_Carbon") |>
  group_by(StandID, Year) |> # Combine results from different random seeds
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    .groups = "keep"
  ) |>
  ungroup()
```

Summary

```{targets cficop_dflt_summary, tar_simple = TRUE}
fvs_read_output(cficop_dflt, "FVS_Summary2_East") |>
  group_by(StandID, Year) |>
  summarize(
    BA = mean(BA),
    Tpa = mean(Tpa),
    .groups = 'keep'
  ) |>
  ungroup()
```



# CFICOP_SRVY

Look at how things actually grew, so we can compare to CFICOP_HVST.

## Run FVS

```{targets cficop_srvy}
tar_target(
  cficop_srvy,
  {
    visits <- cfiabp_trees |>
      distinct(MasterPlotID, VisitCycle) |>
      left_join(
        tblDWSPCFIPlotVisitsComplete |>
          select(MasterPlotID, VisitCycle, MasterPlotVisitID, VisitYear),
        by = join_by(MasterPlotID, VisitCycle)
      ) |>
      mutate(MasterPlotVisitID = as.character(MasterPlotVisitID)) |>
      select(
        STAND_CN = MasterPlotVisitID,
        STAND_ID = MasterPlotID,
        INV_YEAR = VisitYear
      )
    
    # Despite its name, cfigro_plot has all plots in it
    plots_for_fvs <- cfigro_plot |>
      select(-STAND_CN, -INV_YEAR) |>
      full_join(visits, by = join_by(STAND_ID)) |>
      mutate(FIRST_YEAR = INV_YEAR, LAST_YEAR = INV_YEAR)

    # No establishment for survey runs

    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "CFICarbonOffsetProgram"
    mgmt_id <- "SRVY"

    # We communicate with FVS through files. FVSOnline shows a model in which
    # a "project" (the inputs and outputs of a single FVS run) live in a
    # single directory; we follow that model.
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = NULL,
      title = title,
      mgmt_id = mgmt_id,
      stands = plots_for_fvs,
      trees = cfigro_trees,
      num_partitions = fvs_num_partitions,
      partition = fvs_partition
    )
  },
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here:
  pattern = map(fvs_partition)
)
```

## Load Results


Carbon

```{targets cficop_srvy_carbon, tar_simple = TRUE}
fvs_read_output(cficop_srvy, "FVS_Carbon") |>
  group_by(StandID, Year) |> # Combine results from different random seeds
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    .groups = "keep"
  ) |>
  ungroup()
```

Summary

```{targets cficop_srvy_summary, tar_simple = TRUE}
fvs_read_output(cficop_srvy, "FVS_Summary2_East") |>
  group_by(StandID, Year) |>
  summarize(
    BA = mean(BA),
    Tpa = mean(Tpa),
    .groups = 'keep'
  ) |>
  ungroup()
```




# CFICOP_HVST

Let's look at the distribution of harvest, and what we'll need to model.

## Observed Growth and Harvest

I don't know why we didn't start here, but let's plot what actually
happens on the landscape:

```{r population_mean with harvest, eval = FALSE}
hectares <- conv_unit(56816, "acre", "hectare")

population_mean <- cficop_none_carbon |>
  rename(
    Projected_Carbon = Aboveground_Total_Live
  ) |>
  left_join(
    cficop_none_bai |>
      select(StandID, Starting_Carbon, Projected_Carbon, Adjusted_AGLCF) |>
      group_by(StandID) |>
      summarize(
        Starting_Carbon = min(Starting_Carbon),
        Adjusted_AGLCF = mean(Adjusted_AGLCF),
        .groups = "keep"
      ) |>
      ungroup(),
    by = join_by(StandID)
  ) |>
  mutate(
    Adjusted_Carbon = Starting_Carbon + Adjusted_AGLCF * (Year - 1970)
  ) |>
  group_by(Year) |>
  summarize(
    projected_carbon_mean = mean(Projected_Carbon),
    projected_carbon_sd = sd(Projected_Carbon),
    adjusted_carbon_mean = mean(Adjusted_Carbon),
    adjusted_carbon_sd = sd(Adjusted_Carbon),
    n = n(),
    .groups = "keep"
  ) |>
  ungroup() |>
  mutate(
    # convert sd to ci via 1.96 / sqrt(n)
    projected_carbon = projected_carbon_mean,
    projected_carbon_min = projected_carbon - projected_carbon_sd * 1.96 / sqrt(n),
    projected_carbon_max = projected_carbon + projected_carbon_sd * 1.96 / sqrt(n),
    adjusted_carbon = adjusted_carbon_mean,
    adjusted_carbon_min = adjusted_carbon - adjusted_carbon_sd * 1.96 / sqrt(n),
    adjusted_carbon_max = adjusted_carbon + adjusted_carbon_sd * 1.96 / sqrt(n)
  ) |>
  select(
    Year,
    projected_carbon, projected_carbon_min, projected_carbon_max,
    adjusted_carbon, adjusted_carbon_min, adjusted_carbon_max
  ) |>
  pivot_longer(-Year) |>
  mutate(
    value = value * hectares,
    group = if_else(grepl("projected", name), "projected", "adjusted"),
    kind  = if_else(grepl("_min", name), "min", if_else(grepl("_max", name), "max", "mean"))
  ) |>
  pivot_wider(id_cols = c("group", "Year"), names_from = "kind")
```

Plot it:
```{r plot population mean with harvest, eval = FALSE}
library(ggfx)
population_mean |>
  mutate(group = ordered(group, levels = c("projected", "adjusted"))) |>
  ggplot(aes(Year, mean)) +
  with_blur(
    geom_ribbon(aes(ymin = min, ymax = max, fill = group), alpha = 0.25),
    sigma = 3
    
  ) +
  geom_line(aes(color = group)) +
  coord_cartesian(ylim = c(0, NA)) +
  guides(
    color = guide_legend(order = 1),
    fill = guide_legend(order = 2)
  ) +
  theme_bw() +
  ggtitle("Projected vs. Measured Total Carbon, 0.1% sample") +
  ylab(bquote("Total Carbon" ~(`Mg C`))) +
  scale_color_discrete(name = "Estimated\nPopulation\nMean") +
  scale_fill_discrete(name = "95% CI")
```

```{r population mean values with harvest, eval = FALSE}
population_mean |>
  filter(Year == 1970 | Year == 2020) |>
  mutate(ci = mean - min) |>
  select(group, Year, mean, ci)
```


# Carbon on the Landscape

- Treat the 277 plots as a sample (by area?)
- For the sample, we can compute the Standard Error of the Mean (SEM) as:
  - SEM = s / sqrt(n)
    where s = sample standard deviation
    and   n = number of points in the sample
  - Note that if sample size > 5% of the population size, also apply
    Finite Population Correction (FPC), which says
  - SEM = s / sqrt(n) * (N - n) / (N - 1)
    where N = population size
- Then a 95% CI for the population mean is
  x_bar +/- (1.96 * SEM)
  where x_bar is the sample mean

What does this mean for total carbon on the landscape?

I think we just multiply the FVS projected vs. corrected AGLCF times years
times acres (converted to hectares).

from above, estimated 56816 forested acres; we have 277 * 0.2 = 55.4 acres,
so 0.1%

## Population Mean

So, let's look at distribution of biomass in our 277 plot sample:

```{r population_mean, eval = FALSE}
hectares <- conv_unit(56816, "acre", "hectare")

population_mean <- cficop_none_carbon |>
  rename(
    Projected_Carbon = Aboveground_Total_Live
  ) |>
  left_join(
    cficop_none_bai |>
      select(StandID, Starting_Carbon, Projected_Carbon, Adjusted_AGLCF) |>
      group_by(StandID) |>
      summarize(
        Starting_Carbon = min(Starting_Carbon),
        Adjusted_AGLCF = mean(Adjusted_AGLCF),
        .groups = "keep"
      ) |>
      ungroup(),
    by = join_by(StandID)
  ) |>
  mutate(
    Adjusted_Carbon = Starting_Carbon + Adjusted_AGLCF * (Year - 1970)
  ) |>
  group_by(Year) |>
  summarize(
    projected_carbon_mean = mean(Projected_Carbon),
    projected_carbon_sd = sd(Projected_Carbon),
    adjusted_carbon_mean = mean(Adjusted_Carbon),
    adjusted_carbon_sd = sd(Adjusted_Carbon),
    n = n(),
    .groups = "keep"
  ) |>
  ungroup() |>
  mutate(
    # convert sd to ci via 1.96 / sqrt(n)
    projected_carbon = projected_carbon_mean,
    projected_carbon_min = projected_carbon - projected_carbon_sd * 1.96,
    projected_carbon_max = projected_carbon + projected_carbon_sd * 1.96,
    adjusted_carbon = adjusted_carbon_mean,
    adjusted_carbon_min = adjusted_carbon - adjusted_carbon_sd * 1.96,
    adjusted_carbon_max = adjusted_carbon + adjusted_carbon_sd * 1.96
  ) |>
  select(
    Year,
    projected_carbon, projected_carbon_min, projected_carbon_max,
    adjusted_carbon, adjusted_carbon_min, adjusted_carbon_max
  ) |>
  pivot_longer(-Year) |>
  mutate(
    value = value * hectares,
    group = if_else(grepl("projected", name), "projected", "adjusted"),
    kind  = if_else(grepl("_min", name), "min", if_else(grepl("_max", name), "max", "mean"))
  ) |>
  pivot_wider(id_cols = c("group", "Year"), names_from = "kind")
```

Plot it:
```{r plot population mean, eval = FALSE}
library(ggfx)
population_mean |>
  mutate(group = ordered(group, levels = c("projected", "adjusted"))) |>
  ggplot(aes(Year, mean)) +
  with_blur(
    geom_ribbon(aes(ymin = min, ymax = max, fill = group), alpha = 0.25),
    sigma = 3
    
  ) +
  geom_line(aes(color = group)) +
  coord_cartesian(ylim = c(0, NA)) +
  guides(
    color = guide_legend(order = 1),
    fill = guide_legend(order = 2)
  ) +
  theme_bw() +
  ggtitle("Projected vs. Measured Total Carbon, 0.1% sample") +
  ylab(bquote("Total Carbon" ~(`Mg C`))) +
  scale_color_discrete(name = "Estimated\nPopulation\nMean") +
  scale_fill_discrete(name = "95% CI")
```

```{r population mean values, eval = FALSE}
population_mean |>
  filter(Year == 1970 | Year == 2020) |>
  mutate(ci = mean - min) |>
  select(group, Year, mean, ci)
```

In 1970, there were 1170155 +- 57272 Mg C / ha
In 2020, projected was 2839915 +- 80259
In 2020, adjusted  was 2713476 +- 68425
2839915 - 2713476 = 126439,
126439 / 2839915 = 0.04452210718, so off by 4.5%

2713476 - 1170155 = 1543321 Mg C growth
126439 / 1543321 = 0.08192657263, so over-projects growth by 8%

## Calibrated vs Uncalibrated vs Observed

```{r none vs dflt vs srvy, eval = FALSE}
cficop_none_carbon |>
  rename(Calibrated = Aboveground_Total_Live) |>
  left_join(
    cficop_dflt_carbon |>
      rename(Uncalibrated = Aboveground_Total_Live),
    by = join_by(StandID, Year)
  ) |>
  left_join(
    cficop_srvy_carbon |>
      rename(Measured = Aboveground_Total_Live),
    by = join_by(StandID, Year)
  ) |>
  left_join(
    cficop_none_bai |>
      select(StandID, Starting_Carbon, Projected_Carbon, Adjusted_AGLCF) |>
      group_by(StandID) |>
      summarize(
        Starting_Carbon = min(Starting_Carbon),
        Adjusted_AGLCF = mean(Adjusted_AGLCF),
        .groups = "keep"
      ) |>
      ungroup(),
    by = join_by(StandID)
  ) |>
  mutate(
    Adjusted = Starting_Carbon + Adjusted_AGLCF * (Year - 1970)
  ) |>
  select(-c("Starting_Carbon", "Adjusted_AGLCF")) |>
  pivot_longer(-c("StandID", "Year")) |>
  group_by(Year, name) |>
  summarize(
    n = n(),
    mean = mean(value),
    ymin = mean(value) - 1.96 * sd(value),
    ymax = mean(value) + 1.96 * sd(value),
    .groups = "drop"
  ) |>
  mutate(name = ordered(name, levels = c("Uncalibrated", "Calibrated", "Adjusted", "Measured"))) |>
  ggplot(aes(Year, mean, color = name)) +
  geom_line() +
  geom_point() +
  theme_bw() +
  ggtitle("Quabbin CFI Projected Carbon") +
  xlab("Year") +
  ylab(bquote("Aboveground Live Carbon" ~(`Mg C` %.% ha^-1)))
```


