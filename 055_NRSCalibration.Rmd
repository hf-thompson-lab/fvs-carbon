---
title: "055_Calibration"
author: "Nikolaus Bates-Haus"
output:
  html_document: default
  word_document: default
  pdf_document: default
editor_options:
  markdown:
    wrap: 72
---

# Setup

```{r setup, include=FALSE}
library(targets)
library(tarchetypes)
library(tidyverse)
library(reshape2) # melt()
library(measurements) # conv_unit and conv_multiunit
library(maps)
library(ggspatial) # for maps
library(ggpmisc) # for stat_poly_eq
options(scipen = 9) # Use integer notation for numbers under 9 digits
tar_source()
```


## Load targets results from other documents

```{r load tar objects defined elsewhere, eval = FALSE}
tar_load(fiadb)
tar_load(species_crosswalk)
```

## Preload everything from 05_NRSGrowOnly.Rmd

```{r load 05 nrsgrowonly, eval = FALSE}
get_this_rmd_file() |>
  str_replace("055_NRSCalibration", "05_NRSGrowOnly") |>
  tar_objects_defined_in_rmd() |>
  tar_load()
```

## Preload targets results from this document

When tar_make() has already built the objects defined in this document,
run this block to pre-load them. You can then skip running ```{targets} blocks.

```{r load tar objects defined here, eval = FALSE}
get_this_rmd_file() |>
  tar_objects_defined_in_rmd() |>
  tar_load()
```

# Lack of Calibration

## Notes

rmrs_p061_289_306.pdf p 8 / 296
CalbStat - print calibration stats
ReadCorR - Readjust Correction for Regeneration (height)
ReadCorD - Readjust Correction for large tree Diameter
ReadCorH - Readjust Correction for large tree Height
"can be constructed from the mean multipliers listed in the calibration statistics report"
EssentialFVS 6.5.2.1
 any available growth observations that are present in the input data for the site
being projected
So, I'm not getting calibration because I'm almost always starting with the first survey of a stand and there is no previous observation
I could copy the next growth increment backwards a step.

The scaling procedure (Stage 1973), when stripped of statistical condiments, is really
quite simple. Both the large-tree diameter growth model and the small-tree height growth
model are linear with logarithmically scaled dependent variables. Therefore, the model
intercepts are, in effect, growth multipliers. An increment is predicted to match each
observed increment for a species, and differences are sorted. The median difference is
then added to the model for that species, on the logarithmic scale, as an additional
intercept term (see section 7.2 for detailed information). (EssentialFVS)

## Lack of Calibration

Why, in all these runs, do we so rarely see FVS kick in its internal calibration?

It's because we're starting at the beginning of time for each plot, so there is
no remeasurement, and no growth rate in either height or diameter.

```{r nrsgro_none_calibration, eval = FALSE}
single_seed <- nrsgro_none |>
  group_by() |>
  filter(random_seed == min(random_seed)) |>
  ungroup()
nrsgro_none_cases <- fvs_read_output(single_seed, "FVS_Cases")
nrsgro_none_calibstats <- fvs_read_output(single_seed, "FVS_CalibStats")
num_cases <- nrsgro_none_cases |> distinct(CaseID) |> nrow()
num_cases_calibrated <- nrsgro_none_calibstats |> distinct(CaseID) |> nrow()
num_cases_calibrated /  num_cases
```

# FVS vs FIA Growth

FIADB.TREE_GRM_COMPONENT has ANN_DIA_GROWTH and ANN_HT_GROWTH

FVS_TreeInit_Plot has DG and HTG

FIADB.PLOT.REMPER,
FIADB.TREE_GRM_ESTN.REMPER - remeasurement period to the nearest 0.1 year

Do these have anything to do with each other?

```{r sample_plots, eval = FALSE}
sample_plots <- nrsgro_plot |>
  sample_n(10, replace = FALSE)
```

## FIA Growth Rates

FIADB has annual diameter and height growth rates in the GRM_COMPONENT table,
but these are sparsely populated. We can compute our own from remeasured trees.

```{r fia growth, eval = FALSE}
tmp_tre <- fia_trees(fiadb, sample_plots)
tmp_prv_tre <- fia_trees_by_cn(
  fiadb,
  tmp_tre |>
    select(PREV_TRE_CN) |>
    rename(CN = PREV_TRE_CN)
) |>
  select(CN, DIA, HT) |>
  rename(
    PREV_TRE_CN = CN,
    PREV_DIA = DIA,
    PREV_HT = HT
  )

tmp_plt <- fia_plots_by_cn(
  fiadb,
  tmp_tre |>
    select(PLT_CN) |>
    rename(CN = PLT_CN)
) |>
  select(CN, REMPER) |>
  rename(PLT_CN = CN)

fia_growth <- tmp_tre |>
  left_join(tmp_prv_tre, by = join_by(PREV_TRE_CN)) |>
  left_join(tmp_plt, by = join_by(PLT_CN)) |>
  mutate(
    ANN_DIA_GROWTH = (DIA - PREV_DIA) / REMPER,
    ANN_DIA_GROWTH5 = (DIA - PREV_DIA) / 5,
    ANN_HT_GROWTH = (HT - PREV_HT) / REMPER,
    ANN_HT_GROWTH5 = (HT - PREV_HT) / 5
  ) |>
  filter(!is.na(ANN_DIA_GROWTH) & !is.na(ANN_HT_GROWTH))
fia_growth |>
  ggplot(aes(ANN_DIA_GROWTH, ANN_HT_GROWTH)) +
  geom_point()
```

That's a lot of negative height growth, and a modest amount of negative
diameter growth, but that is what the data shows.

## FVS Growth Rates

From EssentialFVS:
Diameter increment data
may be entered into FVS either as an inside bark diameter increment (future or past), or a
second outside bark DBH measurement (future or past). If the second method is used, the
program will automatically convert DG to an inside bark increment prior to calibration.
When the sample tree records are plain text (not in a database) and the value entered for
DG does not contain a decimal point the value is assumed to be in tenths of inches (one
implied decimal place). When the sample tree records are in a database the value is read
as entered (no implied decimal place).

so we're switching from a past "outside bark DBH measurement" to a future
"outside bark DBH measurement".

EssentialFVS goes on to say:
It is also recommended that a growth measurement period be used corresponding to the
period used to fit the diameter growth models for the variant you are using (generally 10
years). [...] Both the method of growth
measurement and the length of the period are entered on the GROWTH keyword record
(see section 4.2.3.4).


```{r fvs growth, eval = FALSE}
fvs_growth <- fia_tbl(fiadb, "FVS_TreeInit_Plot", \(.data, con) {
  .data |>
    inner_join(
      sample_plots |> select(CN) |> rename(STAND_CN = CN),
      by = join_by(STAND_CN),
      copy = TRUE
    )
}) |>
  mutate(
    DIA_GROWTH = DIAMETER - DG,
    HT_GROWTH = HT - HTG
  ) |>
  filter(!is.na(DIA_GROWTH) & !is.na(HT_GROWTH))
fvs_growth |>
  ggplot(aes(DIA_GROWTH, HT_GROWTH)) +
  geom_point()
```

Note that FVS never has negative growth, in either diameter or height.

Did we get FVS growth corresponding to all FIA growth?

```{r missing_growth, eval = FALSE}
a <- fvs_growth |>
  anti_join(
    fia_growth,
    by = join_by(TREE_CN == CN)
  ) |>
  select(TREE_CN, DIAMETER) |>
  rename(CN = TREE_CN, DIA = DIAMETER) |>
  mutate(SOURCE = "FVS")
b <- fia_growth |>
  anti_join(
    fvs_growth,
    by = join_by(CN == TREE_CN)
  ) |>
  select(CN, DIA) |>
  mutate(SOURCE = "FIA")
missing_growth <- bind_rows(a, b)
```

That's a bunch of FIA trees not in the FVS data; where did they go?
Oh, they don't have DG or HTG filled in, so FVS doesn't get growth for them.

## FVS vs FIA Growth

How do FVS and FIA growth rates compare?

```{r cmp growth, eval = FALSE}
cmp_growth <- fvs_growth |>
  select(TREE_CN, DIA_GROWTH, HT_GROWTH) |>
  left_join(
    fia_growth |> select(CN, ANN_DIA_GROWTH, ANN_HT_GROWTH),
    by = join_by(TREE_CN == CN)
  ) |>
  mutate(DIA_GROWTH = DIA_GROWTH / 5)

cmp_growth |>
  ggplot(aes(DIA_GROWTH, ANN_DIA_GROWTH)) +
  geom_abline(slope = 1, intercept = 0) +
  theme(aspect.ratio = 1) +
  geom_point()
```

These are not exact because, when computing FVS_TreeInit_Plot.DG, the
growth period is assumed to be 5 years, rather than PLOT.REMPER. Note that
this imparts a very slight positive growth bias:
```{r growth rmse, eval = FALSE}
# compute RMSE for DIA_GROWTH compared to ANN_DIA_GROWTH
cmp_growth |>
  summarise(
    RMSE = sqrt(mean((DIA_GROWTH - ANN_DIA_GROWTH) ^ 2))
  )
```

If we switch the FIA growth to use 5 years instead of REMPER, things line up 
much nicer:

```{r plot cmp growth, eval = FALSE}
cmp_growth <- fvs_growth |>
  select(TREE_CN, DIA_GROWTH, HT_GROWTH) |>
  left_join(
    fia_growth |> select(CN, ANN_DIA_GROWTH5, ANN_HT_GROWTH5),
    by = join_by(TREE_CN == CN)
  ) |>
  mutate(DIA_GROWTH = DIA_GROWTH / 5)

cmp_growth |>
  ggplot(aes(DIA_GROWTH, ANN_DIA_GROWTH5)) +
  geom_abline(slope = 1, intercept = 0) +
  theme(aspect.ratio = 1) +
  geom_point()
```


## Mortality

FVS uses mortality from the tree list to calibrate mortality for a stand. The
default period for the mortality observation period is 5 years.

```{r single seed tree init, eval = FALSE}
nrsgro_none_treeinit <- fvs_read_input(single_seed, "FVS_TreeInit_Plot")
```

FVS uses HISTORY to record the status of trees, where:
- Tree history codes of 0-5 are used to represent live tree records that are proejcted by FVS. FVS does not distinguish between the various live tree codes.
- Tree history codes 6, 7, 8 and 9 indicates types of tree records taht are not projected.
- The codes 6 and 7 trees are assumed to have died during the mortality observation period. FVS makes no distinction between tree records coded with a tree history of 6 or 7.
- The codes 8 and 9 represent trees that have been dead for longer periods of time. These records are included in the inventory list of trees but are not included in stand densities during calibration. FVS makes no distinction between tree records coded with a tree history of 8 or 9.

(Essential FVS, 4.2.1 Sample Tree Data Description)

```{r tree history histogram, eval = FALSE}
num_recent_dead <- nrsgro_none_treeinit |>
  filter(HISTORY %in% 6:7) |>
  nrow()
nrsgro_none_treeinit |>
  mutate(
    STATUS = case_when(
      HISTORY %in% 0:5 ~ "Live",
      HISTORY %in% 6:7 ~ "Recent Mortality",
      HISTORY %in% 8:9 ~ "Old Mortality",
      .default = "Other"
    )
  ) |>
  mutate(STATUS = as.factor(STATUS)) |>
  ggplot(aes(STATUS)) +
  geom_bar() +
  geom_text(aes(y = after_stat(count + 3500), label = after_stat(count)), stat = "count") +
  theme_bw()
```

So, ~1800 instances of recent mortality across 3000+ plots.

If we look in FIA, how many dead trees do we get if we expand from initial
survey to initial + 1 surveys?

nrsgro_tree is only live trees, so we need to go find the dead ones.
```{r nrsgro_tree_dead, eval = FALSE}
nrsgro_tree_dead <- fia_trees_filtered(fiadb, nrsgro_plot, \(.data, con) {
  .data |>
    # Only dead trees
    filter(STATUSCD == 2) |>
    # Only keep the first record of any dead tree
    group_by(STATECD, COUNTYCD, PLOT, SUBP, TREE) |>
    dbplyr::window_order(INVYR) |>
    filter(row_number() == 1) |>
    ungroup()
}) |>
  left_join(
    nrsgro_plot |>
      group_by(STATECD, COUNTYCD, PLOT) |>
      arrange(INVYR) |>
      mutate(INVNUM = row_number()) |>
      ungroup() |>
      select(STATECD, COUNTYCD, PLOT, INVYR, INVNUM),
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
  ) |>
  left_join(
    nrsgro_none_treeinit |>
      filter(HISTORY %in% 6:7) |>
      select(TREE_CN, HISTORY) |>
      rename(FVS_HISTORY = HISTORY),
    by = join_by(CN == TREE_CN)
  )

```

```{r dead trees by inventory, eval = FALSE}
nrsgro_tree_dead |>
  mutate(
    PREV_STATUS = case_when(
      PREV_STATUS_CD == 1 ~ "FIA Live",
      PREV_STATUS_CD == 2 ~ "FIA Dead",
      .default = "Unknown"
    )
  ) |>
  mutate(
    DECAY = ordered(DECAYCD, c("Minimal", "Branches", "Sapwood", "Heartwood", "Advanced"))
  ) |>
  ggplot(aes(INVNUM, fill = PREV_STATUS, group = PREV_STATUS)) +
  geom_bar(position = "dodge") +
  geom_text(aes(y = after_stat(count + 100), label = after_stat(count)), position = position_dodge(1), stat = "count")
```

...wait a second, that had 13000+ dead trees in INVNUM==1, whereas FVS only sees
1800 of them. Where'd the rest go?

Looking across TREEHISTCD, DECAYCD, PREV_STATUS_CD, and MORTYR, none of these
clearly results in 1863 recently dead trees.

So, it seems the thing to do is pick the 8541 recently dead trees in INVNUM==2
and back-propagate them to FVS, and extend the mortality observation period to
10 years.

Next challenge: FVS uses FIA tree numbers and synthesizes its own, and has limits
on the range of tree numbers. How do we insert these trees with appropriate
numbers such that they don't conflict with the live versions of themselves?

Note that all recent mortality in INVNUM==2 has PREV_TRE_CN matching TREE_CN
in FVS_TreeInit_Plot, so we can readily find those records and duplicate them
for mortality, adjusting DIA and HT as needed.

```{r dead trees by inventory and size class, eval = FALSE}
nrsgro_none_treeinit |>
  filter(HISTORY %in% 0:5) |>
  semi_join(
    nrsgro_tree_dead |> 
      filter(INVNUM == 2 & PREV_STATUS_CD == 1),
    by = join_by(TREE_CN == PREV_TRE_CN)
  ) |>
  nrow()
```

Oh, wait - I'm an idiot. I can join these two, so I can see what the FIA
trees have in common that causes them to be considered "recently dead" in
the FVS data.

```{r fia recently dead, eval = FALSE}
nrsgro_tree_dead |>
  filter(INVNUM == 1) |>
  ggplot(aes(DECAYCD, fill = FVS_HISTORY, group = FVS_HISTORY)) +
  geom_bar(position = "dodge") +
  geom_text(
    aes(y = after_stat(count + 100), label = after_stat(count)),
    position = position_dodge(1),
    stat = "count"
  )
```

Still nothing that correlates. But one thing this reveals is a bunch of trees
with TREECLCD_NERS==5 ("Tree that has recently died (within the last several years)")
that are not in FVS_TreeInit_Plot as dead trees; they could all be added.

Does TREECLCD_NERS==5 correlate with DECAYCD==1?

```{r tree class vs decay class, eval = FALSE}
nrsgro_tree_dead |>
  filter(INVNUM == 1 & !is.na(TREECLCD_NERS) & !is.na(DECAYCD)) |>
  mutate(TREECLCD_NERS = as.factor(TREECLCD_NERS)) |>
  mutate(DECAYCD = as.factor(DECAYCD)) |>
  ggplot(aes(DECAYCD, fill = TREECLCD_NERS, group = TREECLCD_NERS)) +
  geom_bar(position = "dodge") +
  geom_text(
    aes(y = after_stat(count + 60), label = after_stat(count)),
    position = position_dodge(1),
    stat = "count"
  )
```

TREECLCD_NERS==5 "recently dead with twigs" seem to correspond primarily
with DECAYCD==1-3, whereas DECAYCD 4-5 correspond with TREECLCD_NERS==6

Well, most (but not all) "recently dead" trees in FVS_TreeInit_Plot have
DECAYCD < 5, and the total number of trees there is close to the number
of recently dead trees in later inventories, so we could add all dead trees
for calibration.

```{r plot candidate recently dead trees for fvs, eval = FALSE}
nrsgro_tree_dead |>
  filter(INVNUM < 5) |>
  mutate(
    MORT_STATUS = case_when(
      FVS_HISTORY == 6 ~ "FVS Observed",
      PREV_STATUS_CD == 1 ~ "FIA Recently Dead",
      PREV_STATUS_CD == 2 ~ "FIA Long-Term Dead",
      INVNUM == 1 & DECAYCD < 5 ~ "FVS Candidate",
      .default = "Unknown"
    )
  ) |>
  ggplot(aes(INVNUM, fill = MORT_STATUS, group = MORT_STATUS)) +
  geom_bar(position = "dodge") +
  geom_text(aes(y = after_stat(count + 250), label = after_stat(count)), position = position_dodge(1), stat = "count") +
  scale_fill_discrete(name = "Mortality Status") +
  ylab("Number of trees") +
  xlab("Inventory Number") +
  ggtitle("Candidate Trees for FVS Mortality Calibration")


```

A more principled approach, however, would be to remove the dead trees from
FVS_TreeInit_Plot, and replace them with dead trees from the next inventory,
with appropriate modification to the GROWTH keyword (Field 5: Mortality
observation period (years))

What would it take to do this?

We need to remove the mortality records that FIA puts in FVS_TreeInit_Plot,
and instead insert our own.

```{r fia mortality tree records, eval = FALSE}
knitr::kable(nrsgro_none_treeinit |>
  mutate(
    STATUS = case_when(
      HISTORY %in% 0:5 ~ "Live",
      HISTORY %in% 6:7 ~ "Recent Mortality",
      HISTORY %in% 8:9 ~ "Old Mortality",
      .default = "Other"
    )
  ) |>
  mutate(STATUS = as.factor(STATUS)) |>
  group_by(STATUS) |>
  filter(row_number() == 1) |>
  ungroup())
```

It looks like:
* STAND_CN: PLOT.CN from INVNUM==1
* STAND_ID: fvs_standid() from INVNUM==1
* PLOT_CN: PLOT.CN from INVNUM==1
* STANDPLOT_CN: paste0(PLOT.CN, "_", SUBP) from INVNUM==1
* STANDPLOT_ID: paste0(STAND_ID, "_", SUBP) from INVNUM==1
* PLOT_ID: SUBP from INVNUM==1
* TREE_CN: TREE.CN from INVNUM==2
* TREE_ID: TREE.TREE - needs to be unique within STAND_ID, PLOT_ID, TREE_ID
  This is an integer, so think carefully :-/ 
* TAG_ID: NULL
* DISTANCE: NULL
* SITE_TREE_FLAG: NULL
* TREE_COUNT: Probably TPA_UNADJ * CONDPROP_UNADJ
* MORT_AGENT: NULL
* WDLND_STEMS: NULL
* HISTORY: 6 (recent mortality) or 8 (snag)
* SPECIES: TREE.SPCD - FIA Species Code, must be 3 digits (leading 0s)
* DIAMETER: TREE.DIA in inches
* DIAMETER_HTCD: NULL - FVS Ignores this
* HT: TREE.HEIGHT in feet
* HTTOPK: height to point of top kill, TREE.ACTUALHT
* HTBOLE: NULL
* TPBOLE: NULL
* HTSAW: NULL
* HT_TO_CROWN_BASE: NULL for dead trees
* CRRATIO: NULL for dead trees
* UNCRRATIO: NULL
* CRCLASS: NULL for dead trees
* DAMAGE1/2/3: NULL
* SEVERITY1/2/3: NULL
* DEFECT_CUBIC: NULL - FVS Ignores this
* DEFECT_BOARD: NULL
* TREEVALUE: NULL
* PRESCRIPTION: NULL
* AGE: NULL
* BH_YEARS: NULL
* SLOPE: PLOT.SLOPE
* ASPECT: PLOT.ASPECT
* PV_CODE: NULL
* PV_REF_CODE: NULL
* TOPOCODE: NULL
* SITEPREP: NULL
* CREATED_DATE: TREE.CREATED_DATE
* MODIFIED_DATE: TREE.MODIFIED_DATE
* VERSION: 2.0.20.0 - FVS Ignores this

Among these, the only interesting one is TREE_ID.

Proposal: max(TREE.TREE) for INVYR==1, plus row_number() of dead trees for INVYR==2
TREE_CN will have the correct TREE.CN, so it doesn't really matter what we put in TREE_ID.

So we need:
* STAND_CN: PLOT.CN from INVNUM==1
* STAND_ID: fvs_standid() from INVNUM==1
* PLOT_CN: PLOT.CN from INVNUM==1
* PLOT_ID: SUBP from INVNUM==1
* STANDPLOT_CN: paste0(PLOT.CN, "_", SUBP) from INVNUM==1
* STANDPLOT_ID: paste0(STAND_ID, "_", SUBP) from INVNUM==1
* TREE_CN: TREE.CN from INVNUM==2
* TREE_ID: TREE.TREE - needs to be unique within STAND_ID, PLOT_ID, TREE_ID
  This is an integer, so think carefully :-/ 
* TREE_COUNT: Probably TPA_UNADJ * CONDPROP_UNADJ
* HISTORY: 6 (recent mortality) or 8 (snag)
* SPECIES: TREE.SPCD - FIA Species Code, must be 3 digits (leading 0s)
* DIAMETER: TREE.DIA in inches
* HT: TREE.HEIGHT in feet
* SLOPE: COND.SLOPE
* ASPECT: COND.ASPECT

What's the minimum we can get away with, WITHOUT additional lookups?
STAND_ID, PLOT_CN, STANDPLOT_CN, STANDPLOTID, SLOPE, ASPECT - can be filled from other data
So we need:
STAND_CN, TREE_CN, PLOT_ID, TREE_ID, TREE_COUNT, DIAMETER, HT, HISTORY, SPECIES

Meh, let's just provide a function to fetch next-inventory mortality for a plot.

```{targets nrsgro_calb_mortality, tar_simple = TRUE}
max_tree_id <- nrsgro_tree_history |>
  group_by(STATECD, COUNTYCD, PLOT, SUBP, INVYR) |>
  summarize(MAX_TREE = max(TREE, na.rm = TRUE), .groups = "keep") |>
  ungroup()

prev_plot_cn <- nrsgro_plot |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  arrange(INVYR) |>
  filter(row_number() == 1) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, CN) |>
  rename(PREV_PLT_CN = CN)

cond_mixin <- fia_conds(
  fiadb,
  nrsgro_tree_dead |>
    filter(INVNUM == 2) |>
    distinct(STATECD, COUNTYCD, PLOT, INVYR)
  ) |>
  select(
    STATECD, COUNTYCD, PLOT, CONDID, INVYR, SLOPE, ASPECT
  )

prev_tree_mixin <- fia_trees_by_cn(
  fiadb,
  nrsgro_tree_dead |>
    filter(INVNUM == 2) |>
    select(PREV_TRE_CN) |>
    rename(CN = PREV_TRE_CN)
  ) |>
  select(CN, DIA, HT, TPA_UNADJ) |>
  rename(
    PREV_TRE_CN = CN,
    PREV_DIA = DIA,
    PREV_HT = HT,
    PREV_TPA_UNADJ = TPA_UNADJ
  )

nrsgro_tree_dead |>
  filter(INVNUM == 2) |>
  left_join(
    max_tree_id,
    by = join_by(STATECD, COUNTYCD, PLOT, SUBP, INVYR)
  ) |>
  group_by(STATECD, COUNTYCD, PLOT, SUBP) |>
  arrange(TREE) |>
  mutate(
    TREE_ID = MAX_TREE + row_number()
  ) |>
  ungroup() |>
  left_join(prev_tree_mixin, by = join_by(PREV_TRE_CN)) |>
  left_join(prev_plot_cn, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  left_join(cond_mixin, by = join_by(STATECD, COUNTYCD, PLOT, CONDID, INVYR)) |>
  filter_add_stand_id() |>
  mutate(
    STAND_CN = PREV_PLT_CN,
    STAND_ID = STAND_ID,
    PLOT_CN = PREV_PLT_CN,
    PLOT_ID = SUBP,
    STANDPLOT_CN = paste0(STAND_CN, "_", SUBP),
    STANDPLOT_ID = paste0(STAND_ID, "_", SUBP),
    TREE_CN = CN,
    TREE_ID = TREE_ID,
    TREE_COUNT = coalesce(TPA_UNADJ, PREV_TPA_UNADJ),
    SPECIES = sprintf("%03d", SPCD),
    HISTORY = if_else(PREV_STATUS_CD == 1, "6", "8"),
    DIAMETER = coalesce(DIA, PREV_DIA),
    HT = coalesce(HT, PREV_HT),
    SLOPE = SLOPE,
    ASPECT = ASPECT
  ) |>
  select(
    STAND_CN,
    STAND_ID,
    PLOT_CN,
    PLOT_ID,
    STANDPLOT_CN,
    STANDPLOT_ID,
    TREE_CN,
    TREE_ID,
    TREE_COUNT,
    SPECIES,
    HISTORY,
    DIAMETER,
    HT,
    SLOPE,
    ASPECT
  )

```

# Calibrating FVS

## GROWTH Keyword

It looks like we will want to use the GROWTH keyword to adjust the observation
period:
GROWTH
- Field 1: diameter method; we will use value 3: "Subsequent measurement. Current diameter represents an
outside-bark measurement at the beginning of the growth
measurement period, and diameter increment represents a total
outside-bark diameter measurement at the end of the growth
measurement period."
- Field 2: Length of growth remeasurement; we will use 5 years
- Field 3: height method; we will used 3 to match field 1
- Field 4: Length of height remeasurement; we will use 5 years
- Field 5: Mortality observation period; we will use 5 years

## Choices and Rationale

Fields 1 and 3 we will use method 3 because we have subsequent measurement 
available in the FIA data, and we can input FIA measurements directly.

Fields 2 and 4, FVS recommends using the number of years the model is calibrated
for, typically 10. This leaves us with a choice; do we:

a. use a single FIA remeasurement interval (5 years); this is how FIA populates
   FIADB.FVS_TreeInit_Plot.DG; or
b. use two remeasurement intervals (10 years) to align with FVS calibration

Since FIA uses 5 years, we will use option a, 5 years.

This gives us another choice; do we:

a. use the actual measurement from the next FIA inventory, which may be
   more or less than 5 years out; or
b. compute the annualized growth using FIADB.PLOT.REMPER then multiply by the
   growth interval
   
FIA uses the actual value, no matter how long the remeasurement period is.
We choose instead to use method b, to compute an accurate annual growth rate
and multiply by the growth remeasurement period given to FVS.

Thus, we will:

- For all FIA trees in the FVS stand,
- Compute ANNUAL_DIA_GROWTH = (NEXT_TREE.DIA - TREE.DIA) / NEXT_PLOT.REMPER
  (and the same for HT)
- Compute DG = ANNUAL_DIA_GROWTH * FVS_DIA_REMPER
  (and the same for ht)
- Fill these into a calibration table
- When populating FVS input tables, override DG and HTG from the calibration table
- When generating FVS keywords, fill in GROWTH appropriately

## Calibration Table

```{targets nrsgro_calb_calibration, tar_simple = TRUE}
starting_plots <- nrsgro_plot |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  arrange(INVYR) |>
  filter(row_number() == 1) |> 
  ungroup()

tmp_tre <- fia_trees(fiadb, starting_plots) |>
  select(CN, PLT_CN, STATECD, COUNTYCD, PLOT, INVYR, PREV_TRE_CN, DIA, HT)

tmp_nxt_tre <- fia_trees_filtered(
  fiadb,
  plots = NULL,
  \(.data, con) {
    .data |>
      inner_join(
        tmp_tre |>
          select(CN) |>
          rename(PREV_TRE_CN = CN),
        by = join_by(PREV_TRE_CN),
        copy = TRUE
      ) |>
      select(PREV_TRE_CN, CN, PLT_CN, DIA, HT) |>
      rename(
        NEXT_TRE_CN = CN,
        CN = PREV_TRE_CN,
        NEXT_PLT_CN = PLT_CN,
        NEXT_DIA = DIA,
        NEXT_HT = HT
      )
  }
)

tmp_plt <- nrsgro_plot |>
  select(CN, REMPER) |>
  rename(NEXT_PLT_CN = CN)

# For FVS, we need:
# STAND_CN
# TREE_CN
# DG
# HTG
# The rest is assumed

tmp_tre |>
  left_join(tmp_nxt_tre, by = join_by(CN)) |>
  left_join(tmp_plt, by = join_by(NEXT_PLT_CN)) |>
  mutate(
    ANN_DIA_GROWTH = (NEXT_DIA - DIA) / REMPER,
    DG = DIA + ANN_DIA_GROWTH * 5,
    ANN_HT_GROWTH = (NEXT_HT - HT) / REMPER,
    HTG = HT + ANN_HT_GROWTH * 5
  ) |>
  filter(!is.na(DG) & !is.na(HTG)) |>
  select(PLT_CN, CN, DG, HTG) |>
  rename(
    STAND_CN = PLT_CN,
    TREE_CN = CN
  )
```

# Run FVS

```{targets nrsgro_calb}
tar_target(
  nrsgro_calb,
  {
    # fvs_run wants a table of the form:
    # STAND_ID - arbitrary identifier for a stand
    # STAND_CN - CN for the plot
    # FIRST_YEAR - start of the projection; if this doesn't align with the actual
    #   year (MEASYEAR) of first survey, the stand will be projected from the
    #   survey year to the start of the projection.
    # LAST_YEAR - end of the projection
    timestep <- 10 # years; determined by FVSne variant
    
    plots_for_fvs <- nrsgro_plot |>
      group_by(STATECD, COUNTYCD, PLOT) |>
      arrange(INVYR) |>
      mutate(
        STAND_CN = if_else(row_number() == 1, CN, NA)
      ) |>
      summarize(
        STAND_CN = min(STAND_CN, na.rm = TRUE), # only one will not be NA
        FIRST_YEAR = min(MEASYEAR, na.rm = TRUE),
        LAST_YEAR = max(MEASYEAR, na.rm = TRUE),
        .groups = "keep"
      ) |>
      ungroup() |>
      mutate(
        # STAND_ID won't match FVS_PLOTINIT_PLOT.STAND_ID; that's OK
        STAND_ID = sprintf("%04d%03d%05d", STATECD, COUNTYCD, PLOT)
      )
    
    # fvs_run wants establishment in the form:
    # STAND_CN
    # SPECIES (FVS_SPCD)
    # DENSITY (TPA)
    # HEIGHT (FT)
    estab_for_fvs <- nrsgro_estab_rate |>
      mutate(
        STAND_ID = sprintf("%04d%03d%05d", STATECD, COUNTYCD, PLOT)
      ) |>
      left_join(
        plots_for_fvs |> select(STAND_ID, STAND_CN),
        by = join_by(STAND_ID)
      ) |>
      select(STAND_CN, STATECD, COUNTYCD, PLOT, SPCD, RATE_PER_ACRE) |>
      mutate(RATE_PER_ACRE = floor(RATE_PER_ACRE * timestep)) |>
      rename(DENSITY = RATE_PER_ACRE) |>
      left_join(
        nrsgro_estab_height |>
          select(STATECD, COUNTYCD, PLOT, SPCD, HT),
        by = join_by(STATECD, COUNTYCD, PLOT, SPCD)
      ) |>
      mutate(HT = floor(HT)) |>
      rename(HEIGHT = HT) |>
      left_join(
        species_crosswalk |>
          select(SPCD, FVS_SPCD),
        by = join_by(SPCD)
      ) |>
      rename(SPECIES = FVS_SPCD) |>
      filter(!is.na(SPECIES) & !is.na(DENSITY) & !is.na(HEIGHT)) |>
      select(STAND_CN, SPECIES, DENSITY, HEIGHT)
      
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "NRSGrowOnly"
    mgmt_id <- "CALB"
    
    # We communicate with FVS through files. FVSOnline shows a model in which
    # a "project" (the inputs and outputs of a single FVS run) live in a
    # single directory; we follow that model.
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = fiadb,
      title = title,
      mgmt_id = mgmt_id,
      stands = plots_for_fvs,
      calibration = nrsgro_calb_calibration,
      calib_mort = nrsgro_calb_mortality,
      regen = estab_for_fvs,
      num_partitions = fvs_num_partitions,
      partition = fvs_partition,
      random_seed = fvs_randseed
    )
  },
  # iteration = "vector" branches execution for each partition value (see below)
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here.
  # cross() ensures that every combination of values for its arguments is processed
  # map() distributes each value of its argument to a separate sub-target (branch)
  # so cross(randseed, map(partition)) will run each partition in a separate branch,
  # and each branch will run with each value of randseed
  pattern = cross(fvs_randseed, map(fvs_partition))
)
```

# Load Results

## NRS GrowOnly CALB

Carbon

```{targets nrsgro_calb_carbon, tar_simple = TRUE}
fvs_read_output(nrsgro_calb, "FVS_Carbon") |>
  group_by(StandID, Year) |> # Combine results from different random seeds
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    .groups = "keep"
  ) |>
  ungroup()
```

Summary

```{targets nrsgro_calb_summary, tar_simple = TRUE}
fvs_read_output(nrsgro_calb, "FVS_Summary2_East") |>
  group_by(StandID, Year) |>
  summarize(
    BA = mean(BA),
    Tpa = mean(Tpa),
    .groups = 'keep'
  ) |>
  ungroup()
```

# Calibration Rate

Did we actually get calibration?

```{r nrsgro_calb_calibration cases, eval = FALSE}
single_seed <- nrsgro_calb |>
  group_by() |>
  filter(random_seed == min(random_seed)) |>
  ungroup()
nrsgro_calb_cases <- fvs_read_output(single_seed, "FVS_Cases")
nrsgro_calb_calibstats <- fvs_read_output(single_seed, "FVS_CalibStats")
num_cases <- nrsgro_calb_cases |> distinct(CaseID) |> nrow()
num_cases_calibrated <- nrsgro_calb_calibstats |> distinct(CaseID) |> nrow()
num_cases_calibrated /  num_cases
```
...which makes it look like 60% of runs got calibration.

Did we populate the calibration table correctly?
```{r calibration input, eval = FALSE}
first_random_seed <- nrsgro_calb |>
  filter(random_seed == min(random_seed))
calibration_input <- fvs_read_input(first_random_seed, "FVS_TreeInit_Plot") |>
  select(STAND_CN, TREE_CN, SPECIES, DIAMETER, HT, DG, HTG) |>
  mutate(Diameter = DG / DIAMETER, Height = HTG / HT) |>
  pivot_longer(
    cols = c(Diameter, Height),
    names_to = "Metric",
    values_to = "Ratio"
  ) |> filter(!is.na(Ratio))
calibration_input |>
  ggplot(aes(Ratio, fill = Metric)) +
  geom_histogram(position = "dodge", binwidth = 0.1) +
  coord_cartesian(xlim = c(0, 2))
```


which shows that the calibration data for most trees has them growing, rather
than shrinking. Note that trees often shrink in the FIA data, so this meets
expectations.

What kind of calibration did we get?
```{r plot calibstats, eval = FALSE}
nrsgro_calb_calibstats |>
  mutate(Log10ScaleFactor = log10(ScaleFactor)) |>
  ggplot(aes(Log10ScaleFactor)) +
  geom_histogram(binwidth = 0.1) +
  geom_vline(xintercept = 0) +
  theme_bw()
```

So it skews a bit towards negative, but not as much as I thought.

```{r calibstats scalefactor rmse, eval = FALSE}
nrsgro_calb_calibstats |>
  mutate(Log10ScaleFactor = log10(ScaleFactor)) |>
  summarise(
    RMSE = sqrt(mean((Log10ScaleFactor) ^ 2))
  )
```

# Calibrated vs. Uncalibrated

```{r calb_vs_none, eval = FALSE}
stand_mixin <- nrsgro_plot_stats |>
  filter_add_stand_id() |>
  group_by(STAND_ID) |>
  arrange(INVYR) |>
  filter(row_number() == 1) |>
  ungroup() |>
  select(STAND_ID, MEASYEAR) |>
  rename(StandID = STAND_ID, StartYear = MEASYEAR)

none_carbon_tmp <- nrsgro_none_carbon |>
  rename(Carbon = Aboveground_Total_Live) |>
  select(StandID, Year, Carbon) |>
  group_by(StandID) |>
  arrange(Year) |>
  mutate(Carbon_Delta = Carbon - lag(Carbon)) |>
  ungroup() |>
  filter(!is.na(Carbon_Delta))

calb_carbon_tmp <- nrsgro_calb_carbon |>
  rename(Carbon = Aboveground_Total_Live) |>
  select(StandID, Year, Carbon) |>
  group_by(StandID) |>
  arrange(Year) |>
  mutate(Carbon_Delta = Carbon - lag(Carbon)) |>
  ungroup() |>
  filter(!is.na(Carbon_Delta))

calb_vs_none <- none_carbon_tmp |>
  rename(Carbon_None = Carbon, Carbon_Delta_None = Carbon_Delta) |>
  left_join(calb_carbon_tmp, by = join_by(StandID, Year)) |>
  rename(Carbon_Calb = Carbon, Carbon_Delta_Calb = Carbon_Delta) |>
  left_join(stand_mixin, by = join_by(StandID)) |>
  mutate(
    Carbon_Diff = Carbon_Calb - Carbon_None,
    ProjectionYears = Year - StartYear,
    Carbon_Flux_Calb = Carbon_Delta_Calb / ProjectionYears,
    Carbon_Flux_None = Carbon_Delta_None / ProjectionYears,
    Carbon_Flux_Delta = Carbon_Flux_Calb - Carbon_Flux_None
  )
```

```{r plot calb_vs_none flux, eval = FALSE}
formula <- y ~ x

calb_vs_none |>
  group_by(StandID) |>
  arrange(desc(ProjectionYears)) |>
  filter(row_number() == 1) |>
  ungroup() |>
  filter(is.finite(Carbon_Flux_Calb) & is.finite(Carbon_Flux_None)) |>
  filter(
    Carbon_Flux_None > quantile(calb_vs_none$Carbon_Flux_None, 0.01, na.rm = TRUE),
    Carbon_Flux_None < quantile(calb_vs_none$Carbon_Flux_None, 0.99, na.rm = TRUE)
  ) |>
  ggplot(aes(Carbon_Flux_None, Carbon_Flux_Calb)) +
  geom_point(size = 0.1) +
  geom_abline(slope = 1, intercept = 0, linewidth = 0.25) +
  scale_y_continuous(limits = c(0, 5)) +
  scale_x_continuous(limits = c(0, 5)) +
  stat_poly_line(formula = formula, se = FALSE, linewidth = 0.25) +
  stat_poly_eq(use_label("eq", "R2"), formula = formula) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  ggtitle("FVS Grow-Only Calibrated vs. Uncalibrated Annual Carbon Flux") +
  xlab(bquote("Uncalibrated Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% year^-1))) +
  ylab(bquote("Calibrated Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% year^-1)))

```


```{r plot calb_vs_none, eval = FALSE}
calb_vs_none |>
  filter(!is.na(Carbon_Flux_Delta)) |>
  ggplot(aes(factor(ProjectionYears), Carbon_Diff)) +
  geom_boxplot(outlier.size = 0.1) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  coord_cartesian(ylim = c(-3, 3), xlim = c(1, 20)) +
  ggtitle("FVS Grow-Only Calibrated vs. Uncalibrated Projected Stand Carbon") +
  xlab("Projection Years") +
  ylab(bquote("Stand Carbon Delta" ~ (`Mg C` %.% ha^-1)))
```

# Projected vs. Measured

Build a dataframe to compare projected carbon (with calibration) to measured
carbon (as done before, no calibration needed).

```{targets nrsgro_calb_proj_vs_meas, tar_simple = TRUE}
projected_carbon_tmp <- nrsgro_calb_carbon |>
  select(StandID, Year, Aboveground_Total_Live) |>
  rename(Projected_Carbon = Aboveground_Total_Live)

projected_ba_tmp <- nrsgro_calb_summary |>
  select(StandID, Year, BA, Tpa) |>
  mutate(Projected_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  rename(Projected_Tpa = Tpa)

projected_tmp <- projected_carbon_tmp |>
  full_join(projected_ba_tmp, by = join_by(StandID, Year)) |>
  select(StandID, Year, Projected_Carbon, Projected_BA, Projected_Tpa)

surveyed_carbon_tmp <- nrsgro_srvy_carbon |>
  select(StandID, Year, Aboveground_Total_Live) |>
  rename(Measured_Carbon = Aboveground_Total_Live)

surveyed_ba_tmp <- nrsgro_srvy_summary |>
  select(StandID, Year, BA, Tpa) |>
  mutate(Measured_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  rename(Measured_Tpa = Tpa)

surveyed_tmp <- surveyed_carbon_tmp |>
  full_join(surveyed_ba_tmp, by = join_by(StandID, Year)) |>
  filter(!is.na(Measured_Carbon)) |> # other metrics get an extra year
  select(StandID, Year, Measured_Carbon, Measured_BA, Measured_Tpa)

nrsgro_plot |>
  filter_add_stand_id() |>
  rename(StandID = STAND_ID, Year = MEASYEAR) |>
  left_join(nrsgro_plot_stats, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
  left_join(fvsne_states, by = join_by(STATECD)) |>
  select(
    StandID, Year, STATE_NAME,
    STDAGE, FOREST_TYPE, FOREST_TYPE_GROUP, ECOSUBCD,
    QMD, QMD_METRIC
  ) |>
  left_join(projected_tmp, by = join_by(StandID, Year)) |>
  left_join(surveyed_tmp, by = join_by(StandID, Year)) |>
  filter_decode_forest_type_group() |>
  group_by(StandID) |>
  mutate(
    ECOCD = substr(ECOSUBCD, 1, nchar(ECOSUBCD) - 1),
    First_Year = min(Year, na.rm = TRUE),
    Last_Year = max(Year, na.rm = TRUE),
    Starting_Carbon = min(if_else(Year == First_Year, Measured_Carbon, NA), na.rm = TRUE),
    Projected_Carbon_Delta = Projected_Carbon - Starting_Carbon,
    Projected_Carbon_Flux = if_else(Year == First_Year, 0, -(Projected_Carbon_Delta / (Year - First_Year))),
    Measured_Carbon_Delta = Measured_Carbon - Starting_Carbon,
    Measured_Carbon_Flux = if_else(Year == First_Year, 0, -(Measured_Carbon_Delta / (Year - First_Year))),
    Starting_BA = min(if_else(Year == First_Year, Measured_BA, NA), na.rm = TRUE),
    Projected_BA_Delta = Projected_BA - Starting_BA,
    Projected_BAI = if_else(Year == First_Year, 0, Projected_BA_Delta / (Year - First_Year)),
    Measured_BA_Delta = Measured_BA - Starting_BA,
    Measured_BAI = if_else(Year == First_Year, 0, Measured_BA_Delta / (Year - First_Year))
  ) |>
  ungroup() |>
  filter(Year == First_Year | Year == Last_Year) |>
  filter(!is.na(Projected_Carbon) & !is.na(Measured_Carbon)) |>
  mutate(
    Projection_Years = Year - First_Year,
    BA_Residual = Projected_BA - Measured_BA,
    BA_Error = 2 * abs(BA_Residual) / (Projected_BA + Measured_BA),
    BA_Delta_Residual = Projected_BA_Delta - Measured_BA_Delta,
    BAI_Residual = BA_Delta_Residual / Projection_Years,
    Carbon_Residual = Projected_Carbon - Measured_Carbon,
    Carbon_Error = 2 * abs(Carbon_Residual) / (Projected_Carbon + Measured_Carbon),
    Carbon_Delta_Residual = Projected_Carbon_Delta - Measured_Carbon_Delta,
    Carbon_Flux_Residual = Projected_Carbon_Flux - Measured_Carbon_Flux
  )
```

# Carbon Flux

How does projected carbon flux compare to measured carbon flux?
```{r proj_vs_meas_carbon_flux, eval = FALSE}
ggplot(
  nrsgro_calb_proj_vs_meas |> filter(Projection_Years > 0),
  aes(x = Measured_Carbon_Flux, y = Projected_Carbon_Flux)
) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_vline(xintercept = 0, linewidth = 0.25, color = "black") +
  geom_abline(intercept = 0, slope = 1, linewidth = 0.25, linetype = "dashed", color = "lightgray") +
  geom_bin2d(bins = 50) +
  scale_fill_gradient(
    name = "Number of Plots",
    low = "lightblue",
    high = "darkblue",
#    limits = c(0, 125)
  ) +
  # stat_poly_* plots and annotates a fit; they need to be configured to match
  stat_poly_line(
    formula = y ~ x,
    fullrange = TRUE,
    se = FALSE,
    color = "darkblue",
    linetype = "dashed",
    linewidth = 0.5
) +
  stat_poly_eq(use_label("eq", "R2"), formula = y ~ x, size = 3) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  ggtitle("FVS Projected vs. FIA Measured\nAGL Carbon Flux in Grow-Only Stands") +
  labs(caption = "With Calibration") +
  xlab(bquote("Measured Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  ylab(bquote("Projected Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  coord_cartesian(xlim = c(-10, 10), ylim = c(-10, 10))
```

```{r proj_vs_meas_carbon_flux by ecoregion, eval = FALSE}
ggplot(
  nrsgro_calb_proj_vs_meas |> filter(Projection_Years > 0),
  aes(x = Measured_Carbon_Flux, y = Projected_Carbon_Flux)
) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_vline(xintercept = 0, linewidth = 0.25, color = "black") +
  geom_abline(intercept = 0, slope = 1, linewidth = 0.25, linetype = "dashed", color = "lightgray") +
  #geom_bin2d(bins = 50) +
  geom_point(size = 0.25) +
  scale_fill_gradient(
    name = "Number of Plots",
    low = "lightblue",
    high = "darkblue",
    #limits = c(0, 125)
  ) +
  # stat_poly_* plots and annotates a fit; they need to be configured to match
  stat_poly_line(
    formula = y ~ x,
    fullrange = TRUE,
    se = FALSE,
    color = "darkblue",
    linetype = "dashed",
    linewidth = 0.5
) +
  stat_poly_eq(use_label("eq", "R2"), formula = y ~ x, size = 3) +
  facet_wrap("ECOCD") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  ggtitle("FVS Projected vs. FIA Measured\nAGL Carbon Flux\nin Grow-Only Stands") +
  labs(caption = "With Calibration") +
  xlab(bquote("Measured Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  ylab(bquote("Projected Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  coord_cartesian(xlim = c(-10, 10), ylim = c(-10, 10))
```


```{r proj_vs_meas_carbon_flux by forest type, eval = FALSE}
ggplot(
  nrsgro_calb_proj_vs_meas |> filter(Projection_Years > 0),
  aes(x = Measured_Carbon_Flux, y = Projected_Carbon_Flux)
) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_vline(xintercept = 0, linewidth = 0.25, color = "black") +
  geom_abline(intercept = 0, slope = 1, linewidth = 0.25, linetype = "dashed", color = "lightgray") +
  #geom_bin2d(bins = 50) +
  geom_point(size = 0.25) +
  scale_fill_gradient(
    name = "Number of Plots",
    low = "lightblue",
    high = "darkblue",
    #limits = c(0, 125)
  ) +
  # stat_poly_* plots and annotates a fit; they need to be configured to match
  stat_poly_line(
    formula = y ~ x,
    fullrange = TRUE,
    se = FALSE,
    color = "darkblue",
    linetype = "dashed",
    linewidth = 0.5
) +
  stat_poly_eq(use_label("eq", "R2"), formula = y ~ x, size = 3) +
  facet_wrap("FOREST_TYPE_GROUP") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  ggtitle("FVS Projected vs. FIA Measured\nAGL Carbon Flux\nin Grow-Only Stands") +
  labs(caption = "With Calibration") +
  xlab(bquote("Measured Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  ylab(bquote("Projected Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  coord_cartesian(xlim = c(-10, 10), ylim = c(-10, 10))
```


```{r proj_vs_meas_carbon_flux by state, eval = FALSE}
ggplot(
  nrsgro_calb_proj_vs_meas |> filter(Projection_Years > 0),
  aes(x = Measured_Carbon_Flux, y = Projected_Carbon_Flux)
) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_vline(xintercept = 0, linewidth = 0.25, color = "black") +
  geom_abline(intercept = 0, slope = 1, linewidth = 0.25, linetype = "dashed", color = "lightgray") +
  #geom_bin2d(bins = 50) +
  geom_point(size = 0.25) +
  scale_fill_gradient(
    name = "Number of Plots",
    low = "lightblue",
    high = "darkblue",
    #limits = c(0, 125)
  ) +
  # stat_poly_* plots and annotates a fit; they need to be configured to match
  stat_poly_line(
    formula = y ~ x,
    fullrange = TRUE,
    se = FALSE,
    color = "darkblue",
    linetype = "dashed",
    linewidth = 0.5
) +
  stat_poly_eq(use_label("eq", "R2"), formula = y ~ x, size = 3) +
  facet_wrap("STATE_NAME") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  ggtitle("FVS Projected vs. FIA Measured\nAGL Carbon Flux\nin Grow-Only Stands") +
  labs(caption = "With Calibration") +
  xlab(bquote("Measured Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  ylab(bquote("Projected Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  coord_cartesian(xlim = c(-10, 10), ylim = c(-10, 10))
```


```{r proj_vs_meas_carbon_flux by latitude, eval = FALSE}
nrsgro_calb_proj_vs_meas |>
  filter(Projection_Years > 0) |>
  left_join(
    nrsgro_plot |>
      filter_add_stand_id() |>
      select(STAND_ID, LAT, LON, ELEV) |>
      rename(StandID = STAND_ID),
    by = join_by(StandID)
  ) |>
  mutate(
    Latitude = cut(LAT, trunc(min(LAT)):trunc(max(LAT)+1))
  ) |>
ggplot(
  aes(x = Measured_Carbon_Flux, y = Projected_Carbon_Flux)
) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_vline(xintercept = 0, linewidth = 0.25, color = "black") +
  geom_abline(intercept = 0, slope = 1, linewidth = 0.25, linetype = "dashed", color = "lightgray") +
  #geom_bin2d(bins = 50) +
  geom_point(size = 0.1) +
  scale_fill_gradient(
    name = "Number of Plots",
    low = "lightblue",
    high = "darkblue",
    #limits = c(0, 125)
  ) +
  # stat_poly_* plots and annotates a fit; they need to be configured to match
  stat_poly_line(
    formula = y ~ x,
    fullrange = TRUE,
    se = FALSE,
    color = "darkblue",
    linetype = "dashed",
    linewidth = 0.5
) +
  stat_poly_eq(use_label("eq", "R2"), formula = y ~ x, size = 3) +
  facet_wrap("Latitude", labeller = "label_both") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  ggtitle("FVS Projected vs. FIA Measured\nAGL Carbon Flux\nin Grow-Only Stands") +
  labs(caption = "With Calibration") +
  xlab(bquote("Measured Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  ylab(bquote("Projected Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  coord_cartesian(xlim = c(-10, 10), ylim = c(-10, 10))
```


Plot carbon flux on a map

```{r plot location with measured carbon flux, eval = FALSE}
fvsne_states_map <- fvsne_states |>
  distinct(STATE_NAME) |>
  rename(region = STATE_NAME) |>
  _$region |>
  map_data("state", region = _)

plot_location_tmp <- nrsgro_plot |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  filter_add_stand_id() |>
  select(STAND_ID, CN, LAT, LON, ELEV) |>
  rename(
    StandID = STAND_ID,
    group = CN,
    lat = LAT,
    long = LON,
    elev = ELEV
  )

plot_carbon_tmp <- nrsgro_calb_proj_vs_meas |>
  filter(Projection_Years > 0) |>
  left_join(
    plot_location_tmp,
    by = join_by(StandID)
  )

ggplot(fvsne_states_map, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") +
  geom_point(
    plot_carbon_tmp,
    mapping = aes(long, lat, group = group, color = Measured_Carbon_Flux),
    size = 0.5
  ) +
  coord_sf(crs = 4326) +
  annotation_scale(location = "br") +
  annotation_north_arrow(
    location = "tl",
    width = unit(1, "cm"),
    pad_x = unit(0.75, "cm"),
    pad_y = unit(0.5, "cm")
  ) +
  theme_bw() +
  theme(legend.position = "bottom") +
#  scale_color_discrete(name = NULL) +
  scale_color_gradient2(
    name = bquote("Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1)),
    high = "red",
    mid = "lightgray",
    low = "blue"
  ) +
  ggtitle("FIA Measured Carbon Flux by Plot Location")

remove(plot_location_tmp)
```

```{r measured carbon flux by latitude, eval = FALSE}
nrsgro_calb_proj_vs_meas |>
  filter(Projection_Years > 0) |>
  left_join(
    plot_location_tmp,
    by = join_by(StandID)
  ) |>
  mutate(lat_adj = lat + elev / 500) |>
  ggplot(aes(lat, Measured_Carbon_Flux)) +
  geom_point(size = 0.1) +
  stat_poly_line() +
  stat_poly_eq(use_label("eq", "R2")) +
  facet_wrap("FOREST_TYPE_GROUP") +
  theme_bw() +
  ggtitle("FIA Measured Annual Carbon Flux by Latitude") +
  ylab(bquote("Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  xlab("Latitude (degrees)")
```

```{r measured carbon flux by latitude adjusted for elevation, eval = FALSE}
nrsgro_calb_proj_vs_meas |>
  filter(Projection_Years > 0) |>
  left_join(
    plot_location_tmp,
    by = join_by(StandID)
  ) |>
  mutate(lat_adj = lat + elev / 500) |>
  ggplot(aes(lat_adj, Measured_Carbon_Flux)) +
  geom_point() +
  stat_poly_line() +
  stat_poly_eq(use_label("eq", "R2")) +
  theme_bw() +
  ggtitle("Measured Annual Carbon Flux by Latitude adjusted for Elevation") +
  ylab(bquote("Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  xlab("Adjusted Latitude (degrees)")
```

```{r projected carbon flux by latitude, eval = FALSE}
nrsgro_calb_proj_vs_meas |>
  filter(Projection_Years > 0) |>
  left_join(
    plot_location_tmp,
    by = join_by(StandID)
  ) |>
  mutate(lat_adj = lat + elev / 500) |>
  ggplot(aes(lat, Projected_Carbon_Flux)) +
  geom_point() +
  stat_poly_line() +
  stat_poly_eq(use_label("eq", "R2")) +
  theme_bw() +
  ggtitle("FVS Projected Annual Carbon Flux by Latitude") +
  ylab(bquote("Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  xlab("Latitude (degrees)")
```

```{r projected carbon flux by latitude adjusted for elevation, eval = FALSE}
nrsgro_calb_proj_vs_meas |>
  filter(Projection_Years > 0) |>
  left_join(
    plot_location_tmp,
    by = join_by(StandID)
  ) |>
  mutate(lat_adj = lat + elev / 500) |>
  ggplot(aes(lat_adj, Projected_Carbon_Flux)) +
  geom_point() +
  stat_poly_line() +
  stat_poly_eq(use_label("eq", "R2")) +
  theme_bw() +
  ggtitle("FVS Projected Annual Carbon Flux by Latitude adjusted for Elevation") +
  ylab(bquote("Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  xlab("Adjusted Latitude (degrees)")
```

# Basal Area

## BA Sanity

Is FVS BA simiar to FIA's?

```{r is ba sane, eval = FALSE}
fia_ba <- nrsgro_plot_stats |>
  filter_add_stand_id() |>
  group_by(STAND_ID) |>
  arrange(INVYR) |>
  filter(row_number() == 1) |>
  ungroup() |>
  select(STAND_ID, MEASYEAR, BALIVE) |>
  rename(StandID = STAND_ID, Year = MEASYEAR, FIA_BA = BALIVE)

fvs_ba <- nrsgro_calb_summary |>
  group_by(StandID) |>
  arrange(Year) |>
  filter(row_number() == 1) |>
  ungroup() |>
  select(StandID, Year, BA) |>
  rename(FVS_BA = BA)

fvs_vs_fia_ba <- fia_ba |>
  left_join(fvs_ba, by = join_by(StandID, Year)) |>
  mutate(BA_PROP = FVS_BA / FIA_BA)

fvs_vs_fia_ba |>
  ggplot(aes(BA_PROP)) +
  geom_histogram(binwidth = 0.1)
```

so, not entirely.
```{r plots with wrong starting ba, eval = FALSE}
wrong_ba_stands <- fvs_vs_fia_ba |>
  filter(BA_PROP < 0.95 | BA_PROP > 1.05)
```


## BAI vs things

### BAI vs Latitude

Among those stands that have good starting ba, how does BAI trend with latitude?
```{r measured bai by latitude, eval = FALSE}
#formula <- y ~ poly(x, 2, raw = TRUE)
formula <- y ~ x

nrsgro_calb_proj_vs_meas |>
  filter(Projection_Years > 0) |>
  left_join(
    nrsgro_plot |>
      filter_add_stand_id() |>
      select(STAND_ID, LAT, LON, ELEV) |>
      rename(StandID = STAND_ID),
    by = join_by(StandID)
  ) |>
  mutate(lat_adj = LAT + ELEV / 500) |>
  ggplot(aes(LAT, Measured_BAI)) +
  geom_point(size = 0.1) +
  stat_poly_line(formula = formula, se = FALSE) +
  stat_poly_eq(use_label("eq", "R2"), formula = formula) +
  #facet_wrap("FOREST_TYPE_GROUP") +
  theme_bw() +
  ggtitle("FIA Measured BAI by Latitude") +
  ylab(bquote("BAI" ~ (m^2 %.% ha^-1 %.% yr^-1))) +
  xlab("Latitude (degrees)")
```


Among those stands that have good starting ba, how does BAI trend with latitude?
```{r projected bai by latitude, eval = FALSE}
formula <- y ~ x

nrsgro_calb_proj_vs_meas |>
  filter(Projection_Years > 0) |>
  left_join(
    nrsgro_plot |>
      filter_add_stand_id() |>
      select(STAND_ID, LAT, LON, ELEV) |>
      rename(StandID = STAND_ID),
    by = join_by(StandID)
  ) |>
  mutate(lat_adj = LAT + ELEV / 500) |>
  ggplot(aes(LAT, Projected_BAI)) +
  geom_point(size = 0.1) +
  stat_poly_line(formula = formula) +
  stat_poly_eq(use_label("eq", "R2"), formula = formula) +
  theme_bw() +
  ggtitle("FVS Projected BAI by Latitude") +
  ylab(bquote("BAI" ~ (m^2 %.% ha^-1 %.% yr^-1))) +
  xlab("Latitude (degrees)")
```


### BAI vs Starting BA

```{r bai residual vs starting ba, eval = FALSE}
ggplot(
  nrsgro_calb_proj_vs_meas |>
    filter(Projection_Years > 0) |>
    mutate(
      BA_Range = cut(Measured_BA, 0:19 * 5)
    ) |>
    group_by(FOREST_TYPE_GROUP) |>
    mutate(FOREST_TYPE_GROUP = paste0(FOREST_TYPE_GROUP, ", n=", n())) |>
    ungroup(),
  aes(x = BA_Range, y = BAI_Residual)
) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_boxplot(outlier.size = 0.1, varwidth = TRUE) +
  scale_fill_discrete(name = "Forest Type Group") +
  ggtitle("BAI Residual vs. Measured BA") +
  labs(caption = "With Calibration") +
  ylab(bquote("BAI Residual "(m^2 %.% ha^-1 %.% yr^-1))) +
  xlab(bquote("Measured Stand BA "(m^2 %.% ha^-1))) +
  theme_bw() +
  coord_cartesian(ylim = c(-2, 3))
```

```{r list measured carbon flux, eval = FALSE}
nrsgro_calb_proj_vs_meas |>
    filter(Projection_Years > 0) |>
  ggplot(aes(Measured_Carbon_Flux)) +
  geom_histogram() +
  geom_vline(xintercept = 0)
```

```{r plot projected vs measured carbon flux, eval = FALSE}
lr <- lm(
  Projected_Carbon_Flux ~ Measured_Carbon_Flux,
  data = nrsgro_calb_proj_vs_meas |> filter(Projection_Years > 0)
)
ggplot(
  nrsgro_calb_proj_vs_meas |> filter(Projection_Years > 0) |>
    mutate(Measured_Carbon_Flux = log10(Measured_Carbon_Flux),
            Projected_Carbon_Flux =  log10(Projected_Carbon_Flux)),
  aes(x = Measured_Carbon_Flux, y = Projected_Carbon_Flux)
) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_vline(xintercept = 0, linewidth = 0.25, color = "black") +
  geom_abline(intercept = 0, slope = 1, linewidth = 0.25, linetype = "dashed", color = "lightgray") +
  geom_bin2d(bins = 50) +
  scale_fill_gradient(
    name = "Number of Plots",
    # transform = "log10",
    low = "lightblue",
    high = "darkblue",
    limits = c(0, 125)
  ) +
  geom_abline(
    intercept = lr$coefficients[1],
    slope = lr$coefficients[2],
    linetype = "dashed",
    color = "darkblue"
  ) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  ggtitle(scales::label_wrap(35)("FVS Projected vs. FIA Measured AGL Carbon Flux in Grow-Only Stands")) +
  labs(caption = "With Calibration") +
  annotate(
    "text",
    x = -10,
    y = 10,
    label = paste0(
      "Slope: ", round(lr$coefficients[2], 3), "\n",
      "Intercept: ", round(lr$coefficients[1], 3), "\n",
      "R-squared: ", round(summary(lr)$r.squared, 3)
    ),
    size = 3,
    hjust = 0,
    vjust = 1
  ) +
  xlab(bquote("Measured Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  ylab(bquote("Projected Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  coord_cartesian(xlim = c(-10, 10), ylim = c(-10, 10))
```

