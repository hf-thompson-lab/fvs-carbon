---
title: "FVS Carbon Modeling Analysis"
author: "Nikolaus Bates-Haus"
output:
  html_document: default
  pdf_document: default
editor_options:
  markdown:
    wrap: 72
---

# Setup

```{r setup, include=FALSE}
library(targets)
library(tarchetypes)
library(tidyverse)
library(reshape2) # for melt()
library(RSQLite)
library(measurements)
tar_source()
```

## Load targets results from other documents

```{r load tar objects}
tar_load(fiadb)
tar_load(species_crosswalk)
tar_load(nk_plot_crosswalk)
tar_load(nk_regen)
```

# Carbon Calculation

[@Herbert2023] use FIA measurement of biomass to determine carbon. FIA
also provides above-groud carbon in the TREE table, in CARBON_AG. This
metric is, of course, not available on plots that FVS grows. For
consistent carbon calculation on both measured and grown plots, we can
use the FVS Fire and Fuels extension (FFE-FVS), which contains a Carbon
Submodel, to compute carbon. We compare FFE carbon calculation with
Jenkins and FIA carbon calculation at the end of this section.

## Stand Inventories

FIA has two notions of when a plot is inventoried:

*  Inventory year (INVYR): the nominal year for which an inventory is
   conducted. This is the "official" year, and is used to identify observations.

*  Measure Year (MEASYEAR): the actual year in which a plot was measured.
   For anything sensitive to real-world time, such as growth, this is the
   time measurement that matters. Note that MEASYEAR may be less than, equal
   to, or greater than INVYR.

The FIA PLOT table lists when plots were measured; the FIA COND table
lists observations from those measurements. We can use the above
established connection between FVS identifiers and FIA identifiers to
find subsequent measurement for the plots and conditions included in NK.

```{r matching_plot, eval = FALSE}
nk_matching_plot <- fia_plots(fiadb, nk_plot_crosswalk) |>
  filter(INVYR >= 1999)
```

### Remeasurement Timeline

To aid visual analysis, we create arbitrary ordinals for plots;
this will allow us to chart each plot in a single
horizontal band, against time, to create a visual timeline of plot
measurement.

To create these ordinals, we sort plots by:

1.  The first year measured, earliest first; then
2.  Break ties by the second year measured, earliest year first; then
3.  Break ties by the third year measured, earliest year first; then
4.  Break ties by the fourth year measured, earliest year first
5.  Assign stand number as dense rank row number.

This will put plots surveyed earlier towards the bottom of the chart,
creating an "upward and to the right" visual that is generally easy to read.

```{r stand_inventories, eval = FALSE}
year1 <- nk_matching_plot |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(YEAR1 = min(MEASYEAR), .groups = "keep") |>
  ungroup() |>
  right_join(nk_matching_plot, by=join_by(STATECD, COUNTYCD, PLOT))

year2 <- year1 |>
  filter(MEASYEAR > YEAR1) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(YEAR2 = min(MEASYEAR), .groups = "keep") |>
  ungroup() |>
  right_join(year1, by=join_by(STATECD, COUNTYCD, PLOT))
  
year3 <- year2 |>
  filter(MEASYEAR > YEAR2) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(YEAR3 = min(MEASYEAR), .groups = "keep") |>
  ungroup() |>
  right_join(year2, by=join_by(STATECD, COUNTYCD, PLOT))

year4 <- year3 |>
  filter(MEASYEAR > YEAR3) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(YEAR4 = min(MEASYEAR), .groups = "keep") |>
  ungroup() |>
  right_join(year3, by=join_by(STATECD, COUNTYCD, PLOT))

# Compute stand numbers as ordinals according to inventory years
stand_num <- year4 |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarise(
    YEAR1 = min(YEAR1),
    YEAR2 = min(YEAR2),
    YEAR3 = min(YEAR3),
    YEAR4 = min(YEAR4),
    .groups = "keep"
  ) |>
  ungroup() |>
  arrange(YEAR1, YEAR2, YEAR3, YEAR4) |>
  mutate(STAND_NUM = row_number()) |>
  select(STAND_NUM, STATECD, COUNTYCD, PLOT)

remove(year1, year2, year3, year4)

# Paste stand numbers back on to plots
stand_inventories <- nk_matching_plot |>
  left_join(stand_num, by=join_by(STATECD, COUNTYCD, PLOT)) |>
  group_by(STAND_NUM, MEASYEAR) |>
  rename(Year = MEASYEAR)

ggplot(
    data = stand_inventories,
    mapping = aes(x = Year, y = STAND_NUM)
  ) +
  geom_point()
```

### Changing Conditions

Conditions are numbered according to where they appear in
the plot for a given inventory. As such, the same physical condition 
can receive a different number in different inventories. For example,
if the condition at the center of subplot 1 changes from inventory A to inventory B, then
the characteristics of the condition numbered 1 will be different between the two inventories, even if there are
portions of the plot that still match what used to be condition 1. To
assign stand ordinals actually correctly, we would need to align
conditions by characteristics such as azimuth, forest type and stand
age. Because there are only a few plots with multiple conditions, we simplify
this analysis by omitting multi-condition plots.

```{r matching_cond, eval = FALSE}
nk_matching_cond <- fia_conds(fiadb, nk_plot_crosswalk) |>
  filter(INVYR >= 1999) |>
  # Paste MEASYEAR on to COND, because everything in FVS works off MEASYEAR
  left_join(
    nk_matching_plot |> select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR),
    by=join_by(STATECD, COUNTYCD, PLOT, INVYR)
  )

# We should have retrieved conditions for all plots
stopifnot(
  (nk_matching_plot |> distinct(STATECD, COUNTYCD, PLOT) |> nrow()) ==
    (nk_matching_cond |> distinct(STATECD, COUNTYCD, PLOT) |> nrow())
)
```

Which plots have multiple conditions?

```{r multi_flag, eval = FALSE}
# We are interested in plots that have more than one condition in any
# inventory year. Therefore we group by plot, and count the number of
# distinct conditions across all inventory years.
# This will not flag cases when a plot with a single condition changes
# condition type, e.g. when a plot is harvested.
matching_cond_multi <- nk_matching_cond |>
  mutate(MULTI_FLAG = CONDID > 1) |>
  select(STATECD, COUNTYCD, PLOT, CONDID, MEASYEAR, MULTI_FLAG)

knitr::kable(
  matching_cond_multi |>
    filter(MULTI_FLAG) |>
    arrange(STATECD, COUNTYCD, PLOT, MEASYEAR, CONDID)
)
```


Alternatively, we may not care if a plot is multi-condition so long as
all conditions are forested for the duration of the study period.

Which plots have non-forested conditions?

```{r nonforest_flag, eval = FALSE}
matching_cond_nonforest <- nk_matching_cond |>
  mutate(NONFOREST_FLAG = COND_STATUS_CD > 1) |>
  select(STATECD, COUNTYCD, PLOT, CONDID, MEASYEAR, COND_STATUS_CD, NONFOREST_FLAG)

knitr::kable(
  matching_cond_nonforest |>
    filter(NONFOREST_FLAG) |>
    arrange(STATECD, COUNTYCD, PLOT, MEASYEAR, CONDID)
)
```


### Skipped

Survey may be skipped for various reasons captured on the condition 
in COND_STATUS_CD and COND_NONSAMPLE_REASN_CD. Codes other than 1 indicate
that forest was not inventoried in the condition.

Status Code Descriptions are given in [@Burrill2024]:

-   1 Accessible forest land
-   2 Nonforest land
-   3 Noncensus water
-   4 Census water
-   5 Nonsampled, possibility of forest land

Nonsample Reason Code Descriptions are given in [@Burrill2024]:

-   01 Outside U.S. boundary
-   02 Denied access area
-   03 Hazardous situation
-   05 Lost data
-   06 Lost plot
-   07 Wrong location
-   08 Skipped visit
-   09 Dropped intensified plot
-   10 Other
-   11 Ocean

We want to remove plots that are skipped for any reason.

```{r skipped_flag, eval = FALSE}
# Were any stands not sampled during an inventory?
matching_cond_skipped <- nk_matching_cond |>
  select(STATECD, COUNTYCD, PLOT, CONDID, MEASYEAR, COND_STATUS_CD, COND_NONSAMPLE_REASN_CD) |>
  mutate(SKIPPED_FLAG = COND_STATUS_CD > 1)

knitr::kable(matching_cond_skipped |> filter(SKIPPED_FLAG))
```

Notably, all Nonforest is skipped:

```{r nonforest_is_skipped, eval = FALSE}
matching_cond_nonforest |>
  full_join(matching_cond_skipped, by = join_by(STATECD, COUNTYCD, PLOT, CONDID, MEASYEAR)) |>
  select(STATECD, COUNTYCD, PLOT, CONDID, MEASYEAR, NONFOREST_FLAG, SKIPPED_FLAG) |>
  filter(NONFOREST_FLAG | SKIPPED_FLAG)
```

### Disturbance

Three condition fields, DSTRBCD1/2/3, capture Disturbance codes. These indicate
types of disturbance to the condition other than disturbances related to
harvest.

Code Descriptions are given in [@Burrill2024]:

-   0 No visible disturbance.
-   10 Insect damage.
-   11 Insect damage to understory vegetation.
-   12 Insect damage to trees, including seedlings and saplings.
-   20 Disease damage.
-   21 Disease damage to understory vegetation.
-   22 Disease damage to trees, including seedlings and saplings.
-   30 Fire damage (from crown and ground fire, either prescribed or
    natural).
-   31 Ground fire damage.
-   32 Crown fire damage.
-   40 Animal damage.
-   41 Beaver (includes flooding caused by beaver).
-   42 Porcupine.
-   43 Deer/ungulate.
-   44 Bear (core optional).
-   45 Rabbit (core optional).
-   46 Domestic animal/livestock (includes grazing).
-   50 Weather damage.
-   51 Ice.
-   52 Wind (includes hurricane, tornado).
-   53 Flooding (weather induced).
-   54 Drought.
-   60 Vegetation (suppression, competition, vines).
-   70 Unknown / not sure / other.
-   80 Human-induced damage - any significant threshold of human-caused
    damage not described in the DISTURBANCE codes or in the TREATMENT
    codes.
-   90 Geologic disturbances.
-   91 Landslide.
-   92 Avalanche track.
-   93 Volcanic blast zone.
-   94 Other geologic event.
-   95 Earth movement / avalanches.

```{r disturbed_flag, eval = FALSE}
# Who had disturbance?
matching_cond_disturbed <- nk_matching_cond |>
  select(STATECD, COUNTYCD, PLOT, CONDID, MEASYEAR, DSTRBCD1, DSTRBCD2, DSTRBCD3) |>
  mutate(DISTURBED_FLAG = DSTRBCD1 > 0 | DSTRBCD2 > 0 | DSTRBCD3 > 0) |>
  mutate(DISTURBED_FLAG = if_else(is.na(DISTURBED_FLAG), FALSE, DISTURBED_FLAG))

knitr::kable(matching_cond_disturbed |> filter(DISTURBED_FLAG))
```

### Treatment

Harvest-related disturbance is captured in the three columns TRTCD1/2/3.
These capture treatment code describing disturbance related to harvest.

Code Descriptions are given in [@Burrill2024]:

-   00 No observable treatment.
-   10 Cutting
-   20 Site preparation
-   30 Artificial regeneration
-   40 Natural regeneration
-   50 Other silvicultural treatment

```{r treated_flag, eval = FALSE}
# Who had treatment?
matching_cond_treated <- nk_matching_cond |>
  select(STATECD, COUNTYCD, PLOT, CONDID, MEASYEAR, TRTCD1, TRTCD2, TRTCD3) |>
  mutate(TREATED_FLAG = TRTCD1 > 0 | TRTCD2 > 0 | TRTCD3 > 0) |>
  mutate(TREATED_FLAG = if_else(is.na(TREATED_FLAG), FALSE, TREATED_FLAG))

knitr::kable(matching_cond_treated |> filter(TREATED_FLAG))
```


### Timeline

We can combine mult-condition, skipped, disturbed, and harvested statuses
to create a single timeline that shows plot status since the start of NK.

Note that the various status are per condition, and we are charting per plot. To
accommodate, we introduce horizontal offset for conditions so that the status of
individual conditions within a plot is visible in the chart.

```{r stand_inventory_status, eval = FALSE}
matching_cond_status <- nk_matching_cond |>
  
  # Merge all the matching_cond_<status> tables
  left_join(
    matching_cond_multi |> select(STATECD, COUNTYCD, PLOT, CONDID, MEASYEAR, MULTI_FLAG),
    by = join_by(STATECD, COUNTYCD, PLOT, CONDID, MEASYEAR)
  ) |>
  left_join(
    matching_cond_skipped |> select(STATECD, COUNTYCD, PLOT, CONDID, MEASYEAR, SKIPPED_FLAG),
    by = join_by(STATECD, COUNTYCD, PLOT, CONDID, MEASYEAR)
  ) |>
  left_join(
    matching_cond_disturbed |> select(STATECD, COUNTYCD, PLOT, CONDID, MEASYEAR, DISTURBED_FLAG),
    by = join_by(STATECD, COUNTYCD, PLOT, CONDID, MEASYEAR)
  ) |>
  left_join(
    matching_cond_treated |> select(STATECD, COUNTYCD, PLOT, CONDID, MEASYEAR, TREATED_FLAG),
    by = join_by(STATECD, COUNTYCD, PLOT, CONDID, MEASYEAR)
  ) |>

  # Collect the various status indicators into a single STATUS column
  mutate(STATUS = NA) |>
  mutate(STATUS = if_else(MULTI_FLAG, "Multi-Condition", STATUS)) |>
  mutate(STATUS = if_else(SKIPPED_FLAG, "Skipped", STATUS)) |>
  mutate(STATUS = if_else(DISTURBED_FLAG, "Disturbed", STATUS)) |>
  mutate(STATUS = if_else(TREATED_FLAG, "Treated", STATUS)) |>
  mutate(STATUS = if_else(is.na(STATUS), "Grown", STATUS))

stand_inventory_status <- matching_cond_status |>
  
  # To facilitate visual display, nudge MEASYEAR by condition
  # max(CONDID) == 3, so nudge by 1/4 per CONDID.
  mutate(MEASYEAR = MEASYEAR + (CONDID - 1)/4) |>
  
  # Use the single STATUS column to create separate columns for each status,
  # where the measurement year is the value for the column
  mutate(GROWN = if_else(STATUS == "Grown", MEASYEAR, NA)) |>
  mutate(SKIPPED = if_else(STATUS == "Skipped", MEASYEAR, NA)) |>
  mutate(TREATED = if_else(STATUS == "Treated", MEASYEAR, NA)) |>
  mutate(DISTURBED = if_else(STATUS == "Disturbed", MEASYEAR, NA)) |>
  mutate(MULTI_COND = if_else(STATUS == "Multi-Condition", MEASYEAR, NA)) |>
  
  # Add stand numbers
  left_join(stand_num, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  select(STAND_NUM, GROWN, TREATED, DISTURBED, SKIPPED, MULTI_COND) |>

  # Melt and arrange for ggplot
  melt(id.vars = "STAND_NUM", variable.name="Status", value.name = "Year") |>
  filter(!is.na(Year)) |>
  select(STAND_NUM, Year, Status) |>
  arrange(STAND_NUM, Year, Status)

ggplot(
    data = stand_inventory_status,
    mapping = aes(x = Year, y = STAND_NUM, shape = Status, color = Status)
  ) +
  ggtitle("Stand Inventory Timeline") +
  geom_point() +
  coord_cartesian(xlim = c(1999, 2022), ylim = c(0, 31))
```

### Grow-Only Stands

[@Herbert2023] says "Where stands were coded as having ≥25% of the trees
or sample area affected by insects, disease, weather damage, or geologic
disturbances damage between inventory visits, we coded a binary,
non-fire disturbance attribute to have available as an explanatory
factor but did not drop them from the analysis set."

There are a subset of plots that are grow-only for
all subsequent inventories. We would like to compare the carbon in the
FIA inventories for the grow-only plots with the carbon projected by FVS.

We start by identifying those plots that are grow in all conditions in all years.
We need all conditions in the plot to be grow-only for all inventory years, since
FIA and FVS may diverge in their understanding of condition composition
of plots over time.

```{r stand_grow_only, eval = FALSE}
rhs <- matching_cond_status |>
  mutate(GROWN_FLAG = !SKIPPED_FLAG & !DISTURBED_FLAG & !TREATED_FLAG) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    GROWN_FLAG = all(GROWN_FLAG),
    .groups = "keep"
  ) |>
  ungroup() |>
  filter(GROWN_FLAG)

stand_grow_only <- nk_matching_plot |>
  semi_join(rhs, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  left_join(stand_num, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  left_join(nk_plot_crosswalk, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  # Add STDAGE, FORTYPE, and MEASYEAR because they'll be useful later
  left_join(
    nk_matching_cond |> 
      select(STATECD, COUNTYCD, PLOT, INVYR, FORTYPE, STDAGE, MEASYEAR),
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
  )

# rhs is just for the RHS of the semi_join
rm(rhs)
  
ggplot(
    data = semi_join(stand_inventory_status, stand_grow_only, by = join_by(STAND_NUM)),
    mapping = aes(x = Year, y = STAND_NUM, shape = Status, color = Status)
  ) +
  ggtitle("Grow-only Stand Inventory Timeline") +
  geom_point() +
  coord_cartesian(xlim = c(1999, 2022), ylim = c(0, 31))
```

We should be able to get the same plots using database filters

```{targets nk_plots_grown, tar_simple = TRUE}
fia_plots_filtered(fiadb, nk_plot_crosswalk, \(.data, con) {
  .data |>
    filter_plots_forested(con) |> # Forested implies not skipped
    filter_plots_undisturbed(con) |>
    filter_plots_untreated(con)
}) |>
  # Bring in other plot IDs
  filter(INVYR >= 1999) |>
  left_join(nk_plot_crosswalk |> select(!MEASYEAR), by = join_by(STATECD, COUNTYCD, PLOT)) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  # Find the first and last measurement year for each stand
  summarize(
    FIRST_YEAR = min(MEASYEAR, na.rm = TRUE),
    LAST_YEAR = max(MEASYEAR, na.rm = TRUE),
    STAND_CN = max(STAND_CN, na.rm = TRUE),
    STAND_ID = max(FVS_STAND_ID, na.rm = TRUE),
    .groups = "keep"
  ) |>
  ungroup()
```

```{r preview nk_plots_grown, eval=FALSE}
knitr::kable(nk_plots_grown)
```

```{r test nk_plots_grown, eval = FALSE}
stopifnot(
  nk_plots_grown |> anti_join(stand_grow_only, by = join_by(STATECD, COUNTYCD, PLOT)) |> nrow() == 0
)
stopifnot(
  stand_grow_only |> anti_join(nk_plots_grown, by = join_by(STATECD, COUNTYCD, PLOT)) |> nrow() == 0
)

```

We also want all surveys of the grown plots.
```{targets nk_plots_surveyed, tar_simple = TRUE}
fia_plots(fiadb, nk_plots_grown) |>
  filter(INVYR >= 1999) |>
  left_join(nk_plot_crosswalk |> select(!MEASYEAR), by = join_by(STATECD, COUNTYCD, PLOT)) |>
  mutate(
    STAND_CN = CN,
    STAND_ID = FVS_STAND_ID,
    FIRST_YEAR = MEASYEAR,
    LAST_YEAR = MEASYEAR
  ) |>
  select(STATECD, COUNTYCD, PLOT, FIRST_YEAR, LAST_YEAR, STAND_ID, STAND_CN)
```

## Carbon Accounting

[@fvsstaff2021] Module 2, section Audit 1, describes how to perform a
zero-year run of FVS. This applies the mapping from FIA plot to FVS
stand, then grows the stand for zero years, which keeps the trees as
they are in the FIA plot. This does however produce all the FVS output
data structures for the stand, which enables application of e.g. the
FFE carbon model. We do not apply the regeneration adjustments, since we are
simply computing carbon from the FIA inventory data. We do this for each
individual grow-only plot in each measurement year, then chart the observed
vs. predicted carbon for these plots.

Note that plots change over time, and FIA's way of dealing with this is
to change the conditions over time. FVS does not change conditions as a
plot ages; it grows trees assuming that the forest type of the plot
remains unchanged. The result is that FVS grows the conditions as
inventoried at the start of the window, whereas FIA will adjust those
conditions over time. For both projected and measured carbon, we use all
conditions in the plot as inventoried, to compare carbon projection vs.
measurement for the entire plot land area.

### Running FVS

We need two outputs from FVS to compare:

1. Projected growth for all grow-only stands between their first and last MEASYEAR.
2. Carbon calculation for each stand for each year in which it was measured.

The first is accomplished with a single run of FVS for each grow-only plot,
ending in the year of last measurement.

The second is accomplished by creating a 0-year FVS run for each plot in each
year in which it was measured.

Next, we want to run FVS for each of those plots, in each of those years.

#### FFE Projected

Generate the keywordfile for NK Plots projected carbon using FFE algorithm.

```{targets nk_ffe_none}
# format = "file" because it produces files outside targets' control
tar_target(
  nk_ffe_none,
  {
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "NKFFE"
    mgmt_id <- "NONE"

    # We communicate with FVS through files. FVSOnline shows a model in which
    # a "project" (the inputs and outputs of a single FVS run) live in a
    # single directory; we follow that model.
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }

    nk_background_regen <- nk_extract_regen(nk_regen, "Background")

    fvs_run(
      fvsbin_dir,
      fvs_variant,
      project_dir,
      fiadb,
      title,
      mgmt_id,
      nk_plots_grown,
      regen = nk_background_regen,
      carb_calc = "FFE"
    )
  },
  format = "file"
)
```

Read back the results.

```{targets nk_ffe_none_carbon, tar_simple = TRUE}
fvs_read_output(nk_ffe_none[3], "FVS_Carbon")
```

We're not using the summary yet, but define the target for it.

```{targets nk_ffe_none_summary, tar_simple = TRUE}
fvs_read_output(nk_ffe_none[3], "FVS_Summary2_East")
```

```{r fvs_stand_projected_ffe, eval=FALSE}
fvs_stand_projected_ffe <- nk_ffe_none_carbon |>
  rename(
    Aboveground_Live = Aboveground_Total_Live,
    Down_Dead = Forest_Down_Dead_Wood
  ) |>
  mutate(
    Method = "Projected",
    Algorithm = "FFE",
    Aboveground_Dead = Standing_Dead + Down_Dead,
    Aboveground_Carbon = Aboveground_Live + Aboveground_Dead
  ) |>
  select(Method, Algorithm, StandID, Year, Total_Stand_Carbon, Aboveground_Carbon,
         Aboveground_Live, Aboveground_Dead, Standing_Dead, Down_Dead)
knitr::kable(fvs_stand_projected_ffe)
```

#### FFE Surveyed

Generate the keywordfile for NK Plots measured carbon using FFE algorithm.

```{targets nk_ffe_srvy}
# format = "file" because it produces files outside targets' control
tar_target(
  nk_ffe_srvy,
  {
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "NKFFE"
    mgmt_id <- "SRVY"

    # We communicate with FVS through files. FVSOnline shows a model in which
    # a "project" (the inputs and outputs of a single FVS run) live in a
    # single directory; we follow that model.
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }

    nk_background_regen <- nk_extract_regen(nk_regen, "Background")

    fvs_run(
      fvsbin_dir,
      fvs_variant,
      project_dir,
      fiadb,
      title,
      mgmt_id,
      nk_plots_surveyed,
      regen = nk_background_regen,
      carb_calc = "FFE"
    )
  },
  format = "file"
)
```

Read back the results.

```{targets nk_ffe_srvy_carbon, tar_simple = TRUE}
fvs_read_output(nk_ffe_srvy[3], "FVS_Carbon")
```

We're not using the summary yet, but define the target for it.

```{targets nk_ffe_srvy_summary, tar_simple = TRUE}
fvs_read_output(nk_ffe_srvy[3], "FVS_Summary2_East")
```


```{r fvs_stand_measured_ffe, eval=FALSE}
fvs_stand_measured_ffe <- nk_ffe_srvy_carbon |>
  rename(Aboveground_Live = Aboveground_Total_Live) |>
  rename(Down_Dead = Forest_Down_Dead_Wood) |>
  mutate(Method = "Surveyed", Algorithm = "FFE") |>
  mutate(Aboveground_Dead = Standing_Dead + Down_Dead) |>
  mutate(Aboveground_Carbon = Aboveground_Live + Aboveground_Dead) |>
  select(Method, Algorithm, StandID, Year, Total_Stand_Carbon, Aboveground_Carbon,
         Aboveground_Live, Aboveground_Dead, Standing_Dead, Down_Dead)
knitr::kable(fvs_stand_measured_ffe)
```

#### Jenkins Projected

Generate the keywordfile for NK Plots projected carbon using Jenkins algorithm.
```{targets nk_jenkins_none}
# format = "file" because it produces files outside targets' control
tar_target(
  nk_jenkins_none,
  {
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "NKJenkins"
    mgmt_id <- "NONE"

    # We communicate with FVS through files. FVSOnline shows a model in which
    # a "project" (the inputs and outputs of a single FVS run) live in a
    # single directory; we follow that model.
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }

    nk_background_regen <- nk_extract_regen(nk_regen, "Background")

    fvs_run(
      fvsbin_dir,
      fvs_variant,
      project_dir,
      fiadb,
      title,
      mgmt_id,
      nk_plots_grown,
      regen = nk_background_regen,
      carb_calc = "Jenkins"
    )
  },
  format = "file"
)
```

Read back the results.

```{targets nk_jenkins_none_carbon, tar_simple = TRUE}
fvs_read_output(nk_jenkins_none[3], "FVS_Carbon")
```

We're not using the summary yet, but define the target for it.

```{targets nk_jenkins_none_summary, tar_simple = TRUE}
fvs_read_output(nk_jenkins_none[3], "FVS_Summary2_East")
```

```{r fvs_stand_projected_jenkins, eval = FALSE}
fvs_stand_projected_jenkins <- nk_jenkins_none_carbon |>
  rename(Aboveground_Live = Aboveground_Total_Live) |>
  rename(Down_Dead = Forest_Down_Dead_Wood) |>
  mutate(Method = "Projected", Algorithm = "Jenkins") |>
  mutate(Aboveground_Dead = Standing_Dead + Down_Dead) |>
  mutate(Aboveground_Carbon = Aboveground_Live + Aboveground_Dead) |>
  select(Method, Algorithm, StandID, Year, Total_Stand_Carbon, Aboveground_Carbon,
         Aboveground_Live, Aboveground_Dead, Standing_Dead, Down_Dead)
knitr::kable(fvs_stand_projected_jenkins)
```

#### Jenkins Surveyed

Generate the keywordfile for NK Plots measured carbon using FFE algorithm.

```{targets nk_jenkins_srvy}
# format = "file" because it produces files outside targets' control
tar_target(
  nk_jenkins_srvy,
  {
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "NKJenkins"
    mgmt_id <- "SRVY"

    # We communicate with FVS through files. FVSOnline shows a model in which
    # a "project" (the inputs and outputs of a single FVS run) live in a
    # single directory; we follow that model.
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }

    nk_background_regen <- nk_extract_regen(nk_regen, "Background")

    fvs_run(
      fvsbin_dir,
      fvs_variant,
      project_dir,
      fiadb,
      title,
      mgmt_id,
      nk_plots_surveyed,
      regen = nk_background_regen,
      carb_calc = "Jenkins"
    )
  },
  format = "file"
)
```

Read back the results.

```{targets nk_jenkins_srvy_carbon, tar_simple = TRUE}
fvs_read_output(nk_jenkins_srvy[3], "FVS_Carbon")
```

We're not using the summary yet, but define the target for it.

```{targets nk_jenkins_srvy_summary, tar_simple = TRUE}
fvs_read_output(nk_jenkins_srvy[3], "FVS_Summary2_East")
```

```{r fvs_stand_measured_jenkins, eval = FALSE}
fvs_stand_measured_jenkins <- nk_jenkins_srvy_carbon |>
  rename(Aboveground_Live = Aboveground_Total_Live) |>
  rename(Down_Dead = Forest_Down_Dead_Wood) |>
  mutate(Method = "Surveyed", Algorithm = "Jenkins") |>
  mutate(Aboveground_Dead = Standing_Dead + Down_Dead) |>
  mutate(Aboveground_Carbon = Aboveground_Live + Aboveground_Dead) |>
  select(Method, Algorithm, StandID, Year, Total_Stand_Carbon, Aboveground_Carbon,
         Aboveground_Live, Aboveground_Dead, Standing_Dead, Down_Dead)
knitr::kable(fvs_stand_measured_jenkins)
```

### FFE-FFE

FFE-FVS is the Fire and Fuels extension for FVS. It provides two methods of
computing carbon: FFE and Jenkins. The default is FFE; we start by comparing
FFE Carbon for measured vs. projected stands.

This gives us a plot of measured carbon over time.

```{r FFE Measured, eval = FALSE}
ggplot(
    data = fvs_stand_measured_ffe,
    mapping = aes(x = Year, y = Aboveground_Live, color = StandID)
  ) +
  geom_line() +
  theme_bw() +
  ylab(bquote("Carbon " ~(`Mg C` %.% ha^{-1}))) +
  coord_cartesian(xlim = c(2000, 2025), ylim = c(0, 200)) +
  ggtitle("NK Grow-Only Stands Measured Carbon (FFE)")
```

We then run FVS on all grow-only stands from the start year with a one-year timestep to
get projected FFE carbon.

```{r FFE Projected, eval = FALSE}
ggplot(
    data = fvs_stand_projected_ffe,
    mapping = aes(x = Year, y = Aboveground_Live, color = StandID)
  ) +
  geom_line() +
  theme_bw() +
  coord_cartesian(xlim = c(2000, 2025), ylim = c(0, 200)) +
  ylab(bquote("Carbon " ~(`Mg C` %.% ha^{-1}))) +
  ggtitle("NK Grow-Only Stands Projected Carbon (FFE)")
```

We can then plot the measured vs. projected carbon.

```{r ffe_projected_vs_measured, eval = FALSE}
compare_ffe <- fvs_stand_measured_ffe |>
  union_all(fvs_stand_projected_ffe)

ggplot(
    data = compare_ffe
  ) +
  geom_line(
    mapping = aes(x = Year, y = Aboveground_Live, color = StandID, linetype = Method)
  ) +
  ylab(bquote("Carbon " ~(`Mg C` %.% ha^{-1}))) +
  theme_bw() +
  coord_cartesian(xlim = c(2000, 2025), ylim = c(0, 200)) +
  ggtitle("NK Grow-Only Stands Measured vs. Projected Carbon (FFE)")
```

Scatterplot comparing just the last year

```{r ffe_scatterplot, eval = FALSE}
left <- fvs_stand_measured_ffe |>
  select(StandID, Year, Aboveground_Live) |>
  group_by(StandID) |>
  filter(Year == max(Year)) |>
  ungroup() |>
  rename(Measured = Aboveground_Live)

right <- fvs_stand_projected_ffe |>
  select(StandID, Year, Aboveground_Live) |>
  group_by(StandID) |>
  filter(Year == max(Year)) |>
  ungroup() |>
  rename(Projected = Aboveground_Live)

compare_ffe <- left |> left_join(right, by = join_by(StandID, Year))

ggplot(data = compare_ffe) +
  geom_point(
    size = 2,
    mapping = aes(x = Measured, y = Projected)
  ) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  xlab(bquote("Measured Carbon " ~(`Mg C` %.% ha^{-1}))) +
  ylab(bquote("Projected Carbon " ~(`Mg C` %.% ha^{-1}))) +
  ggtitle("NK Grow-Only Stands Measured vs. Projected Carbon (FFE)") +
  coord_cartesian(xlim = c(0, 200), ylim = c(0, 200)) +
  geom_abline(intercept = 0, slope = 1, color = 'red')
```


### Jenkins-Jenkins

The second method of computing carbon provided by FFE-FVS is Jenkins. Compare
measured vs. projected carbon using FFE Jenkins.

To gather measured carbon using the Jenkins method, we must re-run FVS,
adding the Jenkins keyword for the fire and fuels extension.

For measured carbon, we re-run all the plots during the years they are measured.

```{r jenkins_projected_vs_measured, eval = FALSE}
compare_jenkins <- fvs_stand_measured_jenkins |>
  union_all(fvs_stand_projected_jenkins)

ggplot(
    data = compare_jenkins
  ) +
  geom_line(
    mapping = aes(x = Year, y = Aboveground_Live, color = StandID, linetype = Method)
  ) +
  theme_bw() +
  ylab(bquote("Carbon " ~(`Mg C` %.% ha^{-1}))) +
  coord_cartesian(xlim = c(2000, 2025), ylim = c(0, 200)) +
  ggtitle("NK Grow-Only Stands Measured vs. Projected Carbon (Jenkins)")
```

Scatterplot comparing just the last year

```{r jenkins_scatterplot, eval = FALSE}
left <- fvs_stand_measured_jenkins |>
  select(StandID, Year, Aboveground_Live) |>
  group_by(StandID) |>
  filter(Year == max(Year)) |>
  ungroup() |>
  rename(Measured = Aboveground_Live)

right <- fvs_stand_projected_jenkins |>
  select(StandID, Year, Aboveground_Live) |>
  group_by(StandID) |>
  filter(Year == max(Year)) |>
  ungroup() |>
  rename(Projected = Aboveground_Live)

compare_jenkins <- left |> left_join(right, by = join_by(StandID, Year))

ggplot(data = compare_jenkins) +
  geom_point(
    size = 2,
    mapping = aes(x = Measured, y = Projected)
  ) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  xlab(bquote("Measured Carbon " ~(`Mg C` %.% ha^{-1}))) +
  ylab(bquote("Projected Carbon " ~(`Mg C` %.% ha^{-1}))) +
  ggtitle("NK Grow-Only Stands Measured vs. Projected Carbon (Jenkins)") +
  coord_cartesian(xlim = c(0, 200), ylim = c(0, 200)) +
  geom_abline(intercept = 0, slope = 1, color = 'red')
```

### FFE-Jenkins
We can get a good assessment of how FFE and Jenkins calculations compare
just by comparing measured FFE and Jenkins computed carbon.

```{r compare_ffe_jenkins, eval = FALSE}
stand_descr <- nk_matching_cond |>
  select(PLT_CN, STDAGE, FORTYPE) |>
  full_join(nk_plot_crosswalk, by = join_by(PLT_CN == STAND_CN))

compare_ffe_jenkins <- fvs_stand_measured_ffe |>
  left_join(stand_descr, by = join_by(StandID == FVS_STAND_ID)) |>
  rename(FFE = Aboveground_Live) |>
  rename(`Forest Type` = FORTYPE) |>
  rename(`Stand Age` = STDAGE) |>
  select(StandID, Year, FFE, `Stand Age`, `Forest Type`) |>
  full_join(fvs_stand_measured_jenkins, by = join_by(StandID, Year)) |>
  rename(Jenkins = Aboveground_Live) |>
  #left_join(stand_first_last, by = join_by(StandID == FVS_STAND_ID)) |>
  select(StandID, Year, FFE, Jenkins, `Stand Age`, `Forest Type`) |>
  group_by(StandID) |>
  filter(Year == max(Year))

ggplot(
    data = compare_ffe_jenkins
  ) +
  geom_point(
    size = 2,
    mapping = aes(x = FFE, y = Jenkins, color = Year, shape = `Forest Type`)
  ) +
  ggtitle("FFE vs. Jenkins Carbon Calculation") +
  coord_cartesian(xlim = c(0, 200), ylim = c(0, 200)) +
  geom_abline(intercept = 0, slope = 1) +
  theme(aspect.ratio = 1) +
  theme_bw() +
  xlab(bquote("FFE Carbon " ~(`Mg C` %.% ha^{-1}))) +
  ylab(bquote("Jenkins Carbon " ~(`Mg C` %.% ha^{-1}))) 
```

From this, it appears the Jenkins over-projects compared to FFE.

Same plot, but colored by stand age:

```{r compare_ffe_jenkins_stdage, eval = FALSE}
ggplot(
    data = compare_ffe_jenkins
  ) +
  geom_point(
    size = 2,
    mapping = aes(x = FFE, y = Jenkins, color = `Stand Age`, shape = `Forest Type`)
  ) +
  coord_cartesian(xlim = c(0, 200), ylim = c(0, 200)) +
  geom_abline(intercept = 0, slope = 1) +
  theme(aspect.ratio = 1) +
  theme_bw() +
  ggtitle("FFE vs. Jenkins Carbon Calculation") +
  xlab(bquote("FFE Carbon " ~(`Mg C` %.% ha^{-1}))) +
  ylab(bquote("Jenkins Carbon " ~(`Mg C` %.% ha^{-1}))) 

```

### FIA Spatial

FIA has carbon in the tree table, in CARBON_AG; we can sum this per
stand and compute a per-hectare value.

Method:

-   Determine how much of each plot we will use the inventory

    -  Remove plots, subplots, and conditions that are not inventoried
       forest
       
    -  We are only including plots that are fully forested, with forested
       conditions, so this is not relevant here.

-   Determine scale factor for each plot

    -  A full plot is 4 subplots
       of 24\^2\*pi square feet each; scale this according to how much
       we're using

-   scale the carbon in each tree for the area we're using to get carbon
    per acre

-   sum across all trees

Fetch all the trees for the grow-only plots:

```{r matching_tree, eval = FALSE}
fia = DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
fia_tree = tbl(fia, 'TREE')

# Create a dataframe containing the TREE rows for the last inventory of
# all conditions for all subplots for all plots used in NK.
matching_tree <- fia_tree |>
  semi_join(
    stand_grow_only,
    # Fetch all conditions, all subplots
    by = join_by(STATECD, COUNTYCD, PLOT),
    copy = TRUE
  ) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == max(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  # Only live trees
  filter(STATUSCD == 1) |>
  collect()

DBI::dbDisconnect(fia)

remove(fia, fia_tree)
```

For each tree, convert its carbon to carbon per acre, then to carbon per hectare.
To convert CARBON_AG, which is pounds, to carbon per acre, we observe that a
plot is 1/6 acre; replicating the plot 6 times gets us a full acre, so we
multiply the carbon in each tree by 6 to get lbs/acre of carbon.

```{r stand_measured_spatial, eval = FALSE}
stand_measured_spatial <- matching_tree |>
  select(STATECD, COUNTYCD, PLOT, SUBP, CONDID, TREE, INVYR, CARBON_AG) |>
  mutate(CARBON_PER_ACRE = 6 * CARBON_AG) |>
  mutate(CARBON_METRIC = conv_multiunit(CARBON_PER_ACRE, "lbs / acre", "Mg / hectare")) |>
  group_by(STATECD, COUNTYCD, PLOT, INVYR) |>
  summarize(CARBON_METRIC = sum(CARBON_METRIC), .groups = "keep") |>
  ungroup() |>
  # Join to get STAND_IDs
  left_join(
    stand_id_crosswalk,
    by = join_by(STATECD, COUNTYCD, PLOT)
  ) |>
  # Join to get MEASYEAR, FORTYPE, and STDAGE
  left_join(
    matching_plot |> select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR),
    by=join_by(STATECD, COUNTYCD, PLOT, INVYR)
  )

knitr::kable(stand_measured_spatial)
```

```{r compare_ffe_spatial, eval = FALSE}
compare_ffe_spatial <- fvs_stand_measured_ffe |>
  group_by(StandID) |> filter(Year == max(Year)) |> ungroup() |>
  left_join(stand_descr, by = join_by(StandID == FVS_STAND_ID)) |>
  rename(FFE = Aboveground_Live) |>
  rename(`Forest Type` = FORTYPE) |>
  rename(`Stand Age` = STDAGE) |>
  select(StandID, Year, FFE, `Forest Type`, `Stand Age`) |>
  left_join(stand_id_crosswalk, by = join_by(StandID == FVS_STAND_ID)) |>
  left_join(stand_measured_spatial, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  mutate(FIA = CARBON_METRIC) |>
  select(StandID, Year, FFE, FIA, `Stand Age`, `Forest Type`)

ggplot(
    data = compare_ffe_spatial
  ) +
  geom_point(
    size = 2,
    mapping = aes(x = FFE, y = FIA, color = Year, shape = `Forest Type`)
  ) +
  coord_cartesian(xlim = c(0, 200), ylim = c(0, 200)) +
  geom_abline(intercept = 0, slope = 1) +
  ggtitle("FFE vs. FIA Spatial Carbon Calculation") +
  xlab(bquote("FFE Carbon " ~(Mg %*% ha^{-1}))) +
  ylab(bquote("FIA Carbon " ~(Mg %*% ha^{-1}))) 
```

Same, but colored by stand age

```{r compare_ffe_spatial_stdage, eval = FALSE}
ggplot(
    data = compare_ffe_spatial
  ) +
  geom_point(
    size = 2,
    mapping = aes(x = FFE, y = FIA, color = `Stand Age`, shape = `Forest Type`)
  ) +
  coord_cartesian(xlim = c(0, 200), ylim = c(0, 200)) +
  geom_abline(intercept = 0, slope = 1) +
  ggtitle("FFE vs. FIA Spatial Carbon Calculation") +
  xlab(bquote("FFE Carbon " ~(Mg %*% ha^{-1}))) +
  ylab(bquote("FIA Carbon " ~(Mg %*% ha^{-1}))) 
```

### FIA TPA

FIA provides TREE.TPA_UNADJ which is the expansion factor to use for an individual
tree to get its carbon per acre contribution. CARBON_AG is pounds per tree,
so CARBON_AG * TPA_UNADJ is pounds per acre.

We have filtered to fully forested plots with a single condition, so the method
does not need to accommodate partially forested plots, or varying conditions.

Method:

- For each tree, compute CARBON_AG * TPA_UNADJ, then convert to Mg/ha.

- Sum for all trees in the plot


```{r stand_measured_tpa, eval = FALSE}
stand_measured_tpa <- matching_tree |>
  select(STATECD, COUNTYCD, PLOT, SUBP, CONDID, TREE, INVYR, CARBON_AG, TPA_UNADJ) |>
  mutate(CARBON_PER_ACRE = CARBON_AG * TPA_UNADJ) |>
  mutate(CARBON_METRIC = conv_multiunit(CARBON_PER_ACRE, "lbs / acre", "Mg / hectare")) |>
  group_by(STATECD, COUNTYCD, PLOT, INVYR) |>
  summarize(CARBON_METRIC = sum(CARBON_METRIC), .groups = "keep") |>
  ungroup() |>
  # Join to get STAND_IDs
  left_join(
    stand_id_crosswalk,
    by = join_by(STATECD, COUNTYCD, PLOT)
  ) |>
  # Join to get MEASYEAR, FORTYPE, and STDAGE
  left_join(
    matching_plot |> select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR),
    by=join_by(STATECD, COUNTYCD, PLOT, INVYR)
  )

knitr::kable(stand_measured_tpa)
```


```{r compare_ffe_tpa, eval = FALSE}
compare_ffe_tpa <- fvs_stand_measured_ffe |>
  group_by(StandID) |> filter(Year == max(Year)) |> ungroup() |>
  left_join(stand_descr, by = join_by(StandID == FVS_STAND_ID)) |>
  mutate(FFE = Aboveground_Live) |>
  rename(`Forest Type` = FORTYPE) |>
  rename(`Stand Age` = STDAGE) |>
  select(StandID, Year, FFE, `Stand Age`, `Forest Type`) |>
  left_join(stand_id_crosswalk, by = join_by(StandID == FVS_STAND_ID)) |>
  full_join(stand_measured_tpa, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  mutate(FIA = CARBON_METRIC) |>
  select(StandID, Year, FFE, FIA, `Stand Age`, `Forest Type`)

ggplot(
    data = compare_ffe_tpa
  ) +
  geom_point(
    size = 2,
    mapping = aes(x = FFE, y = FIA, color = Year, shape = `Forest Type`)
  ) +
  coord_cartesian(xlim = c(0, 200), ylim = c(0, 200)) +
  geom_abline(intercept = 0, slope = 1) +
  ggtitle("FFE vs. FIA TPA Carbon Calculation") +
  xlab(bquote("FFE Carbon " ~(Mg %*% ha^{-1}))) +
  ylab(bquote("FIA Carbon " ~(Mg %*% ha^{-1}))) 
```

Same, but color by stand age

```{r compare_ffe_tpa_stdage, eval = FALSE}
ggplot(
    data = compare_ffe_tpa
  ) +
  geom_point(
    size = 2,
    mapping = aes(x = FFE, y = FIA, color = `Stand Age`, shape = `Forest Type`)
  ) +
  coord_cartesian(xlim = c(0, 200), ylim = c(0, 200)) +
  geom_abline(intercept = 0, slope = 1) +
  ggtitle("FFE vs. FIA TPA Carbon Calculation") +
  xlab(bquote("FFE Carbon " ~(Mg %*% ha^{-1}))) +
  ylab(bquote("FIA Carbon " ~(Mg %*% ha^{-1}))) 
```

These look very similar to the spatial approach; plot them against each other
to directly compare spatial vs. tpa

```{r compare_tpa_spatial, eval = FALSE}
compare_tpa_spatial <- stand_measured_spatial |>
  select(STATECD, COUNTYCD, PLOT, CARBON_METRIC) |>
  rename(Spatial = CARBON_METRIC) |>
  left_join(stand_measured_tpa, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  select(STATECD, COUNTYCD, PLOT, MEASYEAR, Spatial, CARBON_METRIC) |>
  rename(TPA = CARBON_METRIC) |>
  left_join(stand_descr, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  select(PLT_CN, MEASYEAR, Spatial, TPA, STDAGE, FORTYPE) |>
  rename(StandID = PLT_CN) |>
  rename(Year = MEASYEAR) |>
  rename(`Forest Type` = FORTYPE) |>
  rename(`Stand Age` = STDAGE)

ggplot(
    data = compare_tpa_spatial
  ) +
  geom_point(
    size = 2,
    mapping = aes(x = Spatial, y = TPA, color = Year, shape = `Forest Type`)
  ) +
  coord_cartesian(xlim = c(0, 200), ylim = c(0, 200)) +
  geom_abline(intercept = 0, slope = 1) +
  ggtitle("Spatial vs. TPA Carbon Calculation") +
  xlab(bquote("Spatial Carbon " ~(Mg %*% ha^{-1}))) +
  ylab(bquote("TPA Carbon " ~(Mg %*% ha^{-1}))) 
```

Same, but color by stand age

```{r plot_tpa_vs_spatial, eval = FALSE}
ggplot(
    data = compare_tpa_spatial
  ) +
  geom_point(
    size = 2,
    mapping = aes(x = Spatial, y = TPA, color = `Stand Age`, shape = `Forest Type`)
  ) +
  coord_cartesian(xlim = c(0, 200), ylim = c(0, 200)) +
  geom_abline(intercept = 0, slope = 1) +
  ggtitle("Spatial vs. TPA Carbon Calculation") +
  xlab(bquote("Spatial Carbon " ~(Mg %*% ha^{-1}))) +
  ylab(bquote("TPA Carbon " ~(Mg %*% ha^{-1}))) 
```

## Basal Area

From this, we can see that FVS FFE over-projects carbon storage, and FVS Jenkins
over-projects even more. We can compare the measured vs. projected basal area
to get some idea whether the over-projection is part of the growth model or
a characteristic of the carbon calculation.

### Measured Basal Area

FIA provides basal area in COND.BALIVE, which is, per the FIADB User Guide:

> Basal area per acre of live trees.
> Basal area in square feet per acre of all live trees ω1.0
> inch d.b.h./d.r.c. sampled in the condition. Populated for forest conditions.

```{r stand_measured_ba_fia, eval = FALSE}
stand_measured_ba_fia <- matching_cond |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(MEASYEAR == max(MEASYEAR)) |>
  # Sum BA across conditions, proportional to each conditions portion of the
  # plot (CONDPROP_UNADJ)
  summarize(BALIVE = sum(BALIVE * CONDPROP_UNADJ), .groups = 'keep') |>
  ungroup() |>
  semi_join(stand_grow_only, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  select(STATECD, COUNTYCD, PLOT, BALIVE) |>
  # BALIVE is square feet per acre; convert to square meters per hectare
  mutate(BA_FIA = conv_multiunit(BALIVE, "ft2 / acre", "m2 / hectare")) |>
  left_join(stand_id_crosswalk, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  select(PLT_CN, BA_FIA)

knitr::kable(stand_measured_ba_fia)
```

FVS provides basal area in FVS_Summary2_East.BA, which is, per Essential FVS
section 4.3.1.4.1:

> basal area per acre after thinning

which we presume to be square feet per acre for standing live trees only.

```{r stand_measured_ba_fvs, eval = FALSE}
stand_measured_ba_fvs <- FVS_Summary2_East |>
  filter(Method == 'Measured' & Algorithm == 'FFE') |>
  group_by(StandID) |>
  filter(Year == max(Year)) |>
  ungroup() |>
  mutate(BA_FVS = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  select(StandID, Year, BA, BA_FVS) |>
  left_join(stand_descr, by = join_by(StandID == FVS_STAND_ID)) |>
  rename(`Forest Type` = FORTYPE) |>
  rename(`Stand Age` = STDAGE) |>
  select(StandID, Year, BA_FVS, `Stand Age`, `Forest Type`) |>
  left_join(stand_id_crosswalk, by = join_by(StandID == FVS_STAND_ID)) |>
  select(PLT_CN, BA_FVS, Year, `Forest Type`, `Stand Age`)

knitr::kable(stand_measured_ba_fvs)
```

```{r compare_ba_fia_fvs, eval = FALSE}
compare_ba_fia_fvs <- stand_measured_ba_fia |>
  left_join(stand_measured_ba_fvs, by = join_by(PLT_CN))

ggplot(
    data = compare_ba_fia_fvs
  ) +
  geom_point(
    size = 2,
    mapping = aes(x = BA_FIA, y = BA_FVS, color = `Stand Age`, shape = `Forest Type`)
  ) +
  ggtitle("Measured Basal Area\nFIA BALIVE vs. FVS BA (m2 / ha)") +
  coord_cartesian(xlim = c(0, 60), ylim = c(0, 60)) +
  geom_abline(intercept = 0, slope = 1) +
  ggtitle("FIA vs. FVS Measured BA") +
  xlab(bquote("FIA BA " ~(m^2 %*% ha^{-1}))) +
  ylab(bquote("FVS BA " ~(M^2 %*% ha^{-1}))) 
```

This shows that FVS and FIA approach to measuring basal area often aligns, but
there are cases when they do not align.

### Projected Basal Area

FVS also projects basal area, and we can compare FVS projected with FVS measured.
This will give us insight just into the growth model of FVS independent of
carbon calculation.

```{r compare_ba_meas_proj, eval = FALSE}
tmp <- FVS_Summary2_East |>
  filter(Algorithm == 'FFE') |>
  group_by(StandID, Method) |>
  filter(Year == max(Year)) |>
  ungroup() |>
  mutate(BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  select(Method, StandID, Year, BA, BA)

measured <- tmp |>
  filter(Method == 'Measured') |>
  rename(Measured = BA)

projected <- tmp |>
  filter(Method == 'Projected') |>
  rename(Projected = BA)

compare_ba_meas_proj <- measured |>
  left_join(projected, by = join_by(StandID, Year)) |>
  left_join(stand_descr, by = join_by(StandID == FVS_STAND_ID)) |>
  rename(`Forest Type` = FORTYPE) |>
  rename(`Stand Age` = STDAGE) |>
  select(StandID, Year, Measured, Projected, `Stand Age`, `Forest Type`)

knitr::kable(compare_ba_meas_proj)
```

```{r plot_measured_vs_projected_ba, eval = FALSE}
ggplot(
    data = compare_ba_meas_proj
  ) +
  geom_point(
    size = 2,
    mapping = aes(x = Measured, y = Projected, color = `Stand Age`, shape = `Forest Type`)
  ) +
  coord_cartesian(xlim = c(0, 60), ylim = c(0, 60)) +
  geom_abline(intercept = 0, slope = 1) +
  ggtitle("FVS Measured vs. Projected BA") +
  xlab(bquote("Measured BA " ~(m^2 %*% ha^{-1}))) +
  ylab(bquote("Projected BA " ~(m^2 %*% ha^{-1}))) 
```

