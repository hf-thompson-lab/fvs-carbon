---
title: "Nunery Keeton Revisited"
author: "Nikolaus Bates-Haus"
output:
  pdf_document: default
  html_document: default
editor_options:
  markdown:
    wrap: 72
---

```{r setup, include=FALSE}
# Pre-load libraries that issue warnings on startup so these
# warnings don't corrupt the text later.
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(reshape2)) # for melt()
suppressPackageStartupMessages(library(RSQLite))
suppressPackageStartupMessages(library(htmltools))
suppressPackageStartupMessages(library(rmarkdown))
suppressPackageStartupMessages(library(dbplyr))
suppressPackageStartupMessages(library(measurements))
suppressPackageStartupMessages(library(maps))
```

## Grow-Only Plots in the Northeast

Find all FIA plots in the northeastern region that are grow-only, that have
a measurement year between 1999 and 2004, and have at least two measurements
between 1999 and 2024. We select 1999 becasue FIA changed
to the 4-subplot structure in 1999; we select 2004 so that we will have
at least 20 years of growth. We require two measurements so that we can compare
projected vs. actual growth between measurements.

Survey filters:

*  PLOT.MEASYEAR > 1999
*  min(PLOT.MEASYEAR) <= 2004
*  min(PLOT.INVYR) != max(PLOT.INVYR)

Northeastern region:

*  SURVEY.RSCD == 24

Grow-only is described previously:

*  Only one condition: max(FIA.COND.CONDID) == 1
*  Survey was not skipped: COND.COND_STATUS_CD == 1
*  Plot was not disturbed: COND.DSTRBCD1 == 0 & COND.DSTRBCD2 == 0 & COND.DSTRBCD3 == 0
*  Plot was not treated: COND.TRTCD1 == 0 & TRTCD2 == 0 & TRTCD3 == 0

Functions for these filters
```{r}
northeastern_plots_filter <- function(.data) {
  # Region or Station code (RSCD) consolidated multiple regions
  # into region 24, Northeastern Research Station (NERS).
  .data |> filter(RSCD == 24)
}

modern_plots_filter <- function(.data) {
  # The 4-sublpot structure was introduced for INVYR 1999
  # Filter out individual inventories prior to 1999
  .data |> filter(INVYR >= 1999)
}

longstanding_plots_filter <- function(.data) {
  # Plots that were measured prior to 2005
  # Filter out the entire plot if it was not surveyed prior to 2004
  .data |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    filter(min(MEASYEAR, na.rm = TRUE) <= 2004) |>
    ungroup()
}

multiple_inventory_plots_filter <- function(.data) {
  # Filter out the entire plot if it only had a single inventory
  .data |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    filter(min(INVYR, na.rm = TRUE) != max(INVYR, na.rm = TRUE)) |>
    ungroup()
}

forested_plots_filter <- function(.data) {
  # Condition status is forested
  # Filter out the entire plot if it was not forested for the entire period
  .data |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    filter(max(COND_STATUS_CD, na.rm = TRUE) == 1) |>
    ungroup()
}

undisturbed_plots_filter <- function(.data) {
  # Filter out the entire plot if it was disturbed in any year
  .data |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    filter(
      (is.na(max(DSTRBCD1, na.rm = TRUE)) | max(DSTRBCD1, na.rm = TRUE) == 0) & 
      (is.na(max(DSTRBCD2, na.rm = TRUE)) | max(DSTRBCD2, na.rm = TRUE) == 0) &
      (is.na(max(DSTRBCD3, na.rm = TRUE)) | max(DSTRBCD3, na.rm = TRUE) == 0)
    ) |>
    ungroup()
}

untreated_plots_filter <- function(.data) {
  # Filter out the entire plot if it was treated in any year
  .data |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    filter(
      (is.na(max(TRTCD1, na.rm = TRUE)) | max(TRTCD1, na.rm = TRUE) == 0) &
      (is.na(max(TRTCD2, na.rm = TRUE)) | max(TRTCD2, na.rm = TRUE) == 0) &
      (is.na(max(TRTCD3, na.rm = TRUE)) | max(TRTCD3, na.rm = TRUE) == 0)
    ) |>
    ungroup()
}

single_condition_plots_filter <- function(.data) {
  # Filter out the entire plot if it ever had more than one condition
  .data |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    filter(max(CONDID, na.rm = TRUE) == 1) |>
    ungroup()
}
```

Execute the filters to create a list of matching plots.

```{r}
fia <- DBI::dbConnect(RSQLite::SQLite(), '../00_rawData/SQLite_FIADB_ENTIRE.db')
fia_cond <- tbl(fia, 'COND') |>
  select(
    STATECD, COUNTYCD, PLOT, PLT_CN, CONDID, INVYR,
    COND_STATUS_CD, DSTRBCD1, DSTRBCD2, DSTRBCD3, TRTCD1, TRTCD2, TRTCD3
  )
fia_plot <- tbl(fia, 'PLOT') |>
  # Narrow and rename columns to facilitate join
  select(CN, SRV_CN, MEASYEAR) |>
  rename(PLT_CN = CN)
fia_survey <- tbl(fia, 'SURVEY') |>
  # Narrow and rename columns to facilitate join
  select(CN, RSCD) |>
  rename(SRV_CN = CN)

plot_grow_only <- fia_cond |>
  left_join(fia_plot, by = join_by(PLT_CN)) |>
  left_join(fia_survey, by = join_by(SRV_CN)) |>
  northeastern_plots_filter() |>
  modern_plots_filter() |>
  longstanding_plots_filter() |>
  multiple_inventory_plots_filter() |>
  forested_plots_filter() |>
  undisturbed_plots_filter() |>
  untreated_plots_filter() |>
  single_condition_plots_filter() |>
  distinct(STATECD, COUNTYCD, PLOT) |>
  collect()

dbDisconnect(fia)
remove(fia, fia_cond, fia_plot, fia_survey)

length(plot_grow_only$PLOT)
```

This filters to 2008 plots.
 
### Locations

Where are these plots?

Fetch plots with measyear, invyr, latitude, longitude, and state information.

```{r}
fia <- DBI::dbConnect(RSQLite::SQLite(), '../00_rawData/SQLite_FIADB_ENTIRE.db')

# Survey has the research station code
fia_survey <- tbl(fia, 'SURVEY') |>
  select(CN, RSCD) |>
  rename(SRV_CN = CN)

# plot has invyr, measyr, lat and lon
fia_plot <- tbl(fia, 'PLOT') |>
  # Narrow and rename columns to facilitate join
  select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR, SRV_CN, LAT, LON)

# research station has state name and abbreviation
fia_ref_research_station <- tbl(fia, 'REF_RESEARCH_STATION') |>
  select(STATECD, STATE_NAME, STATE_ABBR)

plot_location <- fia_plot |>
  semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
  left_join(fia_survey, by = join_by(SRV_CN)) |>
  left_join(fia_ref_research_station, by = join_by(STATECD)) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  # Pick just the first inventory year
  filter(min_rank(INVYR) == 1) |> 
  ungroup() |>
  collect() |>
  rename(
    long = LON,
    lat = LAT
  ) |>
  mutate(group = sprintf('%02d%03d%05d', STATECD, COUNTYCD, PLOT))

dbDisconnect(fia)
remove(fia, fia_plot, fia_survey, fia_ref_research_station)
```

How many plots are in each state?

```{r}
state_plot_counts <- plot_location |>
  group_by(STATE_NAME) |>
  summarize(COUNT = n()) |>
  ungroup() |>
  arrange(desc(COUNT))
knitr::kable(state_plot_counts)
```

Show the plots on a map.

```{r}
northeastern_states <- plot_location |>
  distinct(STATE_NAME) |>
  mutate(region = str_to_lower(STATE_NAME))
map_states <- map_data('state', northeastern_states$region)

ggplot(map_states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(data = plot_location, color = alpha("blue", alpha = 0.5)) +
  coord_quickmap()
```

### FIA Carbon and BALIVE

We can gather BALIVE and CARBON_AG for these plots over time.

```{r}
fia <- DBI::dbConnect(RSQLite::SQLite(), '../00_rawData/SQLite_FIADB_ENTIRE.db')

measyear <- tbl(fia, 'PLOT') |>
  select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR)

forest_type <- tbl(fia, 'REF_FOREST_TYPE') |>
  select(VALUE, MEANING) |>
  rename(FORTYPCD = VALUE) |>
  rename(FORTYPE = MEANING)

tree_stats <- tbl(fia, 'TREE') |>
  select(STATECD, COUNTYCD, PLOT, CONDID, INVYR, DIA, CARBON_AG, TPA_UNADJ) |>
  group_by(STATECD, COUNTYCD, PLOT, CONDID, INVYR) |>
  summarize(
    CARBON_AG = sum(CARBON_AG, na.rm = TRUE),
    CPA = sum(CARBON_AG * TPA_UNADJ, na.rm = TRUE),
    BA_TREES = sum(if_else(DIA >= 1, TPA_UNADJ, 0), na.rm = TRUE),
    .groups = "keep"
  )

stand_stats <- tbl(fia, 'COND') |>
  select(STATECD, COUNTYCD, PLOT, INVYR, STDAGE, BALIVE, FORTYPCD) |>
  filter(INVYR >= 1999) |>
  semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
  group_by(STATECD, COUNTYCD, PLOT, INVYR) |>
  # QMD = sqrt(sum(DIA^2) / n)
  # Which is equivalent to
  # QMD = sqrt(sum(BALIVE * TPA_UNADJ) / (n * k)), where n is number of trees,
  # and k is π/576 ≅ 0.005454 for B in square feet and QMD in inches;
  # and k is π/40000 ≅ 0.0000785 for B in square meters and QMD in centimeters.
  # (see https://www.sciencedirect.com/science/article/pii/S2197562023000453 ,
  # https://doi.org/10.1016/j.fecs.2023.100114 )
  # When computing QMD from BA we need to use the same trees for BA and n;
  # FIADB data dictionary 2.5.51 BALIVE says "Basal area in square feet per
  # acre of all live trees ω1.0 inch d.b.h/d.r.c sampled in the condition."
  summarize(
    BALIVE = sum(BALIVE, na.rm = TRUE),
    FORTYPCD = max(FORTYPCD, na.rm = TRUE),
    STDAGE = max(STDAGE, na.rm = TRUE),
    .groups = "keep"
  ) |>
  ungroup() |>
  left_join(measyear, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
  left_join(tree_stats, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
  filter(!is.na(CARBON_AG)) |>
  left_join(forest_type, by = join_by(FORTYPCD)) |>
  rename(`Forest Type` = FORTYPE) |>
  mutate(FORTYPCD = floor(FORTYPCD / 10) * 10) |>
  left_join(forest_type, by = join_by(FORTYPCD)) |>
  rename(`Forest Type Group` = FORTYPE) |>
  collect() |>
  mutate(BALIVE_METRIC = conv_multiunit(BALIVE, "ft2 / acre", "m2 / hectare")) |>
  mutate(QMD = sqrt(BALIVE / (BA_TREES * (pi / 576)))) |>
  mutate(QMD_METRIC = sqrt(BALIVE_METRIC / (BA_TREES * (pi / 40000)))) |>
  mutate(CARBON_METRIC = conv_multiunit(CPA, "lbs / acre", "Mg / hectare"))

dbDisconnect(fia)
remove(fia, measyear, forest_type, tree_stats)
```

Re-plot location with forest type

```{r}
plot_location_tmp <- plot_location |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, long, lat, group)

plot_location_type <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  mutate(`Forest Type Group` = 
     if_else(startsWith(`Forest Type Group`, 'Other'), 'Other',
       if_else(startsWith(`Forest Type Group`, 'Exotic'), 'Other',
         `Forest Type Group`
       )
     )
  ) |>
  select(STATECD, COUNTYCD, PLOT, INVYR, `Forest Type`, `Forest Type Group`) |>
  left_join(plot_location_tmp, by = join_by(STATECD, COUNTYCD, PLOT))

ggplot(map_states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(plot_location_type, mapping = aes(long, lat, group = group, color = `Forest Type Group`)) +
  coord_quickmap()

remove(plot_location_tmp)
```

Look at BA over time

```{r}
ggplot(
    data = stand_stats |> filter(STDAGE > 0),
    mapping = aes(x = STDAGE, y = BALIVE_METRIC)
  ) +
  geom_point(alpha = 0.25) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nFIA Measured basal area (m2 / ha)")
```

```{r}
latest_measyear <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    MEASYEAR = max(MEASYEAR),
    .groups = "keep"
  ) |>
  ungroup()

seen_types <- stand_stats |>
  semi_join(latest_measyear, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR)) |>
  group_by(`Forest Type`) |>
  summarize(
    CARBON_AG_METRIC = sum(conv_unit(CARBON_AG, "lbs", "Mg")),
    .groups = "keep"
  )

seen_types |>
  ggplot(
    aes(y = fct_reorder(`Forest Type`, CARBON_AG_METRIC), x = CARBON_AG_METRIC)
  ) +
  scale_x_log10() +
  geom_col() +
  ggtitle("Total Carbon by Forest Type (Mg)") +
  ylab("Forest Type") +
  xlab("Carbon")
```

## Run FVS

### Generate Keyfile

An FVS run is scripted by a keyfile. The keyfile describes how to run the
model and extensions, including where to read input, all parameters to
control processing, and where to write output.

The keyfile is structured by stand; each stand is a separate run of the
model.

To run in parallel, a separate keyfile must be generated for each partition
to be run in parallel. Each partition must send its output to a separate
location, and these can be assembled into a single output as a post-
processing step.

#### Stand Identification

For each stand, we need:

-  StdIdent: Stand Identifier, from fia.FVS_STANDINIT_PLOT.FVS_STAND_ID
-  StandCN: Stand control number, from fia.PLOT.CN
-  MgmtId: Management ID, for no treatment, this is NONE

#### Time

We will run the model from first measurement year to 2024, with a 1-year timestep.

-  InvYear: Inventory Year, this is the first fia.PLOT.MEASYEAR
-  TimeInt: Time Interval, set this to 1 for all timesteps
-  NumCycle: Number of cycles to run, 2024 - InvYear

#### Input

There are two inputs, Stand and Tree. Both are configured to use a database
query.

Within a Database subsection:

-  DSNIn: Data Source Name (DSN) for input; SQLite filename
-  StandSQL: SQL query to fetch a stand, given %Stand_CN%
-  TreeSQL: SQL query to fetch all trees for a stand, given %Stand_CN%

#### Fire and Fuels

Carbon is calculated by the fire and fuels extension.

-  FMIn: Starts configuration of Fire and Fuels extension
-  CarbRept: Carbon Report; save to database (2)
-  CarbCut: Harvested Carbon Report; disable (0)
-  CarbCalc: Carbon calculation; metric (1)
-  FuelOut: Fuel Output, disable (0)
-  FuelRept: Fuel Report, disable (0)

Fire and Fuels also interacts with the database extension; it provides additional
Database keywords to configure Fire and Fuels output to the database.

Within a Database section:

-  CarbReDB: FVS_Carbon and FVS_Hrv_Carbon tables: database (2)
-  FuelReDB: FVS_Consumption table: database (2)
-  FuelsOut: FVS_Fuels table: database (2)

#### Output

We use database output; it is easiest to work with. Many output options take
a parameter that is 0 to disable output, 1 for file output, 2 for database
output, and 3 for both file and database output.

Within a Database section:

-  DSNOut: Data Source Name (DSN) for output; SQLite filename
-  Summary: Configure FVS_Summary; use version 2
-  Computdb: Configure FVS_Compute; disable
-  MisRpts: Configure Mistletoe reports; disable

#### Processing Order

Each stand has its own section of the keyword file, including everything from
StdIdent to Process. Each stand is processed before moving to the next stand.

At the end of all stands, the Stop keyword tells FVS to exit cleanly.

#### Example

```
StdIdent
230202502686        NoManagement
StandCN
52967848010538
MgmtId
NONE
InvYear         2002
TimeInt            0         1
NumCycle           1

FMIn
CarbRept           2
CarbCut            2
CarbCalc           0         1    0.0425         9        11
FuelOut            2
FuelRept           2
End

Database

DSNIn
SQLite_FIADB_ENTIRE.db

StandSQL
SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL

TreeSQL
SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL

DSNOut
FVS_NoManagement_NONE.db

Summary            2
Computdb           0         1
MisRpts            2
CarbReDB           2
FuelReDB           2
FuelsOut           2

END

Process

Stop
```

#### Keword File Generation

Gather stand IDs and CNs for keywordfile generation.

We gather two series of stands:

-  stands_projected is a list of stands and inventory years to grow out to 2025
-  stands_surveyed is a list of stands and inventory years to grow for 0 years
   in each survey year.

When generating keyword files, we create one per partition,
distributing across partitions using round-robin on STAND_ID.

keywordfile_section is a function to generate a keywordfile section from
information about a run and a stand.

```{r}
keywordfile_section <- function(Title, MgmtId, StandID, StandCN, MeasYear, EndYear, Partition) {
  MeasYear <- as.integer(MeasYear)
  paste0(
"StdIdent\n",
StandID, " ", Title, "\n",
"StandCN\n",
StandCN, "\n",
"MgmtId\n",
MgmtId, "\n",
"InvYear   ", sprintf('%10s', MeasYear), "\n",
"TimeInt            0         1\n",
"NumCycle  ", sprintf('%10d', EndYear - MeasYear), "\n",
"FMIn\n",
"CarbRept           2\n",
"CarbCut            2\n",
"CarbCalc           1         1    0.0425         9        11\n",
"FuelOut            2\n",
"FuelRept           2\n",
"End\n",
"Database\n",
"DSNIn\n",
"SQLite_FIADB_ENTIRE.db\n",
"StandSQL\n",
"SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'\n",
"EndSQL\n",
"TreeSQL\n",
"SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'\n",
"EndSQL\n",
"DSNOut\n",
"FVS_", Title, "_", MgmtId, "_", Partition, ".db\n",
"Summary            2\n",
"Computdb           0         1\n",
"MisRpts            2\n",
"CarbReDB           2\n",
"FuelReDB           2\n",
"FuelsOut           2\n",
"End\n",
"Process\n"
  )
}

```

Find the stands we want to project; these are the grow-only stands starting
in their first measurement year.

```{r}
first_measyear <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    INVYR = min(INVYR),
    MEASYEAR = min(MEASYEAR, na.rm = TRUE),
    .groups = "keep"
  ) |>
  ungroup()


fia <- DBI::dbConnect(RSQLite::SQLite(), '../00_rawData/SQLite_FIADB_ENTIRE.db')
fia_fvs_standinit_plot <- tbl(fia, 'FVS_StandInit_Plot') |>
  select(STAND_CN, STAND_ID)

stands_projected <- tbl(fia, 'PLOT') |>
  select(CN, STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR) |>
  filter(INVYR >= 1999) |>
  rename(STAND_CN = CN) |>
  semi_join(first_measyear, by = join_by(STATECD, COUNTYCD, PLOT, INVYR), copy = TRUE) |>
  left_join(fia_fvs_standinit_plot, by = join_by(STAND_CN)) |>
  collect()

dbDisconnect(fia)
remove(fia, fia_fvs_standinit_plot)
```

The first run is to project from the first measurement year to 2025. These
are given management ID "NONE".

```{r}
for (partition in 1:8) {
  filename <- paste0("../03_outputs/FVS_Northeastern_NONE_", partition, ".key")
  write_lines(
    apply(
      stands_projected |> filter((as.numeric(STAND_ID) %% 8) == (partition - 1)),
      1,
      function(row) {
        keywordfile_section(
          "Northeastern",
          "NONE",
          row['STAND_ID'],
          row['STAND_CN'],
          row['MEASYEAR'],
          2025,
          partition
        )
      }
    ),
    filename
  )
  write_lines("Stop", filename, append = TRUE)
}
```

The second run is a zero-year projection to have FVS calculate the carbon
in surveyed stands in each year they are surveyed.

```{r}
fia <- DBI::dbConnect(RSQLite::SQLite(), '../00_rawData/SQLite_FIADB_ENTIRE.db')
fia_fvs_standinit_plot <- tbl(fia, 'FVS_StandInit_Plot') |>
  select(STAND_CN, STAND_ID)

stands_surveyed <- tbl(fia, 'PLOT') |>
  select(CN, STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR) |>
  filter(INVYR >= 1999) |>
  rename(STAND_CN = CN) |>
  semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
  left_join(fia_fvs_standinit_plot, by = join_by(STAND_CN)) |>
  collect()

dbDisconnect(fia)
remove(fia, fia_fvs_standinit_plot)
```

The second run is to do a 0-year projection for each measurement year. These
are given management ID "SRVY".

```{r}
for (partition in 1:8) {
  filename <- paste0("../03_outputs/FVS_Northeastern_SRVY_", partition, ".key")
  write_lines(
    apply(
      stands_surveyed |> filter((as.numeric(STAND_ID) %% 8) == (partition - 1)),
      1,
      function(row) {
        keywordfile_section(
          "Northeastern",
          "SRVY",
          row['STAND_ID'],
          row['STAND_CN'],
          row['MEASYEAR'],
          as.integer(row['MEASYEAR']) + 1,
          partition
        )
      }
    ),
    filename
  )
  write_lines("Stop", filename, append = TRUE)
}
```
#### Run FVS.

```{r}
# TODO nik: Run FVS from in R.
# Batch file to run FVS in parallel:
# for %%p in (FVS_Northeastern_NONE_*.key) do start \FVS\FVSbin\FVSne.exe --keywordfile=%%p
```

## Assemble Results

Load the output from all FVS partitions into a single dataframe

```{r}
FVS_Carbon_NONE <- NULL
FVS_Carbon_SRVY <- NULL
FVS_Summary2_East_NONE <- NULL
FVS_Summary2_East_SRVY <- NULL

for (partition in 1:8) {
  fvs_out_db <- DBI::dbConnect(
    RSQLite::SQLite(),
    paste0('../03_outputs/FVS_Northeastern_NONE_', partition, '.db')
  )
  fvs_carbon_tbl = tbl(fvs_out_db, 'FVS_Carbon') |>
    mutate(Partition = partition)
  fvs_summary2_east_tbl = tbl(fvs_out_db, 'FVS_Summary2_East') |>
    mutate(Partition = partition)

  FVS_Carbon_NONE <- bind_rows(FVS_Carbon_NONE, fvs_carbon_tbl |> collect())
  FVS_Summary2_East_NONE <- bind_rows(FVS_Summary2_East_NONE, fvs_summary2_east_tbl |> collect())
  
  dbDisconnect(fvs_out_db)

  fvs_out_db <- DBI::dbConnect(
    RSQLite::SQLite(),
    paste0('../03_outputs/FVS_Northeastern_SRVY_', partition, '.db')
  )
  fvs_carbon_tbl = tbl(fvs_out_db, 'FVS_Carbon') |>
    mutate(Partition = partition)
  fvs_summary2_east_tbl = tbl(fvs_out_db, 'FVS_Summary2_East') |>
    mutate(Partition = partition)

  FVS_Carbon_SRVY <- bind_rows(FVS_Carbon_SRVY, fvs_carbon_tbl |> collect())
  FVS_Summary2_East_SRVY <- bind_rows(FVS_Summary2_East_SRVY, fvs_summary2_east_tbl |> collect())
  
  dbDisconnect(fvs_out_db)
}

remove(fvs_out_db, fvs_carbon_tbl, fvs_summary2_east_tbl)
```

Filter projections to corresponding observations

```{r}
projected_carbon_tmp <- FVS_Carbon_NONE |>
  select(StandID, Year, Aboveground_Total_Live) |>
  rename(Projected_Carbon = Aboveground_Total_Live)

projected_ba_tmp <- FVS_Summary2_East_NONE |>
  select(StandID, Year, BA) |>
  mutate(Projected_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare"))

projected_tmp <- projected_carbon_tmp |>
  full_join(projected_ba_tmp, by = join_by(StandID, Year)) |>
  mutate(STAND_ID = paste0(
     substring(StandID, 1, 2),
     substring(StandID, 5, 12)
  )) |>
  select(STAND_ID, Year, Projected_Carbon, Projected_BA)

first_measyear_tmp <- first_measyear |>
  select(STATECD, COUNTYCD, PLOT, MEASYEAR) |>
  rename(First_Year = MEASYEAR)

latest_measyear_tmp <- latest_measyear |>
  rename(Last_Year = MEASYEAR)

surveyed_carbon_tmp <- FVS_Carbon_SRVY |>
  select(StandID, Year, Aboveground_Total_Live) |>
  rename(Measured_Carbon = Aboveground_Total_Live)

surveyed_ba_tmp <- FVS_Summary2_East_SRVY |>
  select(StandID, Year, BA) |>
  mutate(Measured_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare"))

surveyed_tmp <- surveyed_carbon_tmp |>
  full_join(surveyed_ba_tmp, by = join_by(StandID, Year)) |>
  mutate(STAND_ID = paste0(
     substring(StandID, 1, 2),
     substring(StandID, 5, 12)
  )) |>
  select(STAND_ID, Year, Measured_Carbon, Measured_BA)

projected_vs_measured <- stand_stats |>
  left_join(first_measyear_tmp, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  left_join(latest_measyear_tmp, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  filter(MEASYEAR == First_Year | MEASYEAR == Last_Year) |>
  mutate(STAND_ID = sprintf(paste0(
    '%02d',  '%03d',   '%05d'),
    STATECD, COUNTYCD, PLOT
  )) |>
  rename(Year = MEASYEAR) |>
  select(
    STAND_ID, Year, First_Year,
    STDAGE, `Forest Type`, `Forest Type Group`,
    QMD, QMD_METRIC
  ) |>
  mutate(`Forest Type Group` = 
     if_else(startsWith(`Forest Type Group`, 'Other'), 'Other',
       if_else(startsWith(`Forest Type Group`, 'Exotic'), 'Other',
         `Forest Type Group`
       )
     )
  ) |>
  mutate(Projection_Years = Year - First_Year) |>
  left_join(projected_tmp, by = join_by(STAND_ID, Year)) |>
  left_join(surveyed_tmp, by = join_by(STAND_ID, Year)) |>
  filter(!is.na(Projected_Carbon) & !is.na(Measured_Carbon)) |>
  mutate(Residual = Projected_Carbon - Measured_Carbon) |>
  mutate(Projection_Error = Residual / Measured_Carbon) |>
  mutate(Projection_Error_Magnitude = abs(Projection_Error))

remove(
  projected_carbon_tmp,
  projected_ba_tmp,
  projected_tmp,
  surveyed_carbon_tmp,
  surveyed_ba_tmp,
  surveyed_tmp,
  first_measyear_tmp,
  latest_measyear_tmp
)
```

plot 'em

```{r}

ggplot(
    data = projected_vs_measured
  ) +
  geom_point(
    size = 2,
#    alpha = 0.5,
    mapping = aes(x = Measured_Carbon, y = Projected_Carbon, color = Projection_Years)
  ) +
  geom_abline(intercept = 0, slope = 1) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nMeasured vs. Projected Carbon (Mg/ha)") +
  coord_cartesian(xlim = c(0, 300), ylim = c(0, 300))
```

```{r}
ggplot(
    data = projected_vs_measured |> filter(Projection_Years > 0)
  ) +
  geom_point(
    size = 2,
#    alpha = 0.5,
    mapping = aes(x = Measured_Carbon, y = Projected_Carbon, color = Projection_Years)
  ) +
  geom_smooth(
    method = lm,
    mapping = aes(x = Measured_Carbon, y = Projected_Carbon),
    formula = 'y ~ x',
    color = 'brown'
  ) +
  geom_abline(intercept = 0, slope = 1) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nMeasured vs. Projected Carbon (Mg/ha)") +
  coord_cartesian(xlim = c(0, 300), ylim = c(0, 300))
```

```{r}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    mapping = aes(x = Projection_Years, y = Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjection Error (Mg/ha) vs. Measured BA")
  
```



```{r}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    mapping = aes(x = Measured_BA, y = Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjection Error (Mg/ha) vs. Measured BA")
  
```


```{r}
ggplot(
    projected_vs_measured |> filter(Projection_Error_Magnitude <= 2),
    mapping = aes(x = Projection_Years, y = Projection_Error)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjection Error (fraction) vs. Projection years")
  
```

```{r}
ggplot(
    projected_vs_measured |> filter(Projection_Error_Magnitude <= 2),
    mapping = aes(x = Projection_Years, y = Projection_Error_Magnitude)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjection Error Magnitude (fraction) vs. Projection years")
  
```

```{r}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      filter(Projection_Error_Magnitude < 2),
    mapping = aes(x = Measured_BA, y = Projection_Error)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjection Error (fraction) vs. Measured BA (m2 / ha)")
```

This omits outliers; looking just at the outliers (error >= 2x value):

```{r}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      filter(Projection_Error_Magnitude >= 2),
    mapping = aes(x = Measured_BA, y = Projection_Error)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  coord_cartesian(xlim = c(0, 80), ylim = c(-15, 15)) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjection Error Outliers vs. Measured BA (m2 / ha)")

```

```{r}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      filter(Projection_Error_Magnitude < 2),
    mapping = aes(x = QMD_METRIC, y = Projection_Error)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjection Error (fraction) vs. Measured QMD (cm)")
```

