---
title: "12_CFICOP"
output: html_document
---

# Setup

```{r setup, include=FALSE}
suppressPackageStartupMessages({
  library(targets)
  library(tarchetypes)
  library(tidyverse)
  library(readxl)
  library(terra)
  library(sf)
  library(rnaturalearth)
  library(measurements)
  library(mlr3verse) # Machine Learning in R framework, larger universe
  library(ggspatial) # annotation_scale, annotation_north_arrow
  library(ggfx) # for fancy ggplot stuff like with_blur
})
tar_source()

## Load targets results from other documents ----

tar_load(fiadb)
tar_load(species_crosswalk)
tar_load(fvs_num_partitions)
tar_load(fvs_partition)
tar_load(fvs_randseed)
tar_load(fvsne_states)
tar_load(cfigro_bai_model)
tar_load(cfigro_estab)
tar_load(cfigro_none_growth)

## Preload everything from 11_CFIGrowOnly.Rmd ----

get_this_rmd_file() |>
  str_replace(basename(get_this_rmd_file()), "11_CFIGrowOnly.Rmd") |>
  tar_objects_defined_in_rmd() |>
  tar_load()

## Preload targets results from this document ----

# When tar_make() has already built the objects defined in this document,
# run this block to pre-load them. You can then skip running ```{targets}
# blocks.

get_this_rmd_file() |>
  tar_objects_defined_in_rmd() |>
  tar_load()

## Eve's Colors ----

#colors1 <- c("indianred3", "chocolate2", "goldenrod2", "yellow3", "olivedrab")
eves_colors <- c(
  "Other" = "#B4B432",
  "Fraxinus" = "#CD5C5C",
  "Betula" = "#8B4513",
  "Tsuga" = "#5F9EA0",
  "Acer" = "#DEB887",
  "Pinus" = "#556B2F",
  "Quercus" = "#D2691E"
)
#colors3 <- c("darkorange4", "goldenrod3", "darkolivegreen")
```

# MODEL ALL* THE PLOTS!!!

We want to:
- Model all the plots grow-only
- Apply the model of residuals to get an idea of how much FVS might have over-projected
- Look at harvest, and how much carbon is actually on the landscape
- Multiply by area to get an idea of what COP would be, etc.

* We don't have harvest information except on Audrey's plots, so we'll actually
just use her 283 plots. So it's not _all_ of all the plots, but it's all the
plots for which we have good data.

## Plots

cfigro_plot has all 283 plots.

## Trees

cfigro_tree has trees for all 283 plots.

### All the plots?

We only need trees in 1970; can we use all the plots?

```{r all the plots, eval = FALSE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
#  cfi_abp(cfiabp_trees) |>
  filter(VisitCycle == 1970) |>
  filter(cfi_status_live(VisitTreeStatusCode)) |> # Only Live Trees
  distinct(MasterPlotID) |>
  nrow()
```

There are 337 plots with trees in 1970; the 65 additional plots dont's seem
worth the extra effort.

For the manuscript, "Many plot locations in the Quabbin watershed were adjusted
in 1970, creating a discontinuity in observed data. This study exampines the
period from 1970 - 2020, during which plot location is consistent. There were
337 plots with trees in 1970; of these, detailed information on harvest and
disturbance is available on 277 [Barker-Plotkin 2024]."

## Regeneration

We ignored harvest in CFIGRO; can we continue to ignore it?

```{r plot establishment rate, eval = FALSE}
cfigro_estab |>
  mutate(STAND_CN = as.character(STAND_CN)) |>
  group_by(STAND_CN) |>
  summarize(DENSITY = sum(DENSITY), .groups = "keep") |>
  left_join(cfigro_plot |> select(STAND_CN, STAND_ID), by = join_by(STAND_CN)) |>
  mutate(MasterPlotID = as.numeric(STAND_ID)) |>
  left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
  left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
  mutate(Status = case_when(
    CFIDisturbed & CFIHarvested ~ "Disturbed & Harvested",
    CFIDisturbed ~ "Disturbed",
    CFIHarvested ~ "Harvested",
    .default = "Grow-Only"
  )) |>
  group_by(Status) |>
  mutate(Status = paste0(Status, ", n=", n())) |>
  ggplot(aes(Status, DENSITY)) +
  geom_boxplot() +
  theme_bw() +
  ggtitle("Establishment rate by plot status") +
  ylab(bquote("Establishment rate" ~ (stems %.% acre^-1 %.% year^-1)))
#  scale_y_continuous(transform = "log10")
  
```

non-Grow-Only plots show double and more the establishment rate of grow-only
plots.

Establishment comes from saplings / seedlings, which come from seeds, which
either come into the plot from outside or come from mature trees on the plot.
All of these plots are co-located, so they can trade seeds with each other.
For available seeds from trees on the plot, we can match plots by BA of the
major species, then use the establishment from the matched / sibling plot.

### Plot Matching

Start simple - minimize the delta in the three major species. We can leave "Other" alone.

```{targets cficop_plot_sibling, tar_simple = TRUE}
tmp_trees <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  filter(VisitCycle == 1970) |>
  filter(cfi_status_live(VisitTreeStatusCode)) |> # Only Live Trees
  # Quercus rubra and Quercus velutina are often conflated in surveys; instead
  # of treating them as two separate important species, combine them into one and
  # treat them as a single species.
  # Replace Quercus velutina (837) with Quercus rubra (833)
  mutate(
    SpeciesCode = if_else(SpeciesCode == 837, 833, SpeciesCode)
  ) |>
  left_join(
    species_crosswalk |> select(SPCD, SCIENTIFIC_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    TPA = 5,
    BA = VisitTreeDIAM
  )

tmp_by_plot <- tmp_trees |>
  group_by(MasterPlotID) |>
  summarize(
    TPA_Plot = sum(TPA, na.rm = TRUE),
    BA_Plot = sum(BA, na.rm = TRUE),
    .groups = "drop"
  ) |>
  ungroup() |>
  select(MasterPlotID, TPA_Plot, BA_Plot)

tmp_top_species <- c(
  "Acer rubrum", "Quercus rubra", "Pinus strobus"
)

tmp_plot_fingerprint <- tmp_trees |>
  group_by(MasterPlotID, SCIENTIFIC_NAME) |>
  summarize(
    TPA_Species = sum(TPA, na.rm = TRUE),
    BA_Species = sum(BA, na.rm = TRUE),
    .groups = "keep"
  ) |>
  ungroup() |>
  left_join(tmp_by_plot, by = join_by(MasterPlotID)) |>
  mutate(
    TPA_Frac = TPA_Species / TPA_Plot,
    BA_Frac = BA_Species / BA_Plot
  ) |>
  select(-ends_with("_Species")) |>
#  filter(BA_Frac > 0.1) |>
  filter(SCIENTIFIC_NAME %in% tmp_top_species) |>
  group_by(MasterPlotID) |>
  mutate(
    Species = do.call(
      paste,
      append(sort(SCIENTIFIC_NAME), list(sep = ", "))
    )
  ) |>
  ungroup() |>
  mutate(SCIENTIFIC_NAME = gsub(" ", "_", SCIENTIFIC_NAME)) |>
  pivot_wider(names_from = "SCIENTIFIC_NAME", values_from = c("TPA_Frac", "BA_Frac"))

tmp_plots_grow_only <- cfigro_plot_harvested |>
  filter(!CFIHarvested) |>
  inner_join(
    cfigro_plot_disturbed |> filter(!CFIDisturbed),
    by = join_by(MasterPlotID)
  ) |>
  select(MasterPlotID)

pct_diff <- function(a, b) {
  abs(a - b) / ((a + b) / 2)
}

most_similar_plot <- function(target_plots) {
  target_plots <- target_plots |>
    # Penalize things that differ on whether they have
    # a species on the landscape
    replace_na(list(
      BA_Frac_Pinus_strobus = -1,
      BA_Frac_Acer_rubrum = -1,
      BA_Frac_Quercus_rubra = -1
    ))

  lapply(1:nrow(target_plots), \(n) {
    # Minimize RMS difference in BA
    ba_plot <- target_plots[[n, "BA_Plot"]]
    ba_pist <- target_plots[[n, "BA_Frac_Pinus_strobus"]]
    ba_acru <- target_plots[[n, "BA_Frac_Acer_rubrum"]]
    ba_quru <- target_plots[[n, "BA_Frac_Quercus_rubra"]]
    tmp_plot_fingerprint |>
      inner_join(tmp_plots_grow_only, by = join_by(MasterPlotID)) |>
      replace_na(list(
        BA_Frac_Pinus_strobus = -1,
        BA_Frac_Acer_rubrum = -1,
        BA_Frac_Quercus_rubra = -1
      )) |>
      mutate(
        BA_RMSE = sqrt(
          pct_diff(BA_Plot, ba_plot)^2 +
            (BA_Frac_Pinus_strobus - ba_pist)^2 +
            (BA_Frac_Acer_rubrum - ba_acru)^2 +
            (BA_Frac_Quercus_rubra - ba_quru)^2
        )
      ) |>
      arrange(BA_RMSE) |>
      head(1) |>
      pull(MasterPlotID)    
  }) |>
    unlist()
}

tmp_plot_fingerprint |>
  mutate(sibling_plot = most_similar_plot(tmp_plot_fingerprint)) |>
  select(MasterPlotID, sibling_plot)
```

How's that looks:

```{r plot sibling plots, eval = FALSE}
tmp_top_species <- c(
  "Acer rubrum", "Quercus rubra", "Pinus strobus"
)

tmp_species <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  filter(VisitCycle == 1970) |>
  filter(cfi_status_live(VisitTreeStatusCode)) |> # Only Live Trees
  mutate(
    SpeciesCode = if_else(SpeciesCode == 837, 833, SpeciesCode)
  ) |>
  left_join(
    species_crosswalk |> select(SPCD, SCIENTIFIC_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  filter(SCIENTIFIC_NAME %in% tmp_top_species) |>
  distinct(MasterPlotID, SCIENTIFIC_NAME) |>
  group_by(MasterPlotID) |>
  summarize(
    Species = do.call(
      paste,
      append(sort(SCIENTIFIC_NAME), list(sep = ", "))
    ),
    .groups = "drop"
  ) |>
  select(MasterPlotID, Species)

matched_plots <- cficop_plot_sibling |>
  mutate(
    status = if_else(MasterPlotID == sibling_plot, "reference", "matched")
  ) |>
  left_join(
    cfigro_plot,
    by = join_by(MasterPlotID == STAND_ID)
  ) |>
  rename(
    lat = LATITUDE,
    long = LONGITUDE
  ) |>
  mutate(
    group = as.character(sibling_plot)
  ) |>
  select(
    MasterPlotID, status, lat, long, group
  ) |>
  left_join(
    tmp_species, by = join_by(MasterPlotID)
  ) |>
  group_by(group) |>
  mutate(n = n(), group = paste0(group, ", n=", n())) |>
  ungroup() |>
  filter(n > 12)
#  filter(n > 6)

matched_plot_group_order <- matched_plots |>
  distinct(group, n) |>
  arrange(desc(n))

matched_plots$group <- ordered(matched_plots$group, levels = matched_plot_group_order$group)

cfi_bbox <- st_as_sfc(
  st_bbox(vect(matched_plots, geom = c("long", "lat")))
)
sf_use_s2(FALSE)
st_crs(cfi_bbox) <- "WGS84"
lakes_north_america <- ne_download(
  scale = 10, type = "lakes_north_america", category = "physical"
)
lakes <- lakes_north_america[
  st_intersects(lakes_north_america, cfi_bbox, sparse = FALSE),
]
rivers_north_america <- ne_download(
  scale = 10, type = "rivers_north_america", category = "physical"
)
rivers <- rivers_north_america[
  st_intersects(rivers_north_america, cfi_bbox, sparse = FALSE),
]
ggplot() +
  geom_sf(data = lakes, fill = "blue", inherit.aes = FALSE) +
#  geom_sf(data = rivers, fill = "blue", inherit.aes = FALSE) +
  geom_point(
    data = matched_plots |> filter(status == "reference"),
    aes(long, lat, color = Species, shape = status), size = 2.5
  ) +
  geom_point(
    data = matched_plots |> filter(status == "matched"),
    aes(long, lat, color = Species, shape = status), size = 1.75
  ) +
  facet_wrap("group") +
#  scale_color_discrete(guide = "none") +
  scale_shape_manual(values = list(reference = 17, matched = 16)) +
#  annotation_scale(location = "br") +
#  annotation_north_arrow(
#    location = "tl",
#    width = unit(1, "cm"),
#    pad_x = unit(0.75, "cm"),
#    pad_y = unit(0.5, "cm")
#  ) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = -30, hjust = 0, vjust = 1)) +
  ggtitle("Matching harvested and disturbed CFI plots to grow-only plots")
```


### Copy CFIGRO Estab

We'll duplicate cfigro_estab from the reference plots to their sibling plots.

```{targets cficop_estab, tar_simple = TRUE}
# Each plot has a sibling plot;
# find the estab associated with the sibling plot.
cficop_plot_sibling |>
  left_join(
    cfigro_plot |> select(STAND_CN, MasterPlotID = STAND_ID),
    by = join_by(sibling_plot == MasterPlotID)
  ) |>
  mutate(STAND_CN = as.numeric(STAND_CN)) |>
  left_join(
    cfigro_estab,
    by = join_by(STAND_CN),
    # Each row on the left is a stand; many stands have the same STAND_CN.
    # Each row on the right is a stand-species; many rows on the right will
    # match a single stand. Therefore this is a many-to-many join.
    relationship = "many-to-many"
  ) |>
  # STAND_CN is for the sibling plot; swap that out
  # with the STAND_CN for the matched plot.
  select(-STAND_CN) |>
  left_join(
    cfigro_plot |> select(STAND_CN, MasterPlotID = STAND_ID),
    by = join_by(MasterPlotID)
  )
```

### Growth

cfigro_none_growth is tree-specific; for each tree within a plot, provide the diameter
and height 10 years from the simulation start time.

### Mortality

cfigro_none_death is tree-specific; for each tree within a plot, provide the status
at simulation start time.

## Watershed Area

I think I need to get a polygon for the watershed / districts, then use
land cover to find the forested area ... in 1970. Which I can't. Unless
they have literature that tells me.

But we can start with, what if it's 100% forested.

```{targets cficop_sam_wt, tar_simple = TRUE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  group_by(MasterPlotID) |>
  arrange(VisitCycle, MasterTreeID) |>
  filter(row_number() == 1) |>
  ungroup() |>
  left_join(
    tblSuppPlotForestrySubBasins,
    by = join_by(DWSPForestrySubWatershed == MasterForestryBasinID)
  ) |>
  group_by(EQDISTRICT, EQSUBDISTRICT) |>
  mutate(
    TotalAcres = max(DWSPOwnedAcres, na.rm = TRUE),
    NumPlots = n(),
    AcresPerPlot = TotalAcres / NumPlots,
    .groups = "keep"
  ) |>
  ungroup() |>
  select(
    EQDISTRICT,
    EQSUBDISTRICT,
    MasterPlotID,
    TotalAcres,
    NumPlots,
    AcresPerPlot
  )
```

```{r plot scaling cfi plots to watershed, eval = FALSE}
cficop_sam_wt |>
  group_by(EQSUBDISTRICT) |>
  filter(row_number() == 1) |>
  ggplot(aes(EQSUBDISTRICT, NumPlots, size = AcresPerPlot)) +
  geom_point() +
  coord_cartesian(ylim = c(0, 80)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = -15, hjust = 0, vjust = 1)) +
  ggtitle("Scaling CFI plots to the Watershed") +
  xlab("Subwatershed") +
  ylab("Number of Plots")
```

```{r map cfi plot scaling to watershed, eval = FALSE}
tmp_state_map <- fvsne_states |>
  filter(STATE_NAME == "Massachusetts") |>
  rename(region = STATE_NAME) |>
  _$region |>
  map_data("state", region = _)

tmp_plot_loc <- cfigro_plot |>
  rename(lat = LATITUDE, long = LONGITUDE, group = STAND_CN) |>
  left_join(
    cficop_sam_wt |> select(MasterPlotID, EQSUBDISTRICT, AcresPerPlot),
    by = join_by(STAND_ID == MasterPlotID)
  )

ggplot(tmp_state_map, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") +
  geom_point(
    data = tmp_plot_loc,
    aes(size = AcresPerPlot, color = EQSUBDISTRICT)
  ) +
  coord_cartesian(xlim = c(-72.45, -72.15), ylim = c(42.25, 42.55)) +
  theme_bw()
```

It looks, however, like we want to treat the entire area as one thing.
What's the total area?

```{r total acres, eval = FALSE}
print(277*0.2)
tblSuppPlotForestrySubBasins |>
  filter(Watershed == 1) |>
  summarize(acres = sum(DWSPOwnedAcres)) |>
  pull(acres)
```

So, by area, we've sampled 277*0.2 = 55.4 acres out of 58657 acres, or about 0.1%.

Oh, but probably we only want the subwatersheds that plots are actually present
on, so:

```{r sample weight, eval = FALSE}
cficop_sam_wt |>
  group_by(EQSUBDISTRICT) |>
  filter(row_number() == 1) |>
  ungroup() |>
  summarize(acres = sum(TotalAcres)) |>
  pull(acres)
```

so 19522, or roughly 20,000 acres, or less than half the total.

Or maybe we want not just ABP plots, but all Quabbin plots

```{r total acres another way, eval = FALSE}
tblSuppPlotForestrySubBasins |>
  filter(Watershed == 1) |>
  semi_join(
    tblDWSPCFIPlotsComplete |> distinct(DWSPForestrySubWatershed),
    by = join_by(MasterForestryBasinID == DWSPForestrySubWatershed)
  ) |>
  summarize(acres = sum(DWSPOwnedAcres)) |>
  pull(acres)
```

56816 acres.

# CFICOP_NONE

## Run FVS

```{targets cficop_none}
tar_target(
  cficop_none,
  {
    timestep <- 10 # years; determined by FVSne variant
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "CFICarbonOffsetProgram"
    mgmt_id <- "NONE"
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = NULL,
      title = title,
      mgmt_id = mgmt_id,
      stands = cfigro_plot |>
        # Filter out the 6 plots that do not get a sibling
        semi_join(
          cficop_plot_sibling,
          by = join_by(STAND_ID == MasterPlotID)
        ),
#        left_join(
#          cficop_sam_wt |> select(STAND_ID = MasterPlotID, SAM_WT = AcresPerPlot),
#          by = join_by(STAND_ID)
#        ),
      trees = cfigro_trees,
      regen = cficop_estab,
#      calibration = cfigro_none_growth,
#      calib_mort = cfigro_none_death,
#      calib_years = 10,
      num_partitions = fvs_num_partitions,
      partition = fvs_partition,
      random_seed = fvs_randseed
    )
  },
  # iteration = "vector" branches execution for each partition value (see below)
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here.
  # cross() ensures that every combination of values for its arguments is processed
  # map() distributes each value of its argument to a separate sub-target (branch)
  # so cross(randseed, map(partition)) will run each partition in a separate branch,
  # and each branch will run with each value of randseed
  pattern = cross(fvs_randseed, map(fvs_partition))
)
```

## Load Results

Carbon

```{targets cficop_none_carbon, tar_simple = TRUE}
fvs_read_output(cficop_none, "FVS_Carbon") |>
  group_by(StandID, Year) |> # Combine results from different random seeds
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    .groups = "keep"
  ) |>
  ungroup()
```

Summary

```{targets cficop_none_summary, tar_simple = TRUE}
fvs_read_output(cficop_none, "FVS_Summary2_East") |>
  group_by(StandID, Year) |>
  summarize(
    BA = mean(BA),
    Tpa = mean(Tpa),
    .groups = 'keep'
  ) |>
  ungroup()
```

## BA Over Time

```{r plot ba over time, eval = FALSE}
cficop_none_summary |>
  filter(Year %% 10 == 0) |>
#  group_by(Year) |>
#  summarize(BA = sum(BA) / n()) |>
#  ungroup() |>
  mutate(Series = "Projected") |>
  union_all(
    cfigro_srvy_summary |>
      filter(Year %% 10 == 0) |>
#      group_by(Year) |>
#      summarize(BA = sum(BA) / n()) |>
#      ungroup() |>
      mutate(Series = "Observed")
  ) |>
  mutate(
    Year = as.character(Year),
    BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")
  ) |>
  ggplot(aes(Year, BA, fill = Series)) +
  geom_boxplot(outlier.size = 0.5) +
  theme_bw() +
  ggtitle("CFI Grow-Only Projection") +
  ylab(bquote("Basal Area " ~ (m^2 %.% hectare^-1)))

```

## Carbon Over Time

```{r plot carbon over time, eval = FALSE}
cficop_none_carbon |>
#  group_by(Year) |>
#  summarize(Aboveground_Total_Live = sum(Aboveground_Total_Live) / n()) |>
#  ungroup() |>
  mutate(Series = paste0("Projection, n=", n_distinct(StandID))) |>
  union_all(
    cfigro_srvy_carbon |>
#      group_by(Year) |>
#      summarize(Aboveground_Total_Live = sum(Aboveground_Total_Live) / n()) |>
#      ungroup() |>
      mutate(Series = paste0("Reference, n=", n_distinct(StandID)))
  ) |>
  mutate(Year = as.character(Year)) |>
  ggplot(aes(Year, Aboveground_Total_Live, fill = Series)) +
  geom_boxplot(outlier.size = 0.5) +
  theme_bw() +
  ggtitle("CFI Grow-Only Projection") +
  ylab(bquote("Aboveground Live Carbon " ~ (`Mg C` %.% hectare^-1)))
```

## Error Model

We need:
cfigro_bai_task$select(
  c("Acer_rubrum", "LAT", "Pinus_strobus", "Projected_BA", "Projected_Tph", "Quercus_rubra", "SLOPE")
)

```{targets cficop_none_bai, tar_simple = TRUE}
tmp_top_species <- c("Acer rubrum", "Pinus strobus", "Quercus rubra")

tmp_species_cmp <- fvs_species_composition(cficop_none) |>
  filter(Year == 2020) |>
  mutate(SpeciesCode = as.numeric(SpeciesFIA)) |>
  # Combine black oak and red oak
  mutate(
    SpeciesCode = if_else(SpeciesCode == 837, 833, SpeciesCode)
  ) |>
  group_by(StandID, Year, SpeciesCode, random_seed) |>
  summarize(BA = sum(BA), TPA = sum(TPA), .groups = "drop") |>
  left_join(
    species_crosswalk |> select(SPCD, SCIENTIFIC_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    TPH = conv_unit(TPA, "hectare", "acre"),
    BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare"),
  )

tmp_by_plot <- tmp_species_cmp |>
  group_by(StandID, random_seed) |>
  summarize(
    TPA = sum(TPA),
    BA = sum(BA),
    .groups = "drop"
  )

# Top species by plot
# (only considering tmp_top_species)
tmp_plot_species <- tmp_species_cmp |>
  group_by(StandID, SCIENTIFIC_NAME, random_seed) |>
  summarize(BA = sum(BA), .groups = "drop") |>
  ungroup() |>
  left_join(
    tmp_by_plot |>
      select(StandID, random_seed, BA_Plot = BA),
    by = join_by(StandID, random_seed)
  ) |>
  mutate(BA_Frac = BA / BA_Plot) |>
  filter(SCIENTIFIC_NAME %in% tmp_top_species) |>
  mutate(
    SCIENTIFIC_NAME = sub(" ", "_", SCIENTIFIC_NAME)
  ) |>
  pivot_wider(
    id_cols = c("StandID", "random_seed"),
    names_from = SCIENTIFIC_NAME,
    values_from = BA_Frac,
    values_fill = 0
  )

# cficop_none_summary aggregates over random_seed; we need random_seed
# in the output.
tmp_none_summary <- fvs_read_output(cficop_none, "FVS_Summary2_East")

tmp_plot_starting_ba <- tmp_none_summary |>
  filter(Year == 1970) |>
  mutate(
    Starting_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare"),
    Starting_Tph = conv_unit(Tpa, "hectare", "acre")
  ) |>
  select(StandID, random_seed, Starting_BA, Starting_Tph)

tmp_plot_projected_ba <- tmp_none_summary |>
  filter(Year == 2020) |>
  mutate(
    Projected_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare"),
    Projected_Tph = conv_unit(Tpa, "hectare", "acre")
  ) |>
  select(StandID, random_seed, Projected_BA, Projected_Tph)

# cficop_none_carbon aggregates over random_seed; we need random_seed
# in the output.
tmp_none_carbon <- fvs_read_output(cficop_none, "FVS_Carbon")

tmp_plot_starting_carbon <- tmp_none_carbon |>
  filter(Year == 1970) |>
  rename(Starting_Carbon = Aboveground_Total_Live) |>
  select(StandID, random_seed, Starting_Carbon)

tmp_plot_projected_carbon <- tmp_none_carbon |>
  filter(Year == 2020) |>
  rename(Projected_Carbon = Aboveground_Total_Live) |>
  select(StandID, random_seed, Projected_Carbon)

cficop_none_bai <- tmp_plot_species |>
  left_join(
    cfigro_plot |>
      filter(INV_YEAR == 1970) |>
      mutate(StandID = as.character(STAND_ID)) |>
      select(StandID, LAT = LATITUDE, ASPECT, SLOPE, ELEV = ELEVFT),
    by = join_by(StandID)
  ) |>
  left_join(
    tmp_plot_starting_ba,
    by = join_by(StandID, random_seed)
  ) |>
  left_join(
    tmp_plot_projected_ba,
    by = join_by(StandID, random_seed)
  ) |>
  left_join(
    tmp_plot_starting_carbon,
    by = join_by(StandID, random_seed)
  ) |>
  left_join(
    tmp_plot_projected_carbon,
    by = join_by(StandID, random_seed)
  ) |>
  mutate(
    BAI_Error = cfigro_bai_model$predict_newdata(pick(everything()))$response,
    Carbon_Flux_Error = cfigro_aglcf_model$predict_newdata(pick(everything()))$response
  ) |>
  mutate(
    Projected_BAI = (Projected_BA - Starting_BA) / (2020 - 1970),
    Adjusted_BAI = Projected_BAI - BAI_Error,
    Projected_AGLCF = (Projected_Carbon - Starting_Carbon) / (2020 - 1970),
    Adjusted_AGLCF = Projected_AGLCF - Carbon_Flux_Error
  )
```

Plot it:

```{r plot cficop none bai, eval = FALSE}
cficop_none_bai |>
  rename(
    `FVS Projected` = Projected_BAI,
    `Corrected` = Adjusted_BAI
  ) |>
  pivot_longer(c("FVS Projected", "Corrected")) |>
  ggplot(aes(value, fill = name)) +
  geom_density(alpha = 0.5) +
  theme_bw() +
  scale_fill_discrete(name = "Series") +
  xlab(bquote("Basal Area Increment" ~ (m^2 %.% hectare^-1 %.% year^-1))) +
  ylab("Density") +
  ggtitle("CFI Quabbin All Plots 50 year BAI Projection")
```

```{r plot cficop none aglcf, eval = FALSE}
cficop_none_bai |>
  rename(
    `FVS Projected` = Projected_AGLCF,
    `Corrected` = Adjusted_AGLCF
  ) |>
  pivot_longer(c("FVS Projected", "Corrected")) |>
  ggplot(aes(value, fill = name)) +
  geom_density(alpha = 0.5) +
  theme_bw() +
  scale_fill_discrete(name = "Series") +
  xlab(bquote("Aboveground Live Carbon Flux" ~ (`Mg C` %.% hectare^-1 %.% year^-1))) +
  ylab("Density") +
  ggtitle("CFI Quabbin All Plots 50 year Aboveground Live Carbon Flux Projection")
```

## Error Distribution

```{r plot cficop error distribution, eval = FALSE}
cficop_none_bai |>
  mutate(Series = "Modeled") |>
  ggplot(aes(Carbon_Flux_Error, fill = Series)) +
  geom_density(alpha = 0.5) +
  geom_vline(xintercept = 0, color = "black", linewidth = 0.25) +
  theme_bw() +
  xlab(bquote("Aboveground Live Carbon Flux Residual" ~ (`Mg C` %.% ha^-1 %.% year^-1))) +
  ylab("Density") +
  scale_fill_brewer(palette="Set1") +
  ggtitle("Modeled AGL Carbon Flux Residual")
```


# CFICOP_DFLT

Like CFIGRO_NONE, but use default growth and mortality.

## Regeneration

Ignore plot-specificc regeneration. use a spatial average over the
first survey period to see how many trees of each species establish
in each plot.

Regeneration in Quabbin is fraught. Regen was suppressed in areas
from 1960 into the 1990s by excessive deer browse; hunting was
re-introduced in the 1990s to reduce the deer population.

### 1980 Model Year

Can we use trees that establish in the 1970-1980 cycle to represent
"what would a manager's perspective be on establishment in 1970?".

Start by finding all the trees that establish:

```{r cfiabp_estab, eval = FALSE}
cfiabp_estab <- qryDWSPCFIPlotVisitTreeDetail |>
  filter(VisitTreeStatusCode == 1) |>
  left_join(
    tblDWSPCFIPlotVisitsComplete |>
      select(MasterPlotID, VisitCycle, MasterPlotVisitID),
    by = join_by(MasterPlotVisitID)
  ) |>
  left_join( 
    tblDWSPCFITreesComplete |> select(MasterTreeID, SpeciesCode),
    by = join_by(MasterTreeID)
  ) |>
  inner_join(
    cfiabp_trees |>
      distinct(MasterPlotID, VisitCycle, MasterTreeID, StatusB),
    by = join_by(MasterPlotID, VisitCycle, MasterTreeID)
  ) |>
  filter(StatusB == "R")
```


### CFI Establishment By Year

Let's look at establishment rate - this will be how many trees
establish per 0.2 acre plot in a 10-year interval, on grow-only
plots.

```{r establisment rate, eval = FALSE}
cfiabp_estab |>
  left_join(
    cfigro_plot_harvested,
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    cfigro_plot_disturbed,
    by = join_by(MasterPlotID)
  ) |>
  filter(!CFIHarvested & !CFIDisturbed) |>
  group_by(MasterPlotID, VisitCycle) |>
  summarize(rate = n(), .groups = "keep") |>
  ungroup() |>
  # Convert rate to trees per acre per year
  mutate(rate = rate * 5 / 10) |>
  ggplot(aes(factor(VisitCycle), rate)) +
  geom_boxplot() +
  theme_bw() +
  ggtitle("Grow-Only Quabbin CFI Plot Establisment Rate") +
  ylab("New 5\"dbh trees per acre per year") +
  xlab("Inventory Year")
  
```

This says "no" - 1980 establishment rate is roughly 5x that of 2020.
1990 is still double.

```{r establishment per cycle, eval = FALSE}
cfiabp_estab |>
  left_join(
    cfigro_plot_harvested,
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    cfigro_plot_disturbed,
    by = join_by(MasterPlotID)
  ) |>
  filter(!CFIHarvested & !CFIDisturbed) |>
  group_by(MasterPlotID, VisitCycle) |>
  summarize(rate = n(), .groups = "keep") |>
  ungroup() |>
  mutate(rate = rate * 5 / 10) |>
  group_by(VisitCycle) |>
  summarize(rate = mean(rate))
```

### CFI Grow-Only Recruitment

Maybe we can use Hunt's data for seedling establishment. To do this,
we'd create a stems-per-acre NATURAL block that omits height; the
omission of height says these are seedlings, and FVS should figure
things out from there.

```{r establishment by species, eval = FALSE}
cfiabp_estab |>
  left_join(
    cfigro_plot_harvested,
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    cfigro_plot_disturbed,
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    species_crosswalk,
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(GENUS = if_else(GENUS == "Tree", "Other", GENUS)) |>
  filter(!CFIHarvested & !CFIDisturbed) |>
  mutate(GENUS = fct_lump(GENUS, n = 5, other_level = "Other")) |>
  ggplot(aes(VisitCycle, fill = GENUS, group = GENUS)) +
  geom_bar() +
  theme_bw() +
  ggtitle("Quabbin CFI Recruitment in Grow-Only Plots") +
  ylab("Number of Trees Recruited")
```

### CFI All Recruitment

```{r establishment by species in all plots, eval = FALSE}
cfiabp_estab |>
  left_join(
    cfigro_plot_harvested,
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    cfigro_plot_disturbed,
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    species_crosswalk,
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(GENUS = if_else(GENUS == "Tree", "Other", GENUS)) |>
#  filter(!CFIHarvested & !CFIDisturbed) |>
  mutate(GENUS = fct_lump(GENUS, n = 5, other_level = "Other")) |>
  ggplot(aes(VisitCycle, fill = GENUS, group = GENUS)) +
  geom_bar() +
  theme_bw() +
  ggtitle("Quabbin CFI Recruitment in All Plots") +
  ylab("Number of Trees Recruited")
```


### Fred Hunt's Table 13

Fred Hunt's 1961 Master's Thesis at UMass Amherst describes
a general rate of 254 stems of "establishment" per acre; we can use
this number, distributed according to his table 13, to set up 
background establishment.

Table 13.  Reproduction by Species

Here is a reproduction of Fred Hunt's table 13 showing reproduction in
1960, from Brian Keevan, personal communication, June 12 2025.

Keevan notes:
> "Note that Hunt decided to call anything from 3 foot tall to 4.9”
> diameter ‘reproduction’."

Hunt left some species unspecified; we substitute the most common
in Quabbin for these:
- Red maple = red maple
- Oak = northern red oak
- white pine = eastern white pine
- black birch = sweet birch
- white ash = white ash
- red pine = red pine
- other birch = paper birch
- other hardwoods = black cherry
- sugar maple = sugar maple
- spruce = red spruce

```{targets cficop_dflt_estab, tar_simple = TRUE}
tibble(
  Species = c(
    "White pine", "Hemlock", "Spruce", "Red Pine",
    "Sugar Maple", "Red maple", "Oak", "Black birch",
    "Other birch", "White ash", "Other hardwoods"
  ),
  Stems_Per_Acre = c(
    45, 13, 4, 10,
    8, 63, 54, 21,
    10, 16, 10
  ),
  Percent = c(
    10, 5, 2, 4,
    3, 25, 21, 8,
    4, 6, 4
  )
) |>
  mutate(
    SPCD = case_match(
      Species,
      "Red maple" ~ 316,
      "Oak" ~ 833,
      "White pine" ~ 129,
      "Black birch" ~ 372,
      "White ash" ~ 541,
      "Hemlock" ~ 261,
      "Red Pine" ~ 125,
      "Other birch" ~ 375,
      "Other hardwoods" ~ 762,
      "Sugar Maple" ~ 318,
      "Spruce" ~ 97
    )
  ) |>
  left_join(
    species_crosswalk |> select(SPCD, FVS_SPCD),
    by = join_by(SPCD)
  ) |>
  select(SPECIES = FVS_SPCD, DENSITY = Stems_Per_Acre) |>
  mutate(STAND_CN = NA, YEAR = NA) |>
  arrange(desc(DENSITY))
```

## Run FVS

This should be simple; there's no calibration.

```{targets cficop_dflt}
tar_target(
  cficop_dflt,
  {
    timestep <- 10 # years; determined by FVSne variant
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "CFICarbonOffsetProgram"
    mgmt_id <- "DFLT"
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = NULL,
      title = title,
      mgmt_id = mgmt_id,
      stands = cfigro_plot,
      trees = cfigro_trees,
      regen = cficop_dflt_estab,
      num_partitions = fvs_num_partitions,
      partition = fvs_partition,
      random_seed = fvs_randseed
    )
  },
  # iteration = "vector" branches execution for each partition value (see below)
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here.
  # cross() ensures that every combination of values for its arguments is processed
  # map() distributes each value of its argument to a separate sub-target (branch)
  # so cross(randseed, map(partition)) will run each partition in a separate branch,
  # and each branch will run with each value of randseed
  pattern = cross(fvs_randseed, map(fvs_partition))
)
```

## Load Results


Carbon

```{targets cficop_dflt_carbon, tar_simple = TRUE}
fvs_read_output(cficop_dflt, "FVS_Carbon") |>
  group_by(StandID, Year) |> # Combine results from different random seeds
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    .groups = "keep"
  ) |>
  ungroup()
```

Summary

```{targets cficop_dflt_summary, tar_simple = TRUE}
fvs_read_output(cficop_dflt, "FVS_Summary2_East") |>
  group_by(StandID, Year) |>
  summarize(
    BA = mean(BA),
    Tpa = mean(Tpa),
    .groups = 'keep'
  ) |>
  ungroup()
```



# CFICOP_SRVY

Look at how things actually grew, so we can compare to CFICOP_HVST.

## Run FVS

```{targets cficop_srvy}
tar_target(
  cficop_srvy,
  {
    visits <- cfiabp_trees |>
      distinct(MasterPlotID, VisitCycle) |>
      left_join(
        tblDWSPCFIPlotVisitsComplete |>
          select(MasterPlotID, VisitCycle, MasterPlotVisitID, VisitYear),
        by = join_by(MasterPlotID, VisitCycle)
      ) |>
      mutate(MasterPlotVisitID = as.character(MasterPlotVisitID)) |>
      select(
        STAND_CN = MasterPlotVisitID,
        STAND_ID = MasterPlotID,
        INV_YEAR = VisitYear
      )
    
    # Despite its name, cfigro_plot has all plots in it
    plots_for_fvs <- cfigro_plot |>
      select(-STAND_CN, -INV_YEAR) |>
      full_join(visits, by = join_by(STAND_ID)) |>
      mutate(FIRST_YEAR = INV_YEAR, LAST_YEAR = INV_YEAR)

    # No establishment for survey runs

    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "CFICarbonOffsetProgram"
    mgmt_id <- "SRVY"

    # We communicate with FVS through files. FVSOnline shows a model in which
    # a "project" (the inputs and outputs of a single FVS run) live in a
    # single directory; we follow that model.
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = NULL,
      title = title,
      mgmt_id = mgmt_id,
      stands = plots_for_fvs,
      trees = cfigro_trees,
      num_partitions = fvs_num_partitions,
      partition = fvs_partition
    )
  },
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here:
  pattern = map(fvs_partition)
)
```

## Load Results


Carbon

```{targets cficop_srvy_carbon, tar_simple = TRUE}
fvs_read_output(cficop_srvy, "FVS_Carbon") |>
  group_by(StandID, Year) |> # Combine results from different random seeds
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    .groups = "keep"
  ) |>
  ungroup()
```

Summary

```{targets cficop_srvy_summary, tar_simple = TRUE}
fvs_read_output(cficop_srvy, "FVS_Summary2_East") |>
  group_by(StandID, Year) |>
  summarize(
    BA = mean(BA),
    Tpa = mean(Tpa),
    .groups = 'keep'
  ) |>
  ungroup()
```




# CFICOP_HVST

Let's look at the distribution of harvest, and what we'll need to model.

## Observed Harvest

We're interested in a few things:

1. What trees get cut? (when / where / species / size / tpa)
2. What trees are left? (when / where / species / size / tpa)


```{r observed harvest ba}
tmp_observed_harvest <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  left_join(
    species_crosswalk |> select(SPCD, GENUS, SPECIES, COMMON_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    basal_area = (conv_unit(dbh_prior, "cm", "m") / 2)^2 * pi,
  ) |>
  # Replace na's in status to keep them from propagating
  replace_na(list(StatusB = "X", Status6 = "X")) |>
  filter(StatusB == "C" | Status6 == "B") |>
  filter(!is.na(basal_area)) |>
  group_by(VisitCycle) |>
  mutate(
    VisitCycle = paste0(VisitCycle, " (n=", n_distinct(MasterPlotID), ")")
  ) |>
  ungroup() |>
  mutate(
    GENUS = fct_lump_n(GENUS, n = 5, w = basal_area, other_level = "Other"),
    VisitCycle = ordered(VisitCycle)
  ) |>
  group_by(MasterPlotID, VisitCycle, GENUS) |>
  summarize(
    basal_area = sum(basal_area, na.rm = TRUE),
    tpa = n() * 5,
    .groups = "keep"
  ) |>
  ungroup()

tmp_observed_harvest |>
  ggplot(aes(VisitCycle, basal_area, fill = GENUS)) +
  geom_boxplot(outlier.size = 0.1) +
  coord_cartesian(ylim = c(0, 2)) +
  theme_bw() +
  scale_fill_manual(values = eves_colors) +
  ggtitle("Harvested BA Per Plot") +
  ylab(bquote("Harvested BA" ~ (m^2))) +
  xlab("Visit Cycle (Number of Plots Harvested)")

tmp_observed_harvest |>
  ggplot(aes(VisitCycle, tpa, fill = GENUS)) +
  geom_boxplot(outlier.size = 0.1) +
#  coord_cartesian(ylim = c(0, 2)) +
  theme_bw() +
  scale_fill_manual(values = eves_colors) +
  scale_y_continuous(transform = "log10") +
  ggtitle("Harvested TPA Per Plot") +
  ylab(bquote("Harvested TPA" ~ (trees %.% acre^-1))) +
  xlab("Visit Cycle (Number of Plots Harvested)")

```

## Who got left behind?

Unharvested:
- Filter to plot/cycles with harvest
- sum the ba of what's left

```{r observed unharvested ba}

# Which plots are harvested, in which visit cycles?

tmp_harvest_history <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_abp(cfiabp_trees) |>
  # cfi_harvested() |> # Can't use this, doesn't retain VisitCycle
  group_by(MasterPlotID, VisitCycle) |>
  summarize(
    CFIHarvested = any(CutSinceLastVisit, na.rm = TRUE),
    .groups = "drop"
  )

# What trees are left behind after harvest?

tmp_observed_remainders <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  left_join(tmp_harvest_history, by = join_by(MasterPlotID, VisitCycle)) |>
  filter(CFIHarvested) |>
  left_join(
    species_crosswalk |> select(SPCD, GENUS, SPECIES, COMMON_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    # Judgment: basal_area intended to be left in harvest is better
    # represented by ba PRIOR to harvest, than POST harvest. We don't
    # have BA at the time of harvest, which would be ideal.
    basal_area = (conv_unit(dbh_prior, "cm", "m") / 2)^2 * pi,
  ) |>
  # Replace na's in status to keep them from propagating
  replace_na(list(StatusB = "X", Status6 = "X")) |>
  # Live trees, not recruits
  filter(StatusB == "L" | Status6 == "L") |>
  filter(!is.na(basal_area)) |>
  group_by(VisitCycle) |>
  mutate(VisitCycle = paste0(VisitCycle, " (n=", n_distinct(MasterPlotID), ")")) |>
  ungroup() |>
  mutate(
    GENUS = fct_lump_n(GENUS, n = 5, w = basal_area, other_level = "Other"),
    VisitCycle = ordered(VisitCycle)
  ) |>
  group_by(MasterPlotID, VisitCycle, GENUS) |>
  summarize(
    basal_area = sum(basal_area, na.rm = TRUE),
    tpa = n() * 5,
    .groups = "keep"
  ) |>
  ungroup()

tmp_observed_remainders |>
  ggplot(aes(VisitCycle, basal_area, fill = GENUS)) +
  geom_boxplot(outlier.size = 0.1) +
  coord_cartesian(ylim = c(0, 2)) +
  theme_bw() +
  scale_fill_manual(values = eves_colors) +
  ggtitle("Unharvested BA Per Plot") +
  ylab(bquote("Unarvested BA" ~ (m^2))) +
  xlab("Visit Cycle (Number of Plots Harvested)")

tmp_observed_remainders |>
  ggplot(aes(VisitCycle, tpa, fill = GENUS)) +
  geom_boxplot(outlier.size = 0.1) +
  coord_cartesian(ylim = c(5, 100)) +
  theme_bw() +
  scale_fill_manual(values = eves_colors) +
#  scale_y_continuous(transform = "log10") +
  ggtitle("Unharvested TPA Per Plot") +
  ylab(bquote("Unarvested TPA" ~ (trees %.% acre^-1))) +
  xlab("Visit Cycle (Number of Plots Harvested)")

tmp_observed_remainders |>
  ggplot(aes(VisitCycle, tpa)) +
  geom_boxplot(outlier.size = 0.1) +
  coord_cartesian(ylim = c(1, 50)) +
  theme_bw() +
#  scale_fill_manual(values = eves_colors) +
#  scale_y_continuous(transform = "log10") +
  ggtitle("Unharvested TPA Per Plot") +
  ylab(bquote("Unarvested TPA" ~ (trees %.% acre^-1))) +
  xlab("Visit Cycle (Number of Plots Harvested)")

```

## Diameter Class

What's the distribution of trees left behind, by diameter class?

```{r harvest by diameter class}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  left_join(tmp_harvest_history, by = join_by(MasterPlotID, VisitCycle)) |>
  filter(CFIHarvested) |>
  left_join(
    species_crosswalk |> select(SPCD, GENUS, SPECIES, COMMON_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    # Judgment: basal_area intended to be left in harvest is better
    # represented by ba PRIOR to harvest, than POST harvest. We don't
    # have BA at the time of harvest, which would be ideal.
    basal_area = (conv_unit(dbh_prior, "cm", "m") / 2)^2 * pi,
    diameter_class = ordered(as.integer(conv_unit(dbh_prior, "cm", "in") / 5) * 5)
  ) |>
  # Replace na's in status to keep them from propagating
  replace_na(list(StatusB = "X", Status6 = "X")) |>
  # Live trees, not recruits
  filter(StatusB == "L" | StatusB == "R" | Status6 == "L" | Status6 == "R") |>
  filter(!is.na(diameter_class)) |>
  group_by(VisitCycle) |>
  mutate(VisitCycle = paste0(VisitCycle, " (n=", n_distinct(MasterPlotID), ")")) |>
  ungroup() |>
  group_by(MasterPlotID, VisitCycle, diameter_class) |>
  summarize(basal_area = sum(basal_area, na.rm = TRUE), .groups = "keep") |>
  ungroup() |>
  ggplot(aes(VisitCycle, basal_area, fill = diameter_class)) +
  geom_boxplot(outlier.size = 0.1) +
  coord_cartesian(ylim = c(0, 1)) +
  theme_bw() +
  scale_fill_discrete() +
  ggtitle("Unharvested BA Per Plot by 5\" diameter class") +
  ylab(bquote("Unharvested BA" ~ (m^2))) +
  xlab("Visit Cycle (Number of Plots Harvested)")
```


```{r remaining tpa by diameter class}
remaining_tpa_by_diameter_class <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  left_join(tmp_harvest_history, by = join_by(MasterPlotID, VisitCycle)) |>
  filter(CFIHarvested) |>
  left_join(
    species_crosswalk |> select(SPCD, GENUS, SPECIES, COMMON_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    # Judgment: basal_area intended to be left in harvest is better
    # represented by ba PRIOR to harvest, than POST harvest. We don't
    # have BA at the time of harvest, which would be ideal.
    basal_area = (conv_unit(dbh_prior, "cm", "m") / 2)^2 * pi,
    diameter_class = as.integer(conv_unit(dbh_prior, "cm", "in") / 2) * 2
  ) |>
  # Replace na's in status to keep them from propagating
  replace_na(list(StatusB = "X", Status6 = "X")) |>
  # Live trees, not recruits
  filter(StatusB == "L" | StatusB == "R" | Status6 == "L" | Status6 == "R") |>
  filter(!is.na(diameter_class)) |>
  filter(diameter_class <= 40) |>
  group_by(VisitCycle) |>
  mutate(VisitCycle = paste0(VisitCycle, " (n=", n_distinct(MasterPlotID), ")")) |>
  ungroup() |>
  group_by(MasterPlotID, VisitCycle, diameter_class) |>
  summarize(
    tpa = n() * 5, .groups = "keep"
  ) |>
  ungroup()

remaining_tpa_by_diameter_class |>
  mutate(
    VisitCycle = ordered(VisitCycle),
    diameter_class = ordered(diameter_class)
  ) |>
  ggplot(aes(VisitCycle, tpa, fill = diameter_class)) +
  geom_boxplot(outlier.size = 0.1) +
  coord_cartesian(ylim = c(5, 100)) +
  theme_bw() +
  scale_y_continuous(transform = "log2") +
  scale_fill_discrete() +
  ggtitle("Unharvested TPA Per Plot by 2\" diameter class") +
  ylab(bquote("Unharvested TPA" ~ (stems %.% acre^-1))) +
  xlab("Visit Cycle (Number of Plots Harvested)")

ideal_tpa_by_diameter_class <- tibble(
  diameter_class = seq(3, 35, 2),
  tpa = sapply(0:16, \(i) as.integer(42 / 1.4^i))
)


remaining_tpa_by_diameter_class |>
  ggplot(aes(diameter_class, tpa)) +
  geom_boxplot(
    aes(group = diameter_class),
    width = 0.7,
    outlier.size = 0.1
  ) +
  geom_step(
    data = ideal_tpa_by_diameter_class,
    color = "red"
  ) +
  scale_x_continuous(breaks = seq(2,40,2)) +
  coord_cartesian(xlim = c(6, 20), ylim = c(0, 100)) +
  annotate("text", x = 18, y = 0, label = "DBq, q=1.4", color = "red") +
  theme_bw() +
  ggtitle("Unharvested TPA Per Plot by 2\" diameter class") +
  ylab(bquote("Unharvested TPA" ~ (stems %.% acre^-1))) +
  xlab("Diameter Class")

```


```{r remaining tpa by diameter class}
remaining_tpa_by_diameter_class <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  left_join(tmp_harvest_history, by = join_by(MasterPlotID, VisitCycle)) |>
  filter(CFIHarvested) |>
  left_join(
    species_crosswalk |> select(SPCD, GENUS, SPECIES, COMMON_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    # Judgment: basal_area intended to be left in harvest is better
    # represented by ba PRIOR to harvest, than POST harvest. We don't
    # have BA at the time of harvest, which would be ideal.
    basal_area = (conv_unit(dbh_prior, "cm", "m") / 2)^2 * pi,
    diameter_class = as.integer(conv_unit(dbh_prior, "cm", "in") / 2) * 2
  ) |>
  # Replace na's in status to keep them from propagating
  replace_na(list(StatusB = "X", Status6 = "X")) |>
  # Live trees, not recruits
  filter(StatusB == "L" | StatusB == "R" | Status6 == "L" | Status6 == "R") |>
  filter(!is.na(diameter_class)) |>
  filter(diameter_class <= 40) |>
  group_by(VisitCycle) |>
  mutate(VisitCycle = paste0(VisitCycle, " (n=", n_distinct(MasterPlotID), ")")) |>
  ungroup() |>
  group_by(MasterPlotID, VisitCycle, diameter_class) |>
  summarize(
    tpa = n() * 5, .groups = "keep"
  ) |>
  ungroup()

starting_tpa <- remaining_tpa_by_diameter_class |>
  filter(diameter_class == 6) |>
  ungroup() |>
  select(MasterPlotID, VisitCycle, starting_tpa = tpa) |>
  mutate(
    starting_tpa = 25 * floor(starting_tpa / 25),
    tpa_class = if_else(
      starting_tpa < 75, as.character(starting_tpa),
      "75+"
    )
  )

ideal_tpa_by_diameter_class <- lapply(
  c(0, 25, 50, 75), \(x) {
    tibble(
      diameter_class = seq(5, 35, 2),
      tpa = sapply(0:15, \(i) as.integer((x + 12.5) / 1.4^i)),
      starting_tpa = x
    ) |>
      mutate(
        tpa_class = if_else(
          starting_tpa < 75, as.character(starting_tpa),
          "75+"
        )
      )
  }
) |>
  do.call(bind_rows, args = _)

remaining_tpa_by_diameter_class |>
  left_join(
    starting_tpa, by = join_by(MasterPlotID, VisitCycle)
  ) |>
  replace_na(list(tpa_class = "0")) |>
  mutate(group = paste(tpa_class, diameter_class)) |>
  ggplot(aes(diameter_class, tpa)) +
  geom_boxplot(
    aes(fill = tpa_class, group = group),
    outlier.size = 0.1
  ) +
  geom_step(
    data = ideal_tpa_by_diameter_class,
    aes(color = tpa_class),
    show.legend = FALSE
  ) +
  scale_x_continuous(breaks = seq(2,40,2)) +
  coord_cartesian(xlim = c(6, 20), ylim = c(0, 100)) +
  theme_bw() +
  labs(fill = "6\" TPA") +
  ggtitle("Unharvested TPA Per Plot by 2\" diameter class") +
  ylab(bquote("Unharvested TPA" ~ (stems %.% acre^-1))) +
  xlab("Diameter Class")
```

## Before / After Ratio

```{r harvest ratio by diameter class}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  left_join(tmp_harvest_history, by = join_by(MasterPlotID, VisitCycle)) |>
  filter(CFIHarvested) |>
  left_join(
    species_crosswalk |> select(SPCD, GENUS, SPECIES, COMMON_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    # Judgment: basal_area intended to be left in harvest is better
    # represented by ba PRIOR to harvest, than POST harvest. We don't
    # have BA at the time of harvest, which would be ideal.
    basal_area = (conv_unit(dbh_prior, "cm", "m") / 2)^2 * pi,
    diameter_class = ordered(as.integer(conv_unit(dbh_prior, "cm", "in") / 5) * 5)
  ) |>
  # Live trees, not recruits
  # Replace na's in status to keep them from propagating
  replace_na(list(StatusB = "X", Status6 = "X")) |>
  filter(
    StatusB == "L" | StatusB == "R" | StatusB == "C" |
      Status6 == "L" | Status6 == "R" | Status6 == "C"
  ) |>
  filter(!is.na(diameter_class)) |>
  group_by(VisitCycle) |>
  mutate(VisitCycle = paste0(VisitCycle, " (n=", n_distinct(MasterPlotID), ")")) |>
  ungroup() |>
  group_by(MasterPlotID, VisitCycle, diameter_class) |>
  summarize(
    pre_harvest_ba = sum(basal_area, na.rm = TRUE),
    harvested_ba = sum(if_else(StatusB == "C" | Status6 == "C", 0, basal_area), na.rm = TRUE),
    harvest_fraction = harvested_ba / pre_harvest_ba,
    .groups = "keep"
  ) |>
  ungroup() |>
  ggplot(aes(VisitCycle, harvest_fraction, fill = diameter_class)) +
  geom_boxplot(outlier.size = 0.1) +
  coord_cartesian(ylim = c(0, 1)) +
  theme_bw() +
  scale_fill_discrete() +
  ggtitle("Harvested BA Ratio Per Plot by 5\" diameter class") +
  ylab(bquote("Harvested BA" ~ (fraction))) +
  xlab("Visit Cycle (Number of Plots Harvested)")
```

```{r harvest ratio by genus}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  left_join(tmp_harvest_history, by = join_by(MasterPlotID, VisitCycle)) |>
  filter(CFIHarvested) |>
  left_join(
    species_crosswalk |> select(SPCD, GENUS, SPECIES, COMMON_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    # Judgment: basal_area intended to be left in harvest is better
    # represented by ba PRIOR to harvest, than POST harvest. We don't
    # have BA at the time of harvest, which would be ideal.
    basal_area = (conv_unit(dbh_prior, "cm", "m") / 2)^2 * pi
  ) |>
  # Replace na's in status to keep them from propagating
  replace_na(list(StatusB = "X", Status6 = "X")) |>
  # Live trees, not recruits
  filter(
    StatusB == "L" | StatusB == "R" | StatusB == "C" |
      Status6 == "L" | Status6 == "R" | Status6 == "C"
  ) |>
  filter(!is.na(basal_area)) |>
  group_by(VisitCycle) |>
  mutate(
    VisitCycle = paste0(VisitCycle, " (n=", n_distinct(MasterPlotID), ")")
  ) |>
  ungroup() |>
  mutate(
    VisitCycle = ordered(VisitCycle),
    GENUS = fct_lump_n(GENUS, n = 5, w = basal_area, other_level = "Other")
  ) |>
  group_by(MasterPlotID, VisitCycle, GENUS) |>
  summarize(
    pre_harvest_ba = sum(basal_area, na.rm = TRUE),
    harvested_ba = sum(if_else(StatusB == "C" | Status6 == "C", 0, basal_area), na.rm = TRUE),
    harvest_fraction = harvested_ba / pre_harvest_ba,
    .groups = "keep"
  ) |>
  ungroup() |>
  ggplot(aes(VisitCycle, harvest_fraction, fill = GENUS)) +
  geom_boxplot(outlier.size = 0.1) +
  coord_cartesian(ylim = c(0, 1)) +
  theme_bw() +
  scale_fill_manual(values = eves_colors) +
  ggtitle("Harvested BA Ratio Per Plot by Genus") +
  ylab(bquote("Harvested BA" ~ (fraction))) +
  xlab("Visit Cycle (Number of Plots Harvested)")
```

## Theoretical

```{r theoretical description of what's on the landscape}
x <- tibble(
  diameter_class = seq(6, 40, 2),
  tpa = sapply(0:17, \(i) as.integer(40 / 1.4^i))
)

x |>
  ggplot(aes(diameter_class, tpa)) +
  geom_line() +
  geom_point()
```

# Carbon on the Landscape

- Treat the 277 plots as a sample (by area?)
- For the sample, we can compute the Standard Error of the Mean (SEM) as:
  - SEM = s / sqrt(n)
    where s = sample standard deviation
    and   n = number of points in the sample
  - Note that if sample size > 5% of the population size, also apply
    Finite Population Correction (FPC), which says
  - SEM = s / sqrt(n) * (N - n) / (N - 1)
    where N = population size
- Then a 95% CI for the population mean is
  x_bar +/- (1.96 * SEM)
  where x_bar is the sample mean

What does this mean for total carbon on the landscape?

I think we just multiply the FVS projected vs. corrected AGLCF times years
times acres (converted to hectares).

from above, estimated 56816 forested acres; we have 277 * 0.2 = 55.4 acres,
so 0.1%

## Population Mean

So, let's look at distribution of biomass in our 277 plot sample:

```{r population_mean, eval = FALSE}
hectares <- conv_unit(56816, "acre", "hectare")

population_mean <- cficop_none_carbon |>
  rename(
    Projected_Carbon = Aboveground_Total_Live
  ) |>
  left_join(
    cficop_none_bai |>
      select(StandID, Starting_Carbon, Projected_Carbon, Adjusted_AGLCF) |>
      group_by(StandID) |>
      summarize(
        Starting_Carbon = min(Starting_Carbon),
        Adjusted_AGLCF = mean(Adjusted_AGLCF),
        .groups = "keep"
      ) |>
      ungroup(),
    by = join_by(StandID)
  ) |>
  mutate(
    Adjusted_Carbon = Starting_Carbon + Adjusted_AGLCF * (Year - 1970)
  ) |>
  group_by(Year) |>
  summarize(
    projected_carbon_mean = mean(Projected_Carbon),
    projected_carbon_sd = sd(Projected_Carbon),
    adjusted_carbon_mean = mean(Adjusted_Carbon),
    adjusted_carbon_sd = sd(Adjusted_Carbon),
    n = n(),
    .groups = "keep"
  ) |>
  ungroup() |>
  mutate(
    # convert sd to ci via 1.96 / sqrt(n)
    projected_carbon = projected_carbon_mean,
    projected_carbon_min = projected_carbon - projected_carbon_sd * 1.96 / sqrt(n),
    projected_carbon_max = projected_carbon + projected_carbon_sd * 1.96 / sqrt(n),
    adjusted_carbon = adjusted_carbon_mean,
    adjusted_carbon_min = adjusted_carbon - adjusted_carbon_sd * 1.96 / sqrt(n),
    adjusted_carbon_max = adjusted_carbon + adjusted_carbon_sd * 1.96 / sqrt(n)
  ) |>
  select(
    Year,
    projected_carbon, projected_carbon_min, projected_carbon_max,
    adjusted_carbon, adjusted_carbon_min, adjusted_carbon_max
  ) |>
  pivot_longer(-Year) |>
  mutate(
    value = value * hectares,
    group = if_else(grepl("projected", name), "projected", "adjusted"),
    kind  = if_else(grepl("_min", name), "min", if_else(grepl("_max", name), "max", "mean"))
  ) |>
  pivot_wider(id_cols = c("group", "Year"), names_from = "kind")
```

Plot it:
```{r plot population mean, eval = FALSE}
population_mean |>
  mutate(group = ordered(group, levels = c("projected", "adjusted"))) |>
  ggplot(aes(Year, mean)) +
  with_blur(
    geom_ribbon(aes(ymin = min, ymax = max, fill = group), alpha = 0.25),
    sigma = 3
    
  ) +
  geom_line(aes(color = group)) +
  coord_cartesian(ylim = c(0, NA)) +
  guides(
    color = guide_legend(order = 1),
    fill = guide_legend(order = 2)
  ) +
  theme_bw() +
  ggtitle("Projected vs. Measured Total Carbon, 0.1% sample") +
  ylab(bquote("Total Carbon" ~(`Mg C`))) +
  scale_color_discrete(name = "Estimated\nPopulation\nMean") +
  scale_fill_discrete(name = "95% CI")
```

```{r population mean values, eval = FALSE}
population_mean |>
  filter(Year == 1970 | Year == 2020) |>
  mutate(ci = mean - min) |>
  select(group, Year, mean, ci)
```

In 1970, there were 1170155 +- 57272 Mg C / ha
In 2020, projected was 2839915 +- 80259
In 2020, adjusted  was 2713476 +- 68425
2839915 - 2713476 = 126439,
126439 / 2839915 = 0.04452210718, so off by 4.5%

2713476 - 1170155 = 1543321 Mg C growth
126439 / 1543321 = 0.08192657263, so over-projects growth by 8%

## Calibrated vs Uncalibrated vs Observed

```{r none vs dflt vs srvy, eval = FALSE}
cficop_none_carbon |>
  rename(Calibrated = Aboveground_Total_Live) |>
  left_join(
    cficop_dflt_carbon |>
      rename(Uncalibrated = Aboveground_Total_Live),
    by = join_by(StandID, Year)
  ) |>
  left_join(
    cficop_srvy_carbon |>
      rename(Measured = Aboveground_Total_Live),
    by = join_by(StandID, Year)
  ) |>
  left_join(
    cficop_none_bai |>
      select(StandID, Starting_Carbon, Projected_Carbon, Adjusted_AGLCF) |>
      group_by(StandID) |>
      summarize(
        Starting_Carbon = min(Starting_Carbon),
        Adjusted_AGLCF = mean(Adjusted_AGLCF),
        .groups = "keep"
      ) |>
      ungroup(),
    by = join_by(StandID)
  ) |>
  mutate(
    Adjusted = Starting_Carbon + Adjusted_AGLCF * (Year - 1970)
  ) |>
  select(-c("Starting_Carbon", "Adjusted_AGLCF")) |>
  pivot_longer(-c("StandID", "Year")) |>
  union_all(
    cfigro_srvy_carbon |>
      select(StandID, Year, Reference = Aboveground_Total_Live) |>
      pivot_longer(-c("StandID", "Year"))
  ) |>
  group_by(Year, name) |>
  summarize(
    n = n(),
    mean = mean(value),
    ymin = mean(value) - 1.96 * sd(value) / sqrt(n),
    ymax = mean(value) + 1.96 * sd(value) / sqrt(n),
    .groups = "drop"
  ) |>
  mutate(name = ordered(
    name,
    levels = c("Uncalibrated", "Calibrated", "Adjusted", "Reference", "Measured")
  )) |>
  ggplot(aes(Year, mean, color = name)) +
  with_blur(
    geom_ribbon(aes(ymin = ymin, ymax = ymax, fill = name), alpha = 0.25),
    sigma = 3
    
  ) +
  geom_line() +
  geom_point() +
  theme_bw() +
  scale_color_discrete() +
  scale_fill_discrete() +
#  scale_y_continuous(limits = c(0, NA)) +
  ggtitle("Quabbin CFI Projected Carbon (277 stands)") +
  xlab("Year") +
  ylab(bquote("Aboveground Live Carbon" ~(`Mg C` %.% ha^-1)))
```

```{r none vs dflt vs srvy, eval = FALSE}
# Use a consistent, decent palette
colors <- brewer.set1(5)

cficop_none_carbon |>
  rename(Calibrated = Aboveground_Total_Live) |>
  left_join(
    cficop_dflt_carbon |>
      rename(Uncalibrated = Aboveground_Total_Live),
    by = join_by(StandID, Year)
  ) |>
  left_join(
    cficop_srvy_carbon |>
      rename(Measured = Aboveground_Total_Live),
    by = join_by(StandID, Year)
  ) |>
  left_join(
    cficop_none_bai |>
      select(StandID, Starting_Carbon, Projected_Carbon, Adjusted_AGLCF) |>
      group_by(StandID) |>
      summarize(
        Starting_Carbon = min(Starting_Carbon),
        Adjusted_AGLCF = mean(Adjusted_AGLCF),
        .groups = "keep"
      ) |>
      ungroup(),
    by = join_by(StandID)
  ) |>
  mutate(
    Adjusted = Starting_Carbon + Adjusted_AGLCF * (Year - 1970)
  ) |>
  select(-c("Starting_Carbon", "Adjusted_AGLCF")) |>
  pivot_longer(-c("StandID", "Year")) |>
  union_all(
    cfigro_srvy_carbon |>
      select(StandID, Year, Reference = Aboveground_Total_Live) |>
      pivot_longer(-c("StandID", "Year"))
  ) |>
  group_by(Year, name) |>
  summarize(
    n = n(),
    mean = mean(value),
    ymin = mean(value) - 1.96 * sd(value) / sqrt(n),
    ymax = mean(value) + 1.96 * sd(value) / sqrt(n),
    .groups = "drop"
  ) |>
  mutate(name = ordered(
    name,
    levels = c("Uncalibrated", "Calibrated", "Adjusted", "Reference", "Measured")
  )) |>
  filter(name %in% c(
    "Reference",
    "Measured",
    "Adjusted",
#    "Calibrated",
    "Uncalibrated"
  )) |>
  ggplot(aes(Year, mean, color = name)) +
  with_blur(
    geom_ribbon(aes(ymin = ymin, ymax = ymax, fill = name), alpha = 0.5),
    sigma = 3
  ) +
  # geom_ribbon(aes(ymin = ymin, ymax = ymax, fill = name), color = NA, alpha = 0.5) +
  geom_line() +
  geom_point() +
  theme_bw() +
  scale_color_manual(values = c(
    "Uncalibrated" = colors[1],
    "Calibrated" = colors[2],
    "Adjusted" = colors[3],
    "Reference" = colors[4],
    "Measured" = colors[5]
  )) +
  scale_fill_manual(values = c(
    "Uncalibrated" = colors[1],
    "Calibrated" = colors[2],
    "Adjusted" = colors[3],
    "Reference" = colors[4],
    "Measured" = colors[5]
  )) +
  scale_y_continuous(limits = c(40, 140)) +
  ggtitle("Quabbin CFI Projected Carbon (277 stands)") +
  xlab("Year") +
  ylab(bquote("Aboveground Live Carbon" ~(`Mg C` %.% ha^-1)))
```

Q: Why does "Reference" go above Calibrated in this picture, but originally it did not?

A: Because originally, we plotted the 31 plot Reference projection against
a 31 plot projection; now we have a 277 plot projection, and lo and
behold it is different!

## Diameter Distribution

Look at distribution of trees by diameter class across time.

Treelists are big (millions of trees), so we don't hold on to
the raw list.

```{r dimater class distribution, eval = FALSE}
add_diameter_class <- function(x) {
  x |>
    mutate(diameter_class = case_when(
      DBH < 3 ~ 0,
      DBH < 5 ~ 3,
      DBH < 9 ~ 5,
      DBH < 15 ~ 9,
      DBH < 21 ~ 15,
      DBH < 40 ~ 21,
      .default = 40
    )
}

fill_dbhlist <- function(x) {
  all_diameter_classes <- c(0, 3, 5, 9, 15, 21, 40)
  all_years <- unique(x$Year)
  all_stands <- unique(x$StandID)

  everything <- tibble(diameter_class = all_diameter_classes) |>
    cross_join(tibble(StandID = all_stands)) |>
    cross_join(tibble(Year = all_years))

  x |>
    full_join(everything, by = join_by(Year, diameter_class, StandID)) |>
    replace_na(list(tpa = 0))
}

cficop_none_dbhdist <- fvs_read_output(cficop_none, "FVS_TreeList_East") |>
  filter(Year %% 10 == 0) |>
  add_diameter_class() |>
  group_by(Year, diameter_class, StandID, random_seed) |>
  summarize(tpa = sum(TPA), .groups = "keep") |>
  group_by(Year, diameter_class, StandID) |>
  summarize(tpa = mean(tpa), .groups = "keep") |>
  ungroup() |>
  fill_dbhlist()

cficop_srvy_dbhdist <- fvs_read_output(cficop_srvy, "FVS_TreeList_East") |>
  filter(Year %% 10 == 0) |>
  add_diameter_class() |>
  group_by(Year, diameter_class, StandID, random_seed) |>
  summarize(tpa = sum(TPA), .groups = "keep") |>
  group_by(Year, diameter_class, StandID) |>
  summarize(tpa = mean(tpa), .groups = "keep") |>
  ungroup() |>
  fill_dbhlist()

cficop_dflt_dbhdist <- fvs_read_output(cficop_dflt, "FVS_TreeList_East") |>
  filter(Year %% 10 == 0) |>
  add_diameter_class() |>
  group_by(Year, diameter_class, StandID, random_seed) |>
  summarize(tpa = sum(TPA), .groups = "keep") |>
  group_by(Year, diameter_class, StandID) |>
  summarize(tpa = mean(tpa), .groups = "keep") |>
  ungroup() |>
  fill_dbhlist()

cfigro_srvy_dbhdist <- fvs_read_output(cfigro_none, "FVS_TreeList_East") |>
  filter(Year %% 10 == 0) |>
  add_diameter_class() |>
  group_by(Year, diameter_class, StandID, random_seed) |>
  summarize(tpa = sum(TPA), .groups = "keep") |>
  group_by(Year, diameter_class, StandID) |>
  summarize(tpa = mean(tpa), .groups = "keep") |>
  ungroup() |>
  fill_dbhlist()
```

```{r plot dbhdist, eval = FALSE}
all_dbhdist <- cficop_none_dbhdist |>
  rename(Adjusted = tpa) |>
  left_join(
    cficop_srvy_dbhdist |>
      rename(Measured = tpa),
    by = join_by(Year, diameter_class, StandID)
  ) |>
  left_join(
    cficop_dflt_dbhdist |>
      rename(Uncalibrated = tpa),
    by = join_by(Year, diameter_class, StandID)
  ) |>
  pivot_longer(-c(Year, diameter_class, StandID)) |>    
  union_all(
    cfigro_srvy_dbhdist |>
      rename(Reference = tpa) |>
      pivot_longer(-c(Year, diameter_class, StandID))
  ) |>
  mutate(name = ordered(
    name,
    levels = c("Uncalibrated", "Calibrated", "Adjusted", "Reference", "Measured")
  ))

all_dbhdist |>
  filter(diameter_class >= 5) |>
  mutate(diameter_class = factor(diameter_class)) |>
  ggplot(aes(diameter_class, value, fill = name)) +
  geom_boxplot(outlier.size = 0.1) +
#  scale_fill_manual(values = c(
#    "Uncalibrated" = colors[1],
#    "Calibrated" = colors[2],
#    "Adjusted" = colors[3],
#    "Reference" = colors[4],
#    "Measured" = colors[5]
#  )) +
  facet_wrap("Year") +
  coord_cartesian(ylim = c(0, 200)) +
  scale_fill_discrete() +
  theme_bw() +
  ggtitle("CFI Diameter Class Frequency by Plot") +
  xlab("Diameter Class (inches)") +
  ylab(bquote(trees %.% acre^-1))
```
