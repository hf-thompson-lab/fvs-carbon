---
title: "Nunery Keeton Revisited"
author: "Nikolaus Bates-Haus"
output:
  pdf_document: default
  html_document: default
editor_options:
  markdown:
    wrap: 72
---
# Setup

```{r setup, include=FALSE}
library(tidyverse)
library(reshape2) # melt()
library(RSQLite)
library(measurements) # conv_unit and conv_multiunit
library(maps)
library(pbapply) # Progress bar for long operations
options(scipen = 9) # Use integer notation for numbers under 9 digits
```

```{r source-functions}
source('R/functions.R')
```

## Use Cache

Some datasets take a long time to compute; these are normally cached and
read from cache. Set `USE_CACHE` to `FALSE` to re-compute everything, and
`TRUE` to use cached values if available.

```{r USE_CACHE}
USE_CACHE <- TRUE
```

## Species Crosswalk

Different systems use different ways of encoding species. Here's a single
crosswalk for them all.

```{r species_mixin}
species_mixin <- read_rds("data/intermediate/species_mixin.rds")
```

# Harvested Plots in the Northeast

Find all FIA plots that:

* are in the northeastern region, and
* use the modern plot design, and
* have at least 10 years of measurements, and
* are fully forested, and
* is not disturbed ("disturbed" is separate from harvest), and
* is harvested, and
* is not seeded, fertilized, herbicided, etc. post-harvest, and
* is measured both pre- and post-harvest, and
* have a single condition for the entire plot

```{r plot_harvested}
rds_file = "data/intermediate/plot_harvested.rds"
if (USE_CACHE & file.exists(rds_file)) {
  plot_harvested <- read_rds(rds_file)
} else {
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  
  harvest_mixin <- tbl(fia, 'TREE') |>
    filter(STATUSCD == 3) |>
    distinct(STATECD, COUNTYCD, PLOT, INVYR) |>
    union(
      tbl(fia, 'COND') |>
        filter((TRTCD1 == 10) | (TRTCD2 == 10) | (TRTCD3 == 10)) |>
        distinct(STATECD, COUNTYCD, PLOT, INVYR)
    ) |>
    mutate(HARVEST = 1) 
  
  fia_cond <- tbl(fia, 'COND') |>
    select(
      STATECD, COUNTYCD, PLOT, PLT_CN, CONDID, INVYR,
      COND_STATUS_CD, BALIVE, DSTRBCD1, DSTRBCD2, DSTRBCD3,
      TRTCD1, TRTYR1, TRTCD2, TRTYR2, TRTCD3, TRTYR3
    )
  
  fia_plot <- tbl(fia, 'PLOT') |>
    # Narrow and rename columns to facilitate join
    select(CN, DESIGNCD, SRV_CN, MEASYEAR, ECOSUBCD) |>
    rename(PLT_CN = CN)
  
  fia_plotgeom <- tbl(fia, 'PLOTGEOM') |>
    # Narrow and rename columns to facilitate join
    select(CN, FVS_VARIANT) |>
    rename(PLT_CN = CN)
  
  plot_harvested <- fia_cond |>
    left_join(fia_plot, by = join_by(PLT_CN)) |>
    left_join(fia_plotgeom, by = join_by(PLT_CN)) |>
    fvsne_plots_filter() |>
    modern_plots_filter() |>
    filter(INVYR >= 1999) |>
    long_measurement_filter() |>
    forested_plots_filter() |>
    single_condition_plots_filter() |>
    undisturbed_plots_filter() |>
    no_unnatural_regen_filter() |> 
    # harvested_plots_filter() |>
    left_join(harvest_mixin, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    # Special case:
    # - If a plot is harvested, AND
    # - the first harvest is also the first inventory, THEN
    # - we want to not process the first harvest as a harvest, BECAUSE
    # - we don't know which trees were on the plot prior to that,
    # - which means we can't figure out natural regen
    mutate(
      HARVEST = case_when(
        INVYR == min(INVYR, na.rm = TRUE) ~ 0,
        is.na(HARVEST) ~ 0,
        .default = HARVEST
      )
    ) |>
    ungroup() |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    mutate(NUM_HARVESTS = sum(HARVEST, na.rm = TRUE)) |>
    filter(NUM_HARVESTS > 0) |>
    ungroup() |>
    # measured_pre_post_harvest_filter() |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    mutate(
      MIN_MEASYEAR = min(MEASYEAR, na.rm = TRUE),
      MAX_MEASYEAR = max(MEASYEAR, na.rm = TRUE),
      MIN_HRVYR = min(if_else(HARVEST == 1, MEASYEAR, 9999), na.rm = TRUE),
      MAX_HRVYR = max(if_else(HARVEST == 1, MEASYEAR, 0), na.rm = TRUE),
    ) |> 
    filter(
      (MIN_MEASYEAR < MIN_HRVYR) &
      (MAX_MEASYEAR - MAX_HRVYR >= 10)
    ) |> 
    ungroup() |>
    distinct(STATECD, COUNTYCD, PLOT) |>
    collect()
  
  dbDisconnect(fia)
  remove(fia, fia_cond, fia_plot, fia_plotgeom)
  
  write_rds(plot_harvested, rds_file)
}

nrow(plot_harvested)
```

## Stand Stats

Fetch more info about these stands.

```{r stand_stats}
rds_file <- "data/intermediate/plot_harvested_stats.rds"
if (USE_CACHE & file.exists(rds_file)) {
  stand_stats <- read_rds(rds_file)
} else {
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  
  tree_mixin <- tbl(fia, 'TREE') |>
    select(STATECD, COUNTYCD, PLOT, CONDID, INVYR, DIA, CARBON_AG, TPA_UNADJ) |>
    group_by(STATECD, COUNTYCD, PLOT, CONDID, INVYR) |>
    summarize(
      CARBON_AG = sum(CARBON_AG, na.rm = TRUE),
      CPA = sum(CARBON_AG * TPA_UNADJ, na.rm = TRUE),
      BA_TREES = sum(if_else(DIA >= 1, TPA_UNADJ, 0), na.rm = TRUE),
      .groups = "keep"
    )
  
  harvest_mixin <- tbl(fia, 'TREE') |>
    filter(STATUSCD == 3) |>
    distinct(STATECD, COUNTYCD, PLOT, INVYR) |>
    union(
      tbl(fia, 'COND') |>
        filter((TRTCD1 == 10) | (TRTCD2 == 10) | (TRTCD3 == 10)) |>
        distinct(STATECD, COUNTYCD, PLOT, INVYR)
    ) |>
    mutate(HARVEST = 1) 

  cond_mixin <- tbl(fia, 'COND') |>
    semi_join(plot_harvested, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
    select(
      STATECD, COUNTYCD, PLOT, INVYR, STDAGE, BALIVE, FORTYPCD
    ) |>
    group_by(STATECD, COUNTYCD, PLOT, INVYR) |>
    summarize(
      BALIVE = sum(BALIVE, na.rm = TRUE),
      FORTYPCD = max(FORTYPCD, na.rm = TRUE),
      STDAGE = max(STDAGE, na.rm = TRUE),
      .groups = "keep"
    ) |>
    ungroup() |>
    left_join(harvest_mixin, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    mutate(
      HARVEST = case_when(
        INVYR == min(INVYR, na.rm = TRUE) ~ 0,
        is.na(HARVEST) ~ 0,
        .default = HARVEST
      )
    ) |>
    ungroup()
  
  forest_type_mixin <- tbl(fia, 'REF_FOREST_TYPE') |>
    select(VALUE, MEANING) |>
    rename(FORTYPCD = VALUE) |>
    rename(FORTYPE = MEANING)
  
  # research station has state name and abbreviation
  state_mixin <- tbl(fia, 'REF_RESEARCH_STATION') |>
    distinct(STATECD, STATE_NAME, STATE_ABBR)
  
  stand_stats <- tbl(fia, 'PLOT') |>
    semi_join(plot_harvested, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
    filter(INVYR >= 1999) |>
    select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR, DESIGNCD, ECOSUBCD, LAT, LON) |>
    left_join(tree_mixin, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    left_join(cond_mixin, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    left_join(forest_type_mixin, by = join_by(FORTYPCD)) |>
    rename(`Forest Type` = FORTYPE) |>
    mutate(FORTYPCD = floor(FORTYPCD / 10) * 10) |>
    left_join(forest_type_mixin, by = join_by(FORTYPCD)) |>
    rename(`Forest Type Group` = FORTYPE) |>
    left_join(state_mixin, by = join_by(STATECD)) |>
    collect() |>
    rename(
      long = LON,
      lat = LAT
    ) |>
    mutate(
      `Forest Type Group` = str_replace(`Forest Type Group`, ' group', ''),
      BALIVE_METRIC = conv_multiunit(BALIVE, "ft2 / acre", "m2 / hectare"),
      QMD = sqrt(BALIVE / (BA_TREES * (pi / 576))),
      QMD_METRIC = sqrt(BALIVE_METRIC / (BA_TREES * (pi / 40000))),
      CARBON_METRIC = conv_multiunit(CPA, "lbs / acre", "Mg / hectare"),
      # If we're just stripping off subregion, could also do this as
      #   substr(ECOSUBCD, 1, nchar(ECOSUBCD) - 1)
      # but using sub() gives us more flexibility.
      ECOCD = sub(
        x = ECOSUBCD,
        # M? - Mountain
        # \d+ - Region
        # [A-Z] - Ecoregion
        # [a-z] - Ecosubregion
        pattern = "(M?)(\\d+)([A-Z])([a-z])",
        replacement = "\\1\\2\\3"
      )
    ) |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    arrange(INVYR) |>
    mutate(
      INVNUM = row_number(),
      BALIVE_START = if_else(row_number() == 1, BALIVE_METRIC, NA),
      MIN_MEASYEAR = min(MEASYEAR, na.rm = TRUE)
    ) |> 
    ungroup() |>
    arrange(STATECD, COUNTYCD, PLOT, INVYR) |>
    fill(BALIVE_START) |>
    mutate(
      BALIVE_DELTA = BALIVE_METRIC - BALIVE_START,
      YEARS = MEASYEAR - MIN_MEASYEAR,
      group = sprintf('%02d%03d%05d', STATECD, COUNTYCD, PLOT)
    )

  # Figure out which inventories are pre-harvest
  pre_harvest_mixin <- stand_stats |>
    filter(HARVEST == 1) |>
    mutate(INVNUM = INVNUM - 1) |> # the inventory prior to harvest is pre-harvest
    rename(PRE_HARVEST = HARVEST) |>
    select(STATECD, COUNTYCD, PLOT, INVNUM, PRE_HARVEST)
  
  stand_stats <- stand_stats |>
    left_join(pre_harvest_mixin, by = join_by(STATECD, COUNTYCD, PLOT, INVNUM)) |>
    mutate(
      PRE_HARVEST = if_else(is.na(PRE_HARVEST), 0, PRE_HARVEST)
    )
  
  dbDisconnect(fia)
  remove(fia, cond_mixin, forest_type_mixin, tree_mixin, state_mixin, pre_harvest_mixin)
  
  write_rds(stand_stats, rds_file)
}
```

## Stand Locations

Where are they?

```{r fvsne_states}
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

fvs_variant_mixin <- tbl(fia, 'PLOTGEOM') |>
  # Narrow and rename columns to facilitate join
  select(CN, FVS_VARIANT)

# research station has state name and abbreviation
state_mixin <- tbl(fia, 'REF_RESEARCH_STATION') |>
  distinct(STATECD, STATE_NAME, STATE_ABBR)

fvsne_states <- tbl(fia, 'PLOT') |>
  left_join(fvs_variant_mixin, by = join_by(CN)) |>
  fvsne_plots_filter() |>
  distinct(STATECD) |>
  left_join(state_mixin, by = join_by(STATECD)) |>
  mutate(region = str_to_lower(STATE_NAME)) |>
  collect()

remove(fia, fvs_variant_mixin, state_mixin)
```

```{r map_by_ecoregion}
map_data('state', fvsne_states$region) |> 
  ggplot(aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(
    data = stand_stats |>
      group_by(STATECD, COUNTYCD, PLOT) |>
      filter(row_number() == 1),
    aes(color = ECOCD)
  ) +
  coord_quickmap() +
  theme_bw() +
  scale_color_discrete(name = "Ecoregion")
```

> TODO nik: in FVS_TreeInit_Plot, column PRESCRIPTION FLOAT is used for ThinPRSC.
> Should be able to identify in which year a tree is harvested and put the year
> in PRESCRIPTION, then run with a ThinPRSC to remove the trees prescribed for
> each year.

> NB: ThinPRSC valid range is 2-9 - so this can NOT be the year in which to thin.
> It needs to be a harvest number (+1)

> Will need to find the database and modify it in-place.
> Good news: TREE_CN is TREE.CN (and, presumably, PLOT_CN is PLOT.CN, etc)
> Can a tree be indirectly harvested, e.g. TPA_UNADJ is reduced?
> Since the SQL Query to fetch trees is in the keyword file, we should
> be able to modify that query to add PRESCRIPTION as needed.
```{sql}
with v as (values
  (3181625010661, 2006),
  (3181626010661, 2007)
)
select
  TREE_CN,
  COALESCE(tree.PRESCRIPTION, v.column2) AS PRESCRIPTION
FROM FVS_TreeInit_Plot tree
LEFT JOIN v ON tree.TREE_CN = v.column1
LIMIT 3;
```

```
TREE_CN|PRESCRIPTION
3181625010661|2006
3181626010661|2007
3181627010661|
```

EXCEPT:
From FVS's DBSUserGuide, sectino 4.3 Stand and Tree Initialization:
> The maximum length of the SQL statement is set at 5000 characters

...which is not going to be enough.

Next up: use ATTACH DATABASE 'harvest_prescriptions.db' AS prsc;

# Harvested Trees

Find the trees that were removed during harvest.

Note that FIA.TREE.STATUSCD == 3 indicates that a tree has been harvested,
but not all harvested trees have STATUSCD == 3. Therefore we approximate
harvested trees by finding all trees that exist in a pre-harvest inventory,
but do not exist (or are marked as harvested) in the corresponding harvest
inventory.

TODO:

✔️ Convert harvest years to per-plot harvest numbers
✔ join harvest number on to tree
✔ data validation: were all trees harvested in a harvest?
  ? there are about 20 standing dead trees that are subsequently harvested;
    given that there are so few, I'm going to not worry about them
    and treat them the same as live trees that are harvested
→ create a dataframe with tree_cn and prescription
* write out the prescription table

## Trees removed in harvest

Fetch trees that were live pre-harvest, that are neither live nor dead
post-harvest.

```{r trees_removed_in_harvest}
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

trees_in_harvested_plots <- tbl(fia, "TREE") |>
  semi_join(
    stand_stats |> filter(HARVEST == 1),
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR),
    copy = TRUE
  ) |>
  filter(STATUSCD == 1 | STATUSCD == 2) |> # live and dead trees are still there
  select(STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR, STATUSCD) |>
  collect() |>
  left_join(
    stand_stats |> select(STATECD, COUNTYCD, PLOT, INVYR, INVNUM),
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
  ) |>
  mutate(
    INVNUM = INVNUM - 1
  )

trees_in_pre_harvest_plots <- tbl(fia, "TREE") |>
  semi_join(
    stand_stats |> filter(PRE_HARVEST == 1),
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR),
    copy = TRUE
  ) |>
  filter(STATUSCD == 1 | STATUSCD == 2) |> # only live trees
  select(STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR, STATUSCD) |>
  collect() |>
  left_join(
    stand_stats |> select(STATECD, COUNTYCD, PLOT, INVYR, INVNUM),
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
  )

trees_removed_in_harvest <- trees_in_pre_harvest_plots |>
  anti_join(
    trees_in_harvested_plots,
    by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE, INVNUM)
  )

DBI::dbDisconnect(fia)

remove(fia)#, trees_in_harvested_plots, trees_in_pre_harvest_plots)
```

Fetch trees that FIA says were harvested.

```{r fia_tree_harvested}
rds_file <- "data/intermediate/tree_harvested.rds"
if (USE_CACHE & file.exists(rds_file)) {
  tree_harvested <- read_rds(rds_file)
} else {
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  
  plot_mixin <- tbl(fia, 'PLOT') |>
    select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR)
    
  tree_harvested <- tbl(fia, 'TREE') |>
    semi_join(
      stand_stats |> filter(HARVEST == 1),
      by = join_by(STATECD, COUNTYCD, PLOT, INVYR),
      copy = TRUE
    ) |>
    select(CN, STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR, STATUSCD) |>
    filter(STATUSCD == 3) |>
    left_join(plot_mixin, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    collect()
  
  DBI::dbDisconnect(fia)
  
  remove(fia, plot_mixin)
  
  write_rds(tree_harvested, rds_file)
}
```

Did we correctly find all the trees that FIA says were harvested?
```{r validate_harvested_tree_method}
trees_harvested_but_not_removed <- tree_harvested |>
  anti_join(trees_removed_in_harvest, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE))
```

Do all harvested plots have harvested trees?
```{r}
View(plot_harvested |>
  left_join(
    trees_removed_in_harvest |>
      group_by(STATECD, COUNTYCD, PLOT) |>
      summarize(N = n(), .groups = "keep") |>
      ungroup(),
    join_by(STATECD, COUNTYCD, PLOT)
  ) |> filter(is.na(N) | (N < 1)))
```

When running FVS, we will need:

* CutList / CutLiDB - list of trees harvested
* TreeList / TreeLiDB - list of trees; probably we want cycle 0 captured
* ATrtList / ATrtLiDB - After treatment (post treelist, pre harvest) tree list


Example of how to write to a database table:
```{r}
harvest_prescriptions <- DBI::dbConnect(RSQLite::SQLite(), 'data/fvs/harvest_prescriptions.db')
DBI::dbWriteTable(harvest_prescriptions, 'PRSC', tree_harvested)
DBI::dbDisconnect(harvest_prescriptions)
```
