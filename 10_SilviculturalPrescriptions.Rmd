---
title: "Nunery Keeton Revisited"
author: "Nikolaus Bates-Haus"
output:
  pdf_document: default
  html_document: default
editor_options:
  markdown:
    wrap: 72
---
# Setup

```{r setup, include=FALSE}
library(tidyverse)
library(reshape2) # melt()
library(RSQLite)
library(measurements) # conv_unit and conv_multiunit
library(maps)
library(pbapply) # Progress bar for long operations
options(scipen = 9) # Use integer notation for numbers under 9 digits
```

```{r source-functions}
source('R/functions.R')
```

## Use Cache

Some datasets take a long time to compute; these are normally cached and
read from cache. Set `USE_CACHE` to `FALSE` to re-compute everything, and
`TRUE` to use cached values if available.

```{r USE_CACHE}
USE_CACHE <- TRUE
```

## Species Crosswalk

Different systems use different ways of encoding species. Here's a single
crosswalk for them all.

```{r species_mixin}
species_mixin <- read_rds("data/intermediate/species_mixin.rds")
```

# Harvested Plots in the Northeast

Find all FIA plots that:

* are in the northeastern region, and
* use the modern plot design, and
* have at least 10 years of measurements, and
* are fully forested, and
* is not disturbed ("disturbed" is separate from harvest), and
* is harvested, and
* is not seeded, fertilized, herbicided, etc. post-harvest, and
* is measured both pre- and post-harvest, and
* have a single condition for the entire plot

```{r plot_harvested}
rds_file = "data/intermediate/plot_harvested.rds"
if (USE_CACHE & file.exists(rds_file)) {
  plot_harvested <- read_rds(rds_file)
} else {
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  
  harvest_mixin <- tbl(fia, 'TREE') |>
    filter(STATUSCD == 3) |>
    distinct(STATECD, COUNTYCD, PLOT, INVYR) |>
    union(
      tbl(fia, 'COND') |>
        filter((TRTCD1 == 10) | (TRTCD2 == 10) | (TRTCD3 == 10)) |>
        distinct(STATECD, COUNTYCD, PLOT, INVYR)
    ) |>
    mutate(HARVEST = 1) 
  
  fia_cond <- tbl(fia, 'COND') |>
    select(
      STATECD, COUNTYCD, PLOT, PLT_CN, CONDID, INVYR,
      COND_STATUS_CD, BALIVE, DSTRBCD1, DSTRBCD2, DSTRBCD3,
      TRTCD1, TRTYR1, TRTCD2, TRTYR2, TRTCD3, TRTYR3
    )
  
  fia_plot <- tbl(fia, 'PLOT') |>
    # Narrow and rename columns to facilitate join
    select(CN, DESIGNCD, SRV_CN, MEASYEAR, ECOSUBCD) |>
    rename(PLT_CN = CN)
  
  fia_plotgeom <- tbl(fia, 'PLOTGEOM') |>
    # Narrow and rename columns to facilitate join
    select(CN, FVS_VARIANT) |>
    rename(PLT_CN = CN)
  
  plot_harvested <- fia_cond |>
    left_join(fia_plot, by = join_by(PLT_CN)) |>
    left_join(fia_plotgeom, by = join_by(PLT_CN)) |>
    fvsne_plots_filter() |>
    modern_plots_filter() |>
    filter(INVYR >= 1999) |>
    long_measurement_filter() |>
    forested_plots_filter() |>
    single_condition_plots_filter() |>
    undisturbed_plots_filter() |>
    no_unnatural_regen_filter() |> 
    # harvested_plots_filter() |>
    left_join(harvest_mixin, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    # Special case:
    # - If a plot is harvested, AND
    # - the first harvest is also the first inventory, THEN
    # - we want to not process the first harvest as a harvest, BECAUSE
    # - we don't know which trees were on the plot prior to that,
    # - which means we can't figure out natural regen
    mutate(
      HARVEST = case_when(
        INVYR == min(INVYR, na.rm = TRUE) ~ 0,
        is.na(HARVEST) ~ 0,
        .default = HARVEST
      )
    ) |>
    ungroup() |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    mutate(NUM_HARVESTS = sum(HARVEST, na.rm = TRUE)) |>
    filter(NUM_HARVESTS > 0) |>
    ungroup() |>
    # measured_pre_post_harvest_filter() |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    mutate(
      MIN_MEASYEAR = min(MEASYEAR, na.rm = TRUE),
      MAX_MEASYEAR = max(MEASYEAR, na.rm = TRUE),
      MIN_HRVYR = min(if_else(HARVEST == 1, MEASYEAR, 9999), na.rm = TRUE),
      MAX_HRVYR = max(if_else(HARVEST == 1, MEASYEAR, 0), na.rm = TRUE),
    ) |> 
    filter(
      (MIN_MEASYEAR < MIN_HRVYR) &
      (MAX_MEASYEAR - MAX_HRVYR >= 10)
    ) |> 
    ungroup() |>
    distinct(STATECD, COUNTYCD, PLOT) |>
    collect()
  
  DBI::dbDisconnect(fia)
  remove(fia, fia_cond, fia_plot, fia_plotgeom)
  
  write_rds(plot_harvested, rds_file)
}

nrow(plot_harvested)
```

## Stand Stats

Fetch more info about these stands.

```{r stand_stats}
rds_file <- "data/intermediate/plot_harvested_stats.rds"
if (USE_CACHE & file.exists(rds_file)) {
  stand_stats <- read_rds(rds_file)
} else {
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  
  tree_mixin <- tbl(fia, 'TREE') |>
    select(STATECD, COUNTYCD, PLOT, CONDID, INVYR, DIA, CARBON_AG, TPA_UNADJ) |>
    group_by(STATECD, COUNTYCD, PLOT, CONDID, INVYR) |>
    summarize(
      CARBON_AG = sum(CARBON_AG, na.rm = TRUE),
      CPA = sum(CARBON_AG * TPA_UNADJ, na.rm = TRUE),
      BA_TREES = sum(if_else(DIA >= 1, TPA_UNADJ, 0), na.rm = TRUE),
      .groups = "keep"
    )
  
  harvest_mixin <- tbl(fia, 'TREE') |>
    semi_join(plot_harvested, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
    filter(STATUSCD == 3) |>
    distinct(STATECD, COUNTYCD, PLOT, INVYR) |>
    mutate(HARVEST_TREE = TRUE) |>
    full_join(
      tbl(fia, 'COND') |>
        semi_join(plot_harvested, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
        filter((TRTCD1 == 10) | (TRTCD2 == 10) | (TRTCD3 == 10)) |>
        distinct(STATECD, COUNTYCD, PLOT, INVYR) |>
        mutate(HARVEST_COND = TRUE),
      by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
    ) |>
    mutate(HARVEST = TRUE)
  
  trtyr_mixin <- tbl(fia, "COND") |>
    semi_join(plot_harvested, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
    select(
      STATECD, COUNTYCD, PLOT, INVYR,
      TRTCD1, TRTYR1, TRTCD2, TRTYR2, TRTCD3, TRTYR3
    ) |>
    # If harvest is performed in multiple years, we can't know which trees
    # were harvested in which year. In theory, this would be in MORTYR, but
    # 1 in 5000 harvested tree records has MORTYR filled in. Therefore, we
    # retain only the latest harvest year - this will be pessimistic with
    # respect to regeneration.
    mutate(
      TRTYR1 = if_else(TRTCD1 == 10, TRTYR1, NA),
      TRTYR2 = if_else(TRTCD2 == 10, TRTYR2, NA),
      TRTYR3 = if_else(TRTCD3 == 10, TRTYR3, NA),
      TRTYR = case_when(
        !is.na(TRTYR3) ~ TRTYR3,
        !is.na(TRTYR2) ~ TRTYR2,
        .default = TRTYR1
      )
    ) |>
    select(STATECD, COUNTYCD, PLOT, INVYR, TRTYR) |>
    filter(!is.na(TRTYR)) |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    arrange(TRTYR) |>
    mutate(TRTNUM = row_number()) |>
    ungroup()

  cond_mixin <- tbl(fia, 'COND') |>
    semi_join(plot_harvested, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
    select(
      STATECD, COUNTYCD, PLOT, INVYR, STDAGE, BALIVE, FORTYPCD
    ) |>
    group_by(STATECD, COUNTYCD, PLOT, INVYR) |>
    summarize(
      BALIVE = sum(BALIVE, na.rm = TRUE),
      FORTYPCD = max(FORTYPCD, na.rm = TRUE),
      STDAGE = max(STDAGE, na.rm = TRUE),
      .groups = "keep"
    ) |>
    ungroup() |>
    left_join(harvest_mixin, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    mutate(
      HARVEST = case_when(
        INVYR == min(INVYR, na.rm = TRUE) ~ FALSE,
        is.na(HARVEST) ~ FALSE,
        .default = HARVEST
      ),
      HARVEST_TREE = if_else(!is.na(HARVEST_TREE), HARVEST_TREE, FALSE),
      HARVEST_COND = if_else(!is.na(HARVEST_COND), HARVEST_COND, FALSE),
    ) |>
    ungroup()
  
  forest_type_mixin <- tbl(fia, 'REF_FOREST_TYPE') |>
    select(VALUE, MEANING) |>
    rename(FORTYPCD = VALUE) |>
    rename(FORTYPE = MEANING)
  
  # research station has state name and abbreviation
  state_mixin <- tbl(fia, 'REF_RESEARCH_STATION') |>
    distinct(STATECD, STATE_NAME, STATE_ABBR)
  
  stand_stats <- tbl(fia, 'PLOT') |>
    semi_join(plot_harvested, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
    filter(INVYR >= 1999) |>
    select(CN, STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR, DESIGNCD, ECOSUBCD, LAT, LON) |>
    left_join(tree_mixin, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    left_join(cond_mixin, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    left_join(trtyr_mixin, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    left_join(forest_type_mixin, by = join_by(FORTYPCD)) |>
    rename(`Forest Type` = FORTYPE) |>
    mutate(FORTYPCD = floor(FORTYPCD / 10) * 10) |>
    left_join(forest_type_mixin, by = join_by(FORTYPCD)) |>
    rename(`Forest Type Group` = FORTYPE) |>
    left_join(state_mixin, by = join_by(STATECD)) |>
    collect() |>
    rename(
      long = LON,
      lat = LAT
    ) |>
    mutate(
      `Forest Type Group` = str_replace(`Forest Type Group`, ' group', ''),
      BALIVE_METRIC = conv_multiunit(BALIVE, "ft2 / acre", "m2 / hectare"),
      QMD = sqrt(BALIVE / (BA_TREES * (pi / 576))),
      QMD_METRIC = sqrt(BALIVE_METRIC / (BA_TREES * (pi / 40000))),
      CARBON_METRIC = conv_multiunit(CPA, "lbs / acre", "Mg / hectare"),
      # If we're just stripping off subregion, could also do this as
      #   substr(ECOSUBCD, 1, nchar(ECOSUBCD) - 1)
      # but using sub() gives us more flexibility.
      ECOCD = sub(
        x = ECOSUBCD,
        # M? - Mountain
        # \d+ - Region
        # [A-Z] - Ecoregion
        # [a-z] - Ecosubregion
        pattern = "(M?)(\\d+)([A-Z])([a-z])",
        replacement = "\\1\\2\\3"
      )
    ) |>
    group_by(STATECD, COUNTYCD, PLOT) |>
    arrange(INVYR) |>
    mutate(
      INVNUM = row_number(),
      BALIVE_START = if_else(row_number() == 1, BALIVE_METRIC, NA),
      MIN_MEASYEAR = min(MEASYEAR, na.rm = TRUE),
      STAND_CN = if_else(row_number() == 1, CN, NA)
    ) |> 
    ungroup() |>
    arrange(STATECD, COUNTYCD, PLOT, INVYR) |>
    fill(BALIVE_START, STAND_CN) |>
    mutate(
      BALIVE_DELTA = BALIVE_METRIC - BALIVE_START,
      YEARS = MEASYEAR - MIN_MEASYEAR,
      group = sprintf('%02d%03d%05d', STATECD, COUNTYCD, PLOT)
    )

  # Figure out which inventories are pre-harvest
  pre_harvest_mixin <- stand_stats |>
    filter(HARVEST == 1) |>
    mutate(INVNUM = INVNUM - 1) |> # the inventory prior to harvest is pre-harvest
    rename(PRE_HARVEST = HARVEST) |>
    select(STATECD, COUNTYCD, PLOT, INVNUM, PRE_HARVEST)
  
  stand_stats <- stand_stats |>
    left_join(pre_harvest_mixin, by = join_by(STATECD, COUNTYCD, PLOT, INVNUM)) |>
    mutate(
      PRE_HARVEST = if_else(is.na(PRE_HARVEST), 0, PRE_HARVEST)
    )
  
  DBI::dbDisconnect(fia)
  remove(fia, cond_mixin, trtyr_mixin, forest_type_mixin, tree_mixin,
         state_mixin, pre_harvest_mixin, harvest_mixin)
  
  write_rds(stand_stats, rds_file)
}
```

## Stand Locations

Where are they?

```{r fvsne_states}
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

fvs_variant_mixin <- tbl(fia, 'PLOTGEOM') |>
  # Narrow and rename columns to facilitate join
  select(CN, FVS_VARIANT)

# research station has state name and abbreviation
state_mixin <- tbl(fia, 'REF_RESEARCH_STATION') |>
  distinct(STATECD, STATE_NAME, STATE_ABBR)

fvsne_states <- tbl(fia, 'PLOT') |>
  left_join(fvs_variant_mixin, by = join_by(CN)) |>
  fvsne_plots_filter() |>
  distinct(STATECD) |>
  left_join(state_mixin, by = join_by(STATECD)) |>
  mutate(region = str_to_lower(STATE_NAME)) |>
  collect()

DBI::dbDisconnect(fia)

remove(fia, fvs_variant_mixin, state_mixin)
```

```{r map_by_ecoregion}
map_data('state', fvsne_states$region) |> 
  ggplot(aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(
    data = stand_stats |>
      group_by(STATECD, COUNTYCD, PLOT) |>
      filter(row_number() == 1),
    aes(color = ECOCD)
  ) +
  coord_quickmap() +
  theme_bw() +
  scale_color_discrete(name = "Ecoregion")
```

> TODO nik: in FVS_TreeInit_Plot, column PRESCRIPTION FLOAT is used for ThinPRSC.
> Should be able to identify in which year a tree is harvested and put the year
> in PRESCRIPTION, then run with a ThinPRSC to remove the trees prescribed for
> each year.

> NB: ThinPRSC valid range is 2-9 - so this can NOT be the year in which to thin.
> It needs to be a harvest number (+1)

> Will need to find the database and modify it in-place.
> Good news: TREE_CN is TREE.CN (and, presumably, PLOT_CN is PLOT.CN, etc)
> Can a tree be indirectly harvested, e.g. TPA_UNADJ is reduced?
> Since the SQL Query to fetch trees is in the keyword file, we should
> be able to modify that query to add PRESCRIPTION as needed.
```{sql}
with v as (values
  (3181625010661, 2006),
  (3181626010661, 2007)
)
select
  TREE_CN,
  COALESCE(tree.PRESCRIPTION, v.column2) AS PRESCRIPTION
FROM FVS_TreeInit_Plot tree
LEFT JOIN v ON tree.TREE_CN = v.column1
LIMIT 3;
```

```
TREE_CN|PRESCRIPTION
3181625010661|2006
3181626010661|2007
3181627010661|
```

EXCEPT:
From FVS's DBSUserGuide, sectino 4.3 Stand and Tree Initialization:
> The maximum length of the SQL statement is set at 5000 characters

...which is not going to be enough.

Next up: use ATTACH DATABASE 'harvest_prescriptions.db' AS prsc;

# Harvested Trees

Find the trees that were removed during harvest.

Note that FIA.TREE.STATUSCD == 3 indicates that a tree has been harvested,
but not all harvested trees have STATUSCD == 3. Therefore we approximate
harvested trees by finding all trees that exist in a pre-harvest inventory,
but do not exist (or are marked as harvested) in the corresponding harvest
inventory.

## TODO List

✔️ Convert harvest years to per-plot harvest numbers
✔ join harvest number on to tree
✔ data validation: were all trees harvested in a harvest?
  ✔ there are about 20 standing dead trees that are subsequently harvested;
    given that there are so few, I'm going to not worry about them
    and treat them the same as live trees that are harvested
✔ data validation: were trees removed from harvested plots?
  ✔ there are 13 plots that FIA marks as "harvested," were there are no
    trees on the plot pre-harvest that are not on the plot post-harvest.
    Given that there are only 13 of these, I am removing these plots from
    the analysis.
✔ create a dataframe with tree_cn and prescription
✔ write out the prescription table

## Trees removed in harvest

Fetch trees that were standing pre-harvest, that are not standing post-harvest.

```{r tree_removed_in_harvest}
rds_file <- "data/intermediate/tree_removed_in_harvest.rds"
if (USE_CACHE & file.exists(rds_file)) {
  tree_removed_in_harvest <- read_rds(rds_file)
} else {
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  
  tree_in_pre_harvest_plots <- tbl(fia, "TREE") |>
    semi_join(
      stand_stats |>
        filter(PRE_HARVEST == 1) |>
        select(STATECD, COUNTYCD, PLOT, INVYR),
      by = join_by(STATECD, COUNTYCD, PLOT, INVYR),
      copy = TRUE
    ) |>
    filter(STATUSCD == 1 | STATUSCD == 2) |> # live or dead trees
    select(CN, STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR, MORTYR, STATUSCD) |>
    collect() |>
    left_join(
      stand_stats |> select(STATECD, COUNTYCD, PLOT, INVYR, INVNUM),
      by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
    )
  
  tree_in_harvested_plots <- tbl(fia, "TREE") |>
    semi_join(
      stand_stats |>
        filter(HARVEST == 1) |>
        select(STATECD, COUNTYCD, PLOT, INVYR),
      by = join_by(STATECD, COUNTYCD, PLOT, INVYR),
      copy = TRUE
    ) |>
    filter(STATUSCD == 1 | STATUSCD == 2) |> # live and dead trees are still there
    select(STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR) |>
    collect() |>
    left_join(
      stand_stats |> select(STATECD, COUNTYCD, PLOT, INVYR, INVNUM),
      by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
    ) |>
    mutate(
      INVNUM = INVNUM - 1
    )
  
  tree_removed_in_harvest <- tree_in_pre_harvest_plots |>
    anti_join(
      tree_in_harvested_plots,
      by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE, INVNUM)
    )
  
  DBI::dbDisconnect(fia)
  
  remove(fia, tree_in_harvested_plots, tree_in_pre_harvest_plots)

  write_rds(tree_removed_in_harvest, rds_file)
}
```

## FIA Harvested Trees

Fetch trees that FIA says were harvested.

```{r tree_fia_harvested}
rds_file <- "data/intermediate/tree_fia_harvested.rds"
if (USE_CACHE & file.exists(rds_file)) {
  tree_fia_harvested <- read_rds(rds_file)
} else {
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  
  plot_mixin <- tbl(fia, 'PLOT') |>
    select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR)
    
  tree_fia_harvested <- tbl(fia, 'TREE') |>
    semi_join(
      stand_stats |> filter(HARVEST == 1),
      by = join_by(STATECD, COUNTYCD, PLOT, INVYR),
      copy = TRUE
    ) |>
    select(STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR, STATUSCD) |>
    filter(STATUSCD == 3) |>
    left_join(plot_mixin, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    collect()
  
  DBI::dbDisconnect(fia)
  
  remove(fia, plot_mixin)
  
  write_rds(tree_fia_harvested, rds_file)
}
```

## Validation

Were all the trees that FIA says were harvested actually removed?
```{r tree_harvested_but_not_removed}
tree_harvested_but_not_removed <- tree_fia_harvested |>
  anti_join(tree_removed_in_harvest, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE))
stopifnot(tree_harvested_but_not_removed |> nrow() == 0)
```

It is expected that FIA did not mark all removed trees as harvested.
```{r tree_removed_but_not_harvested}
tree_removed_but_not_harvested <- tree_removed_in_harvest |>
  anti_join(tree_fia_harvested, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE))
tree_removed_but_not_harvested |> nrow()
```

All harvested trees should be on harvested plots.
```{r stopifnot_tree_removed_from_non_harvested_plots}
stopifnot(
  tree_removed_in_harvest |>
    distinct(STATECD, COUNTYCD, PLOT, INVNUM) |>
    # INVNUM is the last inventory in which the tree was standing,
    # so it is marked harvested in the next inventory
    mutate(INVNUM = INVNUM + 1) |>
    anti_join(
      stand_stats |> filter(HARVEST == 1),
      by = join_by(STATECD, COUNTYCD, PLOT, INVNUM)
    ) |>
    nrow() == 0
)
```

There are some plots that do not have trees removed.
```{r plot_harvested_without_tree_removed}
plot_harvested_without_tree_removed <- plot_harvested |>
  anti_join(
    tree_removed_in_harvest |>
      distinct(STATECD, COUNTYCD, PLOT),
    join_by(STATECD, COUNTYCD, PLOT)
  )
plot_harvested_without_tree_removed |> nrow()
```

## Remove Harvested Plots Without Removed Trees

Remove those plots from consideration.
```{r ignore plots with no trees removed}
join_cols <- plot_harvested_without_tree_removed |>
  names()
plot_harvested <- plot_harvested |>
  anti_join(plot_harvested_without_tree_removed, join_cols)
stand_stats <- stand_stats |>
  anti_join(plot_harvested_without_tree_removed, join_cols)
rm(join_cols)
```

What's left?
```{r map_by_ecoregion2}
map_data('state', fvsne_states$region) |> 
  ggplot(aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(
    data = stand_stats |>
      group_by(STATECD, COUNTYCD, PLOT) |>
      filter(row_number() == 1),
    aes(color = ECOCD)
  ) +
  coord_quickmap() +
  theme_bw() +
  scale_color_discrete(name = "Ecoregion")
```
# Harvest Prescription for FVS

When running FVS, we will need:

* CutList / CutLiDB - list of trees harvested
* TreeList / TreeLiDB - list of trees; probably we want cycle 0 captured
* ATrtList / ATrtLiDB - After treatment (post treelist, pre harvest) tree list

## Prescription Table

Prescription table:

- Find all years in which trees were removed.
  - For trees marked as harvested, the estimated year of harvest is in MORTYR
    - 1 of 5580 records has MORTYR
    - this is not worth handling for one tree
  - For trees removed from conditions marked as harvested, the estimated year(s)
    of harvest are in TRTYR1/2/3
    - when there are multiple harvest years, we can't tell which trees are
      harvested in which year
    - when there are multiple harvest years, pick the latest one
  - if there are trees left that don't have a harvest year, put their harvest
    the year before measurement. This will be pessimistic with respect to regen,
    but fits the overall distribution
- Create ordinals for removal.
  - Each plot needs to have < 10 years in which removals occur to keep life easy
  - sort the years and number them
- Consolidate harvests
  - we don't want lots of short cycles, but
  - Essential FVS figure 3-1 shows that thinning happens once per cycle,
    no matter how many years are involved

We have access to:
- Stand_CN - ignored, but used for filtering
- Stand_ID - ignored
- PLOT_CN - ignored
- PLOT_ID
- TREE_CN - ignored, but can be used for join
- TREE_ID

```{r tree_prescription}
trtyr_mixin <- stand_stats |>
  filter(HARVEST == TRUE) |>
  mutate(
    TRTYR = if_else(is.na(TRTYR), MEASYEAR - 1, TRTYR),
    TRTNUM = if_else(is.na(TRTNUM), 1, TRTNUM),
    INVNUM = INVNUM - 1
  ) |>
  select(CN, STATECD, COUNTYCD, PLOT, INVNUM, TRTYR, TRTNUM) |>
  rename(STAND_CN = CN)


tree_prescription <- tree_removed_in_harvest |>
  inner_join(
    trtyr_mixin,
    by = join_by(STATECD, COUNTYCD, PLOT, INVNUM)
  ) |>
  rename(TREE_CN = CN) |>
  mutate(PRESCRIPTION = TRTNUM + 1) |> # PRESCRIPTION range is 2-9
  select(TREE_CN, PRESCRIPTION)
```

Write the prescription table to a SQLite database so it can be joined 
onto the trees at run-time:

```{r write tree_prescription}
out_db <- DBI::dbConnect(RSQLite::SQLite(), 'data/fvs/tree_prescription.db')
DBI::dbWriteTable(out_db, 'PRSC', tree_prescription, overwrite = TRUE)
DBI::dbDisconnect(out_db)
rm(out_db)
```

We can create a map from year to treatment number as:
```
stand_stats |> filter(!is.na(TRTYR)) |> select(STAND_CN, TRTYR, TRTNUM)
```

## Compose FVS Tree Query

The FVS Keyword File has a SQL query to fetch the trees for a stand. The
usual query is:
```{sql example_fvs_tree_sql, eval = FALSE}
SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'
```

One of the columns that matches `*` is `PRESCRIPTION` - we want to override
that one column to come from `PRSC.PRSC`. Unfortunately, SQLite does not
support tidyselect, or any useful selection metagrammar, so we need to
list all the columns to be selected, and change just the one we want to change.

To do this, we fetch the table schema from SQLite, and write a JOIN to fetch
that one column, yielding something like:

```{sql example_fvs_tree_override_sql, eval = FALSE}
SELECT
  t.STAND_CN AS STAND_CN,
  t.STAND_ID AS STAND_ID,
  ...,
  p.PRESCRIPTION AS PRESCRIPTION,
  ...
FROM FVS_TreeInit_Plot t
LEFT JOIN PRSC.PRSC p ON t.TREE_CN = p.TREE_CN
WHERE Stand_CN = '%Stand_CN%'
```

```{r fvs_tree_prescription_query}
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
# We need to query a pragma (which looks like a table function);
# dbplyr doesn't support this.
# So we run this query using raw DBI.
columns <- DBI::dbListFields(fia, "FVS_TreeInit_Plot")
dbDisconnect(fia)

result_column <- function(name) {
  table <- NULL
  if (name == "PRESCRIPTION") {
    table <- "p"
  } else {
    table <- "t"
  }
  paste0(table, ".", name) #, " AS ", name)
}

fvs_tree_prescription_query <- paste(
  "ATTACH 'tree_prescription.db' AS PRSC;",
  "SELECT ",
  paste(lapply(columns, result_column), collapse = ",\n"),
  "FROM FVS_TreeInit_Plot t ",
  "LEFT JOIN PRSC.PRSC p ON t.TREE_CN = p.TREE_CN ",
  "WHERE Stand_CN = '%Stand_CN%'",
  sep = "\n"
)

remove(fia, columns, result_column)
```

## Keyword File Definition

```{r keywordfile_section}
keywordfile_section <- function(
    Title, MgmtId, StandID, StandCN,
    FirstYear, LastYear, Timestep,
    Partition, RandSeed = NA
  ) {
  if (!is.na(RandSeed)) {
    StdIdent <- c(
      fvs_kwd0("StdIdent"),
      paste0(StandID, "_Y", Timestep, "_R", RandSeed, " ", Title)
    )
    # Careful: RannSeed != RandSeed
    RannSeed <- fvs_kwd1("RANNSEED", RandSeed)
  } else {
    StdIdent <- c(
      fvs_kwd0("StdIdent"),
      # RannSeed isn't 0, but 0 is an illegal random seed so a fine flag value
      paste0(StandID, "_Y", Timestep, "_R0", " ", Title))
    # Careful: RannSeed != RandSeed
    RannSeed <- c()
  }
  TimeConfig <- fvs_TimeConfig(FirstYear, LastYear, Timestep)
  # if (FirstYear == LastYear) {
  #  Regen <- c() # Don't do regen for 0-year runs
  #} else {
  #  Regen <- keyfile_regen_section(StandID, Timestep)
  #}
  c(
    StdIdent,
    fvs_kwd0("StandCN"),
    StandCN,
    fvs_kwd0("MgmtId"),
    MgmtId,
    TimeConfig,
    RannSeed,
    fvs_kwd0("FMIn"), # Fire and Fuels Extension
    fvs_kwd0("CarbRept"),
    fvs_kwd0("CarbCut"),
    fvs_kwd5("CarbCalc", 1, 1, 0.0425, 9, 11),
    fvs_kwd0("FuelOut"),
    fvs_kwd0("FuelRept"),
    fvs_kwd0("End"), # FMIn
    fvs_kwd0("Database"), # Database extension
    fvs_kwd0("DSNIn"),
    "SQLite_FIADB_ENTIRE.db",
    fvs_kwd0("StandSQL"),
    "SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'",
    fvs_kwd0("EndSQL"), # StandSQL
    fvs_kwd0("TreeSQL"),
    fvs_tree_prescription_query,
    fvs_kwd0("EndSQL"), # TreeSQL
    fvs_kwd0("DSNOut"),
    paste0("FVS_", Title, "_", MgmtId, "_", Partition, ".db"),
    fvs_kwd1("Summary",  2),
    fvs_kwd2("Computdb", 0, 1),
    fvs_kwd1("MisRpts",  2),
    fvs_kwd1("CarbReDB", 2),
    fvs_kwd1("FuelReDB", 2),
    fvs_kwd1("FuelsOut", 2),
    fvs_kwd0("End"), # Database
    #Regen,
    fvs_kwd0("Process")
  )
}

```

## Keyword File Generation

```{r fvs_stands_prsc}
starting_stands <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    INVYR = min(INVYR),
    FIRSTYEAR = min(MEASYEAR),
    LASTYEAR = max(MEASYEAR),
    .groups = "keep"
  ) |>
  ungroup()

fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
fia_fvs_standinit_plot <- tbl(fia, 'FVS_StandInit_Plot') |>
  select(STAND_CN, STAND_ID)

fvs_stands_prsc <- tbl(fia, 'PLOT') |>
  inner_join(starting_stands, by = join_by(STATECD, COUNTYCD, PLOT, INVYR), copy = TRUE) |>
  select(CN, STATECD, COUNTYCD, PLOT, INVYR, FIRSTYEAR, LASTYEAR) |>
  rename(STAND_CN = CN) |>
  left_join(fia_fvs_standinit_plot, by = join_by(STAND_CN)) |>
  collect()

dbDisconnect(fia)
remove(fia, starting_stands, fia_fvs_standinit_plot)
```


```{r NRSHarvest PRSC}
num_partitions <- 60 # The number of simultaneous processes to use
title <- "NRSHarvest"
mgmtid <- "PRSC"
for (partition in 1:num_partitions) {
  filename <- paste0("data/fvs/FVS_", title, "_", mgmtid, "_", partition, ".key")
  if (!USE_CACHE | !file.exists(filename)) {
    unlink(filename)
    print(paste0("Writing ", filename))
    pbapply(
      expand.grid(timestep = c(1, 10), rannseed = c(1, 3, 5)),
      1,
      \(runconfig) {
        timestep <- runconfig["timestep"]
        rannseed <- runconfig["rannseed"]
        apply(
          fvs_stands_prsc |> 
            filter((as.numeric(STAND_ID) %% num_partitions) == (partition - 1)) |>
            arrange(STAND_ID, FIRSTYEAR),
          1,
          function(row) {
            write_lines(
              keywordfile_section(
                title,
                mgmtid,
                row['STAND_ID'],
                row['STAND_CN'],
                row['FIRSTYEAR'],
                row['LASTYEAR'],
                timestep,
                partition,
                rannseed
              ),
              filename,
              append = TRUE
            )
          }
        )
      }
    )
    write_lines("Stop", filename, append = TRUE)
  }
}
```
