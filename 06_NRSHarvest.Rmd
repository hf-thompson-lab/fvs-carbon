---
title: "Nunery Keeton Revisited"
author: "Nikolaus Bates-Haus"
output:
  html_document: default
  pdf_document: default
editor_options:
  markdown:
    wrap: 72
---
# Setup

```{r setup, include=FALSE}
library(targets)
library(tarchetypes)
library(tidyverse)
library(reshape2) # melt()
library(dbplyr) # window_order()
library(measurements) # conv_unit and conv_multiunit
library(maps)
library(ggspatial)
library(pbapply) # Progress bar for long operations
# Color palette to use in charts, for consistency
color_palette <- RColorBrewer::brewer.pal(9, "Greens")
options(scipen = 9) # Use integer notation for numbers under 9 digits
tar_source()
```

## Load targets results from other documents

```{r load tar objects}
tar_load(fiadb)
tar_load(fvsne_states)
tar_load(species_crosswalk)
tar_load(fvs_num_partitions)
tar_load(fvs_partition)
tar_load(fvs_randseed)
```

## Preload targets results from this document

When tar_make() has already built the objects defined in this document,
run this block to pre-load them. You can then skip running ```{targets} blocks.

```{r load tar objects defined here, eval = FALSE}
get_this_rmd_file() |>
  tar_objects_defined_in_rmd() |>
  tar_load()
```

# Harvested Plots in the Northeast

Find all FIA plots that:

* are in the northeastern region, and
* use the modern plot design, and
* have at least 10 years of measurements, and
* are fully forested, and
* is not disturbed ("disturbed" is separate from harvest), and
* is harvested, and
* is not seeded, fertilized, herbicided, etc. post-harvest, and
* is measured both pre- and post-harvest, and
* have a single condition for the entire plot

"Is harvested" is as marked on the condition by FIA. Note that conditions with
harvested trees are not necessarily marked as harvested. To reconcile this, we
observe that TREE.DSTRBCD1 says only "significant disturbance" is registered,
and that "significant disturbance" is disturbance that causes "mortality or
damage to 25 percent of the trees in the condition" Testing confirms that when
the number of stems (TPA_UNADJ) represented by TREE.STATUSCD == 3 is >=25% of
the pre-harvest number of stems on the plot, the condition is marked as
harvested. To be consistent across all kinds of disturbance, we use the FIA
definitions for all disturbance, including harvest, and therefore do NOT mark a
plot as harvested even if there are harvested trees.

```{targets nrshrv_plot_all, tar_simple=TRUE}
fia_plots_filtered(fiadb, filter = \(.data, con) {
  .data |>
    filter(INVYR >= 1999) |>
    filter_plots_fvsne(con) |>
    filter_plots_trees(con) |>
    filter_plots_undisturbed(con) |>
    filter_plots_unfertilized(con) |>
    filter_plots_measured_pre_post_harvest(con) |>
    filter_plots_single_harvest(con)
})
```

## Stand Stats

Fetch more info about these stands.

```{targets nrshrv_plot_stats_all, tar_simple = TRUE}
fia_plots_filtered(fiadb, nrshrv_plot_all, \(.data, con) {
    plots <- .data |> distinct(STATECD, COUNTYCD, PLOT, INVYR)
    plots_join_by <- join_by(STATECD, COUNTYCD, PLOT, INVYR)

    forest_type <- tbl(con, "REF_FOREST_TYPE") |>
      select(VALUE, MEANING) |>
      rename(FORTYPCD = VALUE) |>
      rename(FORTYPE = MEANING)
    
    tree_stats <- tbl(con, "TREE") |>
      inner_join(plots, by = plots_join_by) |>
      select(STATECD, COUNTYCD, PLOT, INVYR, DIA, CARBON_AG, TPA_UNADJ) |>
      group_by(STATECD, COUNTYCD, PLOT, INVYR) |>
      summarize(
        CARBON_AG = sum(CARBON_AG, na.rm = TRUE),
        CPA = sum(CARBON_AG * TPA_UNADJ, na.rm = TRUE),
        # Restrict to trees that match those used in QMD computation, below.
        BA_TREES = sum(if_else(DIA >= 1, TPA_UNADJ, 0), na.rm = TRUE),
        .groups = "keep"
      )
    
    cond_stats <- tbl(con, "COND") |>
      inner_join(plots, by = plots_join_by) |>
      select(STATECD, COUNTYCD, PLOT, INVYR, STDAGE, BALIVE, FORTYPCD) |>
      group_by(STATECD, COUNTYCD, PLOT, INVYR) |>
      # QMD = sqrt(sum(DIA^2) / n)
      # Which is equivalent to
      # QMD = sqrt(sum(BALIVE * TPA_UNADJ) / (n * k)), where n is number of trees,
      # and k is π/576 ≅ 0.005454 for B in square feet and QMD in inches;
      # and k is π/40000 ≅ 0.0000785 for B in square meters and QMD in centimeters.
      # (see https://www.sciencedirect.com/science/article/pii/S2197562023000453 ,
      # https://doi.org/10.1016/j.fecs.2023.100114 )
      # When computing QMD from BA we need to use the same trees for BA and n;
      # FIADB data dictionary 2.5.51 BALIVE says "Basal area in square feet per
      # acre of all live trees ω1.0 inch d.b.h/d.r.c sampled in the condition."
      summarize(
        BALIVE = sum(BALIVE, na.rm = TRUE),
        FORTYPCD = max(FORTYPCD, na.rm = TRUE),
        STDAGE = max(STDAGE, na.rm = TRUE),
        .groups = "keep"
      ) |>
      ungroup()
    
    harvest_mixin <- tbl(con, "COND") |>
      inner_join(plots, by = plots_join_by) |>
      # Label each condition for harvest
      mutate(
        HARVEST =
          (!is.na(TRTCD1) & TRTCD1 == 10) |
          (!is.na(TRTCD2) & TRTCD2 == 10) |
          (!is.na(TRTCD3) & TRTCD3 == 10),
        HRVYR1 = if_else(!is.na(TRTCD1) & (TRTCD1 == 10), TRTYR1, NA),
        HRVYR2 = if_else(!is.na(TRTCD2) & (TRTCD2 == 10), TRTYR2, NA),
        HRVYR3 = if_else(!is.na(TRTCD3) & (TRTCD3 == 10), TRTYR3, NA),
        HRVYR = coalesce(HRVYR3, HRVYR2, HRVYR1)
      ) |>
      # Collapse conditions up to plot level
      group_by(STATECD, COUNTYCD, PLOT, INVYR) |>
      summarize(
        HARVEST = any(HARVEST, na.rm = TRUE),
        HRVYR = max(HRVYR, na.rm = TRUE),
        .groups = "keep"
      ) |>
      ungroup() |>
      # Give ordinals to plot inventories
      group_by(STATECD, COUNTYCD, PLOT) |>
      window_order(INVYR) |>
      mutate(
        INVNUM = row_number(),
        HARVEST = HARVEST & (INVNUM > 1) # Don't consider harvest in the first inventory
      ) |>
      ungroup() |>
      select(STATECD, COUNTYCD, PLOT, INVYR, INVNUM, HARVEST, HRVYR)
    
    pre_harvest_mixin <- harvest_mixin |>
      filter(HARVEST == 1) |>
      mutate(INVNUM = INVNUM - 1) |> # the inventory prior to harvest is pre-harvest
      rename(PRE_HARVEST = HARVEST) |>
      select(STATECD, COUNTYCD, PLOT, INVNUM, PRE_HARVEST)
    
    .data |>
      select(CN, STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR) |>
      left_join(cond_stats, by = plots_join_by) |>
      left_join(tree_stats, by = plots_join_by) |>
      left_join(harvest_mixin, by = plots_join_by) |>
      left_join(pre_harvest_mixin, by = join_by(STATECD, COUNTYCD, PLOT, INVNUM)) |>
      left_join(forest_type, by = join_by(FORTYPCD)) |>
      rename(FOREST_TYPE = FORTYPE) |>
      mutate(
        PRE_HARVEST = if_else(is.na(PRE_HARVEST), 0, PRE_HARVEST),
        STDAGE = if_else(STDAGE < 0, NA, STDAGE),
        FRTYGRCD = floor(FORTYPCD / 10) * 10
      ) |>
      # Mark inventories that come before the pre-harvest inventory
      mutate(PREHRVYEAR = if_else(PRE_HARVEST == 1, MEASYEAR, NA)) |>
      group_by(STATECD, COUNTYCD, PLOT) |>
      window_order(MEASYEAR) |>
      mutate(PRE_PRE_HARVEST = (MEASYEAR < min(PREHRVYEAR, na.rm = TRUE))) |>
      ungroup() |>
      left_join(forest_type, by = join_by(FRTYGRCD == FORTYPCD)) |>
      rename(FOREST_TYPE_GROUP = FORTYPE)
  }) |>
  filter_decode_forest_type_group() |>
  mutate(
    STAND_ID = sprintf("%04d%03d%05d", STATECD, COUNTYCD, PLOT),
    BALIVE_METRIC = conv_multiunit(BALIVE, "ft2 / acre", "m2 / hectare"),
    QMD = sqrt(BALIVE / (BA_TREES * (pi / 576))),
    QMD_METRIC = sqrt(BALIVE_METRIC / (BA_TREES * (pi / 40000))),
    CARBON_METRIC = conv_multiunit(CPA, "lbs / acre", "Mg / hectare")
  ) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  mutate(
    BALIVE_START = if_else(MEASYEAR == min(MEASYEAR, na.rm = TRUE), BALIVE_METRIC, NA),
    BALIVE_DELTA = BALIVE_METRIC - max(BALIVE_START, na.rm = TRUE),
    YEARS = MEASYEAR - min(MEASYEAR, na.rm = TRUE)
  ) |> 
  ungroup()
```

## Stand Locations

Where are they?

```{r map_by_ecoregion, eval = FALSE}
plot_location_tmp <- nrshrv_plot_all |>
  left_join(
    nrshrv_plot_stats_all |> select(STATECD, COUNTYCD, PLOT, INVYR, FOREST_TYPE_GROUP),
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
  ) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  select(CN, LAT, LON, FOREST_TYPE_GROUP) |>
  rename(
    group = CN,
    lat = LAT,
    long = LON
  ) |>
  group_by(FOREST_TYPE_GROUP) |>
  mutate(
    n = n(),
    group_name = paste0(FOREST_TYPE_GROUP, ", n=", n())
  ) |>
  ungroup()

fvsne_states_map <- fvsne_states |>
  distinct(STATE_NAME) |>
  rename(region = STATE_NAME) |>
  _$region |>
  map_data('state', region = _)


ggplot(fvsne_states_map, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(
    plot_location_tmp,
    mapping = aes(long, lat, group = group, color = fct_reorder(group_name, desc(n)))
  ) +
  coord_sf(crs = 4326) +
  annotation_scale(
    location = "tl",
    pad_x = unit(0.44, "cm"),
    pad_y = unit(2, "cm")
  ) +
  annotation_north_arrow(
    location = "tl",
    width = unit(1, "cm"),
    pad_x = unit(1.35, "cm"),
    pad_y = unit(0.25, "cm")
  ) +
  theme_bw() +
  scale_color_discrete(name = "Forest Type Group") +
  ggtitle("FIA Harvested Plots using FVSne")

remove(plot_location_tmp)
```

# Harvested Trees

Find the trees that were removed during harvest.

Note that FIA.TREE.STATUSCD == 3 indicates that a tree has been harvested,
but not all harvested trees have STATUSCD == 3. Therefore we approximate
harvested trees by finding all trees that exist in a pre-harvest inventory,
but do not exist (or are marked as harvested) in the corresponding harvest
inventory.

The goal is not to exactly replicate a harvest, but to tell FVSne which
trees should be removed before the next timestep.

## Trees removed in harvest

Fetch trees that were standing pre-harvest, that are not standing post-harvest.

```{targets nrshrv_tree_removed, tar_simple = TRUE}
tree_in_pre_harvest_plots <- fia_trees_filtered(
    fiadb,
    nrshrv_plot_stats_all |> filter(PRE_HARVEST == 1),
    filter = \(.data, com) {
      .data |>
        filter(STATUSCD == 1 | STATUSCD == 2) |> # live or dead trees
        select(CN, STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR, MORTYR, STATUSCD)  
  }) |>
  left_join(
    nrshrv_plot_stats_all |> select(STATECD, COUNTYCD, PLOT, INVYR, INVNUM),
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
  )

tree_in_harvested_plots <- fia_trees_filtered(
    fiadb,
    nrshrv_plot_stats_all |> filter(HARVEST == 1),
    filter = \(.data, con) {
      .data |>
        filter(STATUSCD == 1 | STATUSCD == 2) |> # live and dead trees are still there
        select(STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR)
    }
  ) |>
  left_join(
    nrshrv_plot_stats_all |> select(STATECD, COUNTYCD, PLOT, INVYR, INVNUM),
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
  ) |>
  # Move back a timestep so we can join the future onto the past
  mutate(
    INVNUM = INVNUM - 1
  )

tree_in_pre_harvest_plots |>
  anti_join(
    tree_in_harvested_plots,
    by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE, INVNUM)
  )
```

## FIA Harvested Trees

Fetch trees that FIA says were harvested.

```{targets nrshrv_tree_harvested, tar_simple = TRUE}
fia_trees_filtered(
    fiadb,
    nrshrv_plot_stats_all |> filter(HARVEST == 1),
    filter = \(.data, con) {
      .data |>
        filter(STATUSCD == 3) |>
        select(CN, PREV_TRE_CN, STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR, STATUSCD)
    }
  ) |>
  left_join(
    nrshrv_plot_stats_all |> select(STATECD, COUNTYCD, PLOT, INVYR, INVNUM),
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
  )
```

## Validation

Were all the trees that FIA says were harvested actually removed?
```{r tree_harvested_but_not_removed, eval = FALSE}
tree_harvested_but_not_removed <- tree_fia_harvested |>
  anti_join(nrshrv_tree_removed, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE))
stopifnot(tree_harvested_but_not_removed |> nrow() == 0)
```

It is expected that FIA did not mark all removed trees as harvested.
```{r tree_removed_but_not_harvested, eval = FALSE}
tree_removed_but_not_harvested <- nrshrv_tree_removed |>
  anti_join(tree_fia_harvested, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE))
tree_removed_but_not_harvested |> nrow()
```

Make sure all harvested trees exist in the pre-harvest inventory.
```{r tree_harvested_but_not_in_pre_harvest, eval = FALSE}
tree_in_pre_harvest_plots <- fia_trees_filtered(
    fiadb,
    nrshrv_plot_stats_all |> filter(PRE_HARVEST == 1),
    filter = \(.data, com) {
      .data |>
        select(CN, STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR, STATUSCD)
  }) |>
  left_join(
    nrshrv_plot_stats_all |> select(STATECD, COUNTYCD, PLOT, INVYR, INVNUM),
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
  )

tree_harvested_but_not_in_pre_harvest <- nrshrv_tree_harvested |>
  anti_join(tree_in_pre_harvest_plots, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE))
stopifnot(tree_harvested_but_not_in_pre_harvest |> nrow() == 0)
```

All harvested trees should be on harvested plots.
```{r stopifnot_tree_removed_from_non_harvested_plots, eval = FALSE}
stopifnot(
  nrshrv_tree_removed |>
    distinct(STATECD, COUNTYCD, PLOT, INVNUM) |>
    # INVNUM is the last inventory in which the tree was standing,
    # so it is marked harvested in the next inventory
    mutate(INVNUM = INVNUM + 1) |>
    anti_join(
      nrshrv_plot_stats_all |> filter(HARVEST == 1),
      by = join_by(STATECD, COUNTYCD, PLOT, INVNUM)
    ) |>
    nrow() == 0
)
```

There are some "harvested" plots that do not have trees removed.
```{r plot_harvested_without_tree_removed, eval = FALSE}
plot_harvested_without_tree_removed <- nrshrv_plot_all |>
  anti_join(
    nrshrv_tree_removed |>
      distinct(STATECD, COUNTYCD, PLOT),
    join_by(STATECD, COUNTYCD, PLOT)
  )
plot_harvested_without_tree_removed |> nrow()
```

## Remove Harvested Plots Without Removed Trees

Remove those plots from consideration.

```{targets nrshrv_plot, tar_simple = TRUE}
nrshrv_plot_all |>
  semi_join(
    nrshrv_tree_removed |> distinct(STATECD, COUNTYCD, PLOT),
    by = join_by(STATECD, COUNTYCD, PLOT)
  ) |>
  # Remove inventories prior to the pre-harvest inventory
  semi_join(
    nrshrv_plot_stats_all |> filter(PRE_PRE_HARVEST == FALSE),
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
  )
```

```{targets nrshrv_plot_stats, tar_simple = TRUE}
nrshrv_plot_stats_all |>
  semi_join(
    nrshrv_plot,
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
  ) |>
  # Renumber INVNUM due to removed inventories
  group_by(STATECD, COUNTYCD, PLOT) |>
  arrange(INVYR) |>
  mutate(INVNUM = row_number()) |>
  ungroup()
```

What's left?
```{r map_by_ecoregion2, eval = FALSE}
plot_data <- nrshrv_plot |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(row_number() == 1) |>
  ungroup() |>
  rename(lat = LAT, long = LON, group = CN) |>
  left_join(
    nrshrv_plot_stats |> select(STATECD, COUNTYCD, PLOT, INVYR, FOREST_TYPE, FOREST_TYPE_GROUP),
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
  ) |>
  group_by(FOREST_TYPE_GROUP) |>
  mutate(
    N = n(),
    group = paste0(FOREST_TYPE_GROUP, ", n=", n())
  ) |>
  ungroup()

map_data('state', fvsne_states$STATE_NAME) |> 
  ggplot(aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(
    data = plot_data,
    aes(color = fct_reorder(group, desc(N)))
  ) +
  coord_sf(crs = 4326) +
  annotation_scale(location = "br") +
  annotation_north_arrow(location = "tl",
    width = unit(1, "cm"),
    pad_x = unit(0.75, "cm"),
    pad_y = unit(0.5, "cm")
  ) +
  theme_bw() +
  scale_color_discrete(name = "Forest Type")
```

# Regeneration

Pick a sample of plots to work with:
```{r sample plot, eval = FALSE}
sample_plot <- nrshrv_plot |> slice_sample(n = 1)
```

## FIA Regen

We want actual regeneration. See what we can get from FIA:
```{r rfia growmort regen, eval = FALSE}
con <- DBI::dbConnect(RSQLite::SQLite(), fiadb)

state_cd <- sample_plot |> pull(STATECD)
county_cd <- sample_plot |> pull(COUNTYCD)
plot_cd <- sample_plot |> pull(PLOT)

fia <- rFIA::readFIA(
  con = con,
  schema = "main",
  states = fvsne_states |> filter(STATECD == state_cd) |> pull(STATE_ABBR),
  inMemory = FALSE
)
fia_grow_mort <- rFIA::growMort(
  fia,
  method = "TI", # "TI", "annual", "SMA", "LMA", "EMA"
  stateVar = "TPA",
  areaDomain = COUNTYCD == county_cd & PLOT == plot_cd,
  byPlot = TRUE,
  bySpecies = TRUE,
  bySizeClass = TRUE
) |>
  filter(RECR_TPA > 0 | MORT_TPA > 0 | REMV_TPA > 0 | GROW_TPA > 0)

DBI::dbDisconnect(con)

fia_grow_mort |> distinct(sizeClass)
```

Note that this only gives sizeClass == 5, so ingrowth of trees >= 5" DBH.
We will need a lot of saplings, 1" < DBH < 5", so let's look at other methods.

```{r plot fia growth and mortality, eval = FALSE}
fia_grow_mort |>
  mutate(TREE_GROUP = paste0(SCIENTIFIC_NAME, " ", if_else(sizeClass < 4, "(sapling)", "(tree)"))) |>
  left_join(nrshrv_plot_stats |> select(CN, HRVYR), by = join_by(PLT_CN == CN)) |>
  mutate(YearsSinceHarvest = YEAR - HRVYR) |>
  group_by(YearsSinceHarvest, TREE_GROUP) |>
  summarize(TPA = sum(RECR_TPA, na.rm = TRUE), .groups = "keep") |>
  ungroup() |>
  ggplot(aes(YearsSinceHarvest, TPA, fill = TREE_GROUP)) +
  geom_col() +
  theme_bw() +
  ggtitle("Post-Harvest Ingrowth")
```

## FIA GRM

```{r fia grm regen, eval = FALSE}
sample_plots <- nrshrv_plot |>
  semi_join(sample_plot, by = join_by(STATECD, COUNTYCD, PLOT))
fia_grm <- fia_grm_ingrowth(fiadb, sample_plots) |>
  mutate(HT = (DIA_END / ANN_DIA_GROWTH) * ANN_HT_GROWTH) |>
  left_join(
    nrshrv_plot |>
      select(CN, STATECD, COUNTYCD, PLOT, MEASYEAR),
    by = join_by(PLT_CN == CN)
  ) |>
  left_join(
    nrshrv_plot_stats |> filter(!is.na(HRVYR)) |> select(STATECD, COUNTYCD, PLOT, HRVYR),
    by = join_by(STATECD, COUNTYCD, PLOT)
  ) |>
  mutate(
    SIZE_CLASS = case_when(
      DIA_END < 1 ~ "seedling",
      DIA_END < 5 ~ "sapling",
      .default = "tree"
    ),
    TPA = coalesce(MICR_TPAGROW_UNADJ_AL_FOREST, SUBP_TPAGROW_UNADJ_AL_FOREST),
    YearsSinceHarvest = MEASYEAR - HRVYR
  ) |>
  select(!starts_with("MICR_") & !starts_with("SUBP_"))

fia_grm <- fia_grm |>
  left_join(
    fia_trees_by_cn(
      fiadb,
      fia_grm |>
        select(TRE_CN) |>
        rename(CN = TRE_CN)
    ) |>
      select(CN, SPCD),
    by = join_by(TRE_CN == CN)
  ) |>
  left_join(
    species_crosswalk,
    by = join_by(SPCD)
  )
ggplot(fia_grm, aes(DIA_END, HT)) + geom_point()
```

```{r plot fia grm rate, eval = FALSE}
pattern_scale <- c(
  "tree" = "stripe",
  "sapling" = "none",
  "seedling" = "circle"
)

fia_grm |>
  group_by(YearsSinceHarvest, SCIENTIFIC_NAME, SIZE_CLASS) |>
  summarize(
    TPA = sum(TPA, na.rm = TRUE),
    .groups = "keep"
  ) |>
  ungroup() |>
  mutate(TREE_GROUP = paste0(SCIENTIFIC_NAME, " (", SIZE_CLASS, ")")) |>
  ggplot(aes(YearsSinceHarvest, TPA, fill = SCIENTIFIC_NAME, pattern = SIZE_CLASS)) +
  geom_col_pattern(pattern_fill = "grey20", pattern_density = 0.05) +
  scale_pattern_manual(values = pattern_scale) +
  theme_bw() +
  ggtitle("Post-Harvest Ingrowth")
```

Which gets us a bunch of 1" trees, so much better visibility earlier in the
growth timeline.

## Early Mortality

Seedlings and saplings die quickly. Let's see if we can find rates.

```{r gather fia mortality, eval = FALSE}
mort <- fia_grm_mortality(fiadb, sample_plots) |>
  left_join(
    nrshrv_plot |>
      select(CN, STATECD, COUNTYCD, PLOT, MEASYEAR),
    by = join_by(PLT_CN == CN)
  ) |>
  left_join(
    nrshrv_plot_stats |> filter(!is.na(HRVYR)) |> select(STATECD, COUNTYCD, PLOT, HRVYR),
    by = join_by(STATECD, COUNTYCD, PLOT)
  ) |>
  mutate(YearsSinceHarvest = MEASYEAR - HRVYR)

mort_spcd_mixin <- fia_trees_by_cn(
    fiadb,
    mort |>
      distinct(TRE_CN) |>
      rename(CN = TRE_CN)
  ) |>
  select(CN, SPCD)
mort_rate <- mort |>
  left_join(mort_spcd_mixin, by = join_by(TRE_CN == CN)) |>
  mutate(
    SIZE_CLASS = case_when(
      DIA_BEGIN < 1 ~ "seedling",
      DIA_BEGIN < 5 ~ "sapling",
      .default = "tree"
    ),
    TPAMORT = case_when(
      SIZE_CLASS == "tree" ~ SUBP_TPAMORT_UNADJ_AL_FOREST,
      .default = MICR_TPAMORT_UNADJ_AL_FOREST
    ),
    TPAGROW = case_when(
      SIZE_CLASS == "tree" ~ SUBP_TPAGROW_UNADJ_AL_FOREST,
      .default = MICR_TPAGROW_UNADJ_AL_FOREST
    )
  ) |>
#  group_by(SPCD, SIZE_CLASS, MEASYEAR) |>
#  summarize(
#    MORTALITY = sum(TPAMORT),# * mean(TPAGROW),
#    .groups = "keep"
#  ) |>
#  ungroup() |>
  left_join(species_crosswalk, by = join_by(SPCD))
```

```{r plot fia mortality, eval = FALSE}
mort_rate |>
  group_by(YearsSinceHarvest, SCIENTIFIC_NAME, SIZE_CLASS) |>
  summarize(TPA = sum(TPAMORT, na.rm = TRUE), .groups = "keep") |>
  ungroup() |>
  mutate(TREE_GROUP = paste0(SCIENTIFIC_NAME, " (", SIZE_CLASS, ")")) |>
  ggplot(aes(YearsSinceHarvest, TPA, fill = SCIENTIFIC_NAME, pattern = SIZE_CLASS)) +
  geom_col_pattern(pattern_fill = "grey20", pattern_density = 0.05) +
  scale_pattern_manual(name = "SIZE_CLASS", values = pattern_scale) +
  theme_bw() +
  ggtitle("Post-Harvest Mortality")
```

Can we plot these next to each other?
```{r plot fia recruitment and mortality, eval = FALSE}
r <- fia_grm |>
  group_by(YearsSinceHarvest, SCIENTIFIC_NAME, SIZE_CLASS) |>
  summarize(TPA = sum(TPA, na.rm = TRUE), .groups = "keep") |>
  ungroup() |>
  mutate(YearsSinceHarvest = YearsSinceHarvest - 3) |>
  mutate(GRM = "Recruit")

m <- mort_rate |>
  group_by(YearsSinceHarvest, SCIENTIFIC_NAME, SIZE_CLASS) |>
  summarize(TPA = sum(TPAMORT, na.rm = TRUE), .groups = "keep") |>
  ungroup() |>
  mutate(YearsSinceHarvest = YearsSinceHarvest - 1) |>
  mutate(GRM = "Mortality")

grm <- tibble(
  YearsSinceHarvest = c(-6, -4, -1, 1, 4, 6, 9, 11),
  GRM = c("Recruit", "Mortality", "Recruit", "Mortality", "Recruit", "Mortality", "Recruit", "Mortality"),
  TPA = c(-1.75),
  SCIENTIFIC_NAME = c(NA),
  SIZE_CLASS = c(NA)
)

color_scale <- c(
  "Abies balsamea" = "blue",
  "Acer rubrum" = "red1",
  "Acer saccharum" = "gold2",
  "Acer spicatum" = "darkorange",
  "Betula alleghaniensis" = "olivedrab3",
  "Picea rubens" = "lightblue",
  "Other" = "gray30"
)

ggplot(r, aes(YearsSinceHarvest, TPA, fill = SCIENTIFIC_NAME, pattern = SIZE_CLASS, label = GRM)) +
  geom_col_pattern(width = 2, pattern_fill = "grey20", pattern_density = 0.05) +
  geom_col_pattern(data = m, width = 2, pattern_fill = "grey20", pattern_density = 0.05) +
  geom_text(data = grm, size = 3) +
  scale_fill_manual(values = color_scale) +
  scale_pattern_manual(values = pattern_scale) +
  theme_bw() +
  ggtitle("Post-Harvest Recruitment vs. Mortality")

```

## Seedlings

Note that no seedling mortality is noted; we can get an apprximation
of seedling mortality by looking at the number of seedlings at t
vs the number of saplings at t + 1.

```{r gather fia seedlings, eval = FALSE}
seedlings <- fia_seedlings(fiadb, sample_plots) |>
  left_join(
    nrshrv_plot |> select(CN, MEASYEAR),
    by = join_by(PLT_CN == CN)
  ) |>
  left_join(
    nrshrv_plot_stats |> filter(HARVEST == 1) |> select(STATECD, COUNTYCD, PLOT, HRVYR),
    by = join_by(STATECD, COUNTYCD, PLOT)
  ) |>
  select(-SPGRPCD) |>
  left_join(
    species_crosswalk,
    by = join_by(SPCD)
  ) |>
  mutate(
    YearsSinceHarvest = MEASYEAR - HRVYR,
    SIZE_CLASS = "seedling"
  )
```

```{r plot fia seedlings, eval = FALSE}
seedlings |>
  mutate(SCIENTIFIC_NAME = if_else(SCIENTIFIC_NAME %in% names(color_scale), SCIENTIFIC_NAME, "Other")) |>
  group_by(YearsSinceHarvest, SCIENTIFIC_NAME, SIZE_CLASS) |>
  summarize(TPA = sum(TPA_UNADJ, na.rm = TRUE), .groups = "keep") |>
  ungroup() |>
  mutate(TPA = TPA / 100) |>
  mutate(YearsSinceHarvest = YearsSinceHarvest - 2) |>
  ggplot(aes(YearsSinceHarvest, TPA, fill = SCIENTIFIC_NAME, pattern = SIZE_CLASS)) +
  geom_col_pattern(width = 2, pattern_fill = "grey20", pattern_density = 0.05) +
  scale_fill_manual(values = color_scale) +
  scale_pattern_manual(name = "SIZE_CLASS", values = pattern_scale) +
  theme_bw() +
  ggtitle("Post-Harvest Seedling Abundance")

```

Can we plot them all together?
```{r plot fia seedlings recruitment and mortality, eval = FALSE}
s <- seedlings |>
  mutate(SCIENTIFIC_NAME = if_else(SCIENTIFIC_NAME %in% names(color_scale), SCIENTIFIC_NAME, "Other")) |>
  group_by(YearsSinceHarvest, SCIENTIFIC_NAME, SIZE_CLASS) |>
  summarize(TPA = sum(TPA_UNADJ, na.rm = TRUE), .groups = "keep") |>
  ungroup() |>
  mutate(TPA = TPA / 100) |>
  mutate(YearsSinceHarvest = YearsSinceHarvest - 1) |>
  mutate(GRM = "Seedl.")

r <- fia_grm |>
  group_by(YearsSinceHarvest, SCIENTIFIC_NAME, SIZE_CLASS) |>
  summarize(TPA = sum(TPA, na.rm = TRUE), .groups = "keep") |>
  ungroup() |>
  mutate(YearsSinceHarvest = YearsSinceHarvest) |>
  mutate(GRM = "Recr.")

m <- mort_rate |>
  group_by(YearsSinceHarvest, SCIENTIFIC_NAME, SIZE_CLASS) |>
  summarize(TPA = sum(TPAMORT, na.rm = TRUE), .groups = "keep") |>
  ungroup() |>
  mutate(YearsSinceHarvest = YearsSinceHarvest + 1) |>
  mutate(GRM = "Mort.")

grm <- tibble(
  YearsSinceHarvest = c(-4, -3, -2, 1, 2, 3, 6, 7, 8, 11, 12, 13),
  GRM = rep(c("Seedl.", "Recr.", "Mort."), 4),
  TPA = c(-1.75),
  SCIENTIFIC_NAME = c("Other"),
  SIZE_CLASS = c("tree")
)

ggplot(r, aes(YearsSinceHarvest, TPA, fill = SCIENTIFIC_NAME, pattern = SIZE_CLASS, label = GRM)) +
  geom_col_pattern(width = 1, pattern_fill = "grey20", pattern_density = 0.05) +
  geom_col_pattern(data = m, width = 1, pattern_fill = "grey20", pattern_density = 0.05) +
  geom_col_pattern(data = s, width = 1, pattern_fill = "grey20", pattern_density = 0.05) +
  geom_vline(xintercept = 0, color = "black", linewidth = 0.25) +
  geom_text(data = grm, size = 2) +
  scale_fill_manual(values = color_scale) +
  scale_pattern_manual(values = pattern_scale) +
  scale_x_continuous(breaks = c(-8, -3, 0, 2, 7, 12, 17), minor_breaks = NULL) +
  theme_bw() +
  ggtitle("Post-Harvest Seedlings, Recruitment and Mortality") +
  ylab("TPA (seedling TPA/100)")
```

How many seedlings become saplings in the subsequent timestep?
```{r plot seedling survival rate, eval = FALSE}
survivors <- fia_grm |>
  filter(SIZE_CLASS == "sapling") |>
  left_join(nrshrv_plot |> select(CN, INVYR), by = join_by(PLT_CN == CN)) |>
  group_by(SPCD) |>
  arrange(INVYR) |>
  mutate(PREV_INVYR = lag(INVYR)) |>
  ungroup() |>
  select(SPCD, PREV_INVYR, TPA) |>
  rename(TPA_SAPL = TPA)

seedlings |>
  group_by(PLT_CN, STATECD, COUNTYCD, PLOT, SPCD, INVYR) |>
  summarize(TPA_SEED = sum(TPA_UNADJ, na.rm = TRUE), .groups = "keep") |>
  ungroup() |>
  left_join(survivors, by = join_by(SPCD, INVYR == PREV_INVYR)) |>
  left_join(nrshrv_plot |> select(CN, MEASYEAR), by = join_by(PLT_CN == CN)) |>
  left_join(
    nrshrv_plot_stats |>
      filter(HARVEST == 1) |>
      select(STATECD, COUNTYCD, PLOT, HRVYR),
    by = join_by(STATECD, COUNTYCD, PLOT)
  ) |>
  mutate(
    TPA_SAPL = coalesce(TPA_SAPL, 0),
    SURVIVAL = (TPA_SAPL / TPA_SEED),
    YearsSinceHarvest = MEASYEAR - HRVYR
  ) |>
  left_join(species_crosswalk, by = join_by(SPCD)) |>
  ggplot(aes(YearsSinceHarvest, SURVIVAL, fill = SCIENTIFIC_NAME)) +
  geom_col(position = "dodge") +
  scale_y_continuous(limits = c(0, 1)) +
  scale_fill_manual(values = color_scale) +
  scale_pattern_manual(values = pattern_scale) +
  theme_bw() +
  ggtitle("Post-Harvest Seedling Survival Rate") +
  ylab("Fraction of seedlings that progress to saplings")
```

This indicates that seedlings are not useful as a predictor of sapling or
tree recruitment.

## Recruitment for FVS

We'll put together recruitment similar to how we did for grow-only plots,
but instead of creating a recruitment rate, we'll put in specific trees
in specific years.

```{r nrshrv_estab, eval = FALSE}
nrhhrv_estab <- fia_grm_ingrowth(fiadb, nrshrv_plot) |>
  filter_estab_height(fiadb)
# TODO: reformat to what FVS requires
# TODO: some trees get Inf height
# TODO: some trees get HT_ESTAB > 200, which is crazy
```

# Run FVS

We will use prescription harvest to tell FVS which trees to harvest, when.
The FVS Keyword Reference section on keyword ThinPRSC says:

> It may help to think of the prescription code in the input tree records (column 49) as a
> number painted on the live trees in the stand. Then think of the prescription code
> identified in this keyword (field 3) as instructing the harvest crew to cut trees with the
> identified number painted on them. The cutting efficiency determines the proportion of
> these trees to be cut.

Thinning is always the first activity in a timestep (Essential FVS section 5.1,
Timing of Management Options). To get harvest in a particular year, we can use
CYCLEAT and they year in which we want to harvest - this will split the enclosing
cycle into two smaller cycles, and harvest will run at the start of the second.
Essential FVS section 4.1.3.1 recommends this method to minimize the bias introduced
by odd-length cycles.

## Thinning Prescription

Thinning Prescription:

- Find all years in which trees were removed.
  - For trees marked as harvested, the estimated year of harvest is in MORTYR
    - 1 of 5580 records has MORTYR
    - this is not worth handling for one tree
  - For trees removed from conditions marked as harvested, the estimated year(s)
    of harvest are in TRTYR1/2/3
    - when there are multiple harvest years, we can't tell which trees are
      harvested in which year
    - when there are multiple harvest years, pick the latest one
  - if there are trees left that don't have a harvest year, put their harvest
    the year before measurement. This will be pessimistic with respect to regen,
    but fits the overall distribution
- Create ordinals for removal.
  - Each plot needs to have < 10 years in which removals occur to keep life easy
  - sort the measurement years and number them
- Consolidate harvests
  - we don't want lots of short cycles, but
  - Essential FVS figure 3-1 shows that thinning happens once per cycle,
    no matter how many years are involved

We have access to:
- Stand_CN - ignored, but used for filtering
- Stand_ID - ignored
- PLOT_CN - ignored
- PLOT_ID
- TREE_CN
- TREE_ID - ignored, but can be used for join

I think we want:
- STAND_CN - which stand
- HRVYR - the year in which harvest occurs
- PRESCRIPTION - maybe we can figure this out dynamically?
- TREE_CN - which tree in the stand
- PERCENT - 100 if not provided; for future use

## FVS Tree Table

FVS fetches stand and tree data from a SQLite database. Unfortunately,
the way it queries the database prevents doing "intereting" things,
such as attaching a second database for prescription overrides.

For example, it'd be great to write something like the following, but we 
cannot connect to two databases at a time in order to get both tables:

```{sql fvs_tree_prescription_override, eval = FALSE}
SELECT
  t.STAND_CN, t.PLOT_ID, t.TREE_CN, t.TREE_ID, t.TREE_COUNT, t.HISTORY,
  t.SPECIES, t.DIAMETER, t.DG, t.HT, t.HTG, t.HTTOPK, t.CRRATIO,
  t.DAMAGE1, t.SEVERITY1, t.DAMAGE2, t.SEVERITY2, t.DAMAGE3, t.SEVERITY3,
  t.TREEVALUE, t.AGE, t.SLOPE, t.ASPECT, t.PV_CODE, t.TOPOCODE, t.SITEPREP,
  p.PRESCRIPTION
FROM fiadb.FVS_TreeInit_Plot t,
     tmp.Tree_Prescription_Table p
WHERE t.TREE_CN = p.TREE_CN AND
      t.STAND_CN = '%Stand_CN%'
```

So we need to write an entire database with the information FVS needs, which is
the FVS_StandInit_Plot and FVS_TreeInit_Plot tables.

## Run FVS: Harvest

```{targets nrshrv_prsc}
tar_target(
  nrshrv_prsc,
  {
    # fvs_run wants a table of the form:
    # STAND_ID - arbitrary identifier for a stand
    # STAND_CN - CN for the plot
    # FIRST_YEAR - start of the projection; if this doesn't align with the actual
    #   year (MEASYEAR) of first survey, the stand will be projected from the
    #   survey year to the start of the projection.
    # LAST_YEAR - end of the projection
    timestep <- 10 # years; determined by FVSne variant
    
    plots_for_fvs <- nrshrv_plot |>
      group_by(STATECD, COUNTYCD, PLOT) |>
      arrange(INVYR) |>
      mutate(
        STAND_CN = if_else(row_number() == 1, CN, NA)
      ) |>
      summarize(
        STAND_CN = min(STAND_CN, na.rm = TRUE), # only one will not be NA
        FIRST_YEAR = min(MEASYEAR, na.rm = TRUE),
        LAST_YEAR = max(MEASYEAR, na.rm = TRUE),
        .groups = "keep"
      ) |>
      ungroup() |>
      left_join(
        nrshrv_plot_stats |> distinct(STATECD, COUNTYCD, PLOT, STAND_ID),
        by = join_by(STATECD, COUNTYCD, PLOT)
      )

    # Harvest is all the trees on the pre-harvest plots,
    # filtered to those trees that end up being harvested.
    harvest_for_fvs <- fia_trees_filtered(
        fiadb,
        nrshrv_plot_stats |> filter(PRE_HARVEST == 1),
        filter = \(.data, com) {
          .data |>
            select(CN, STATECD, COUNTYCD, PLOT, SUBP, TREE) |>
            rename(TREE_CN = CN)
      }) |>
      inner_join(
        nrshrv_tree_harvested |>
          select(PREV_TRE_CN, STATECD, COUNTYCD, PLOT, SUBP, TREE),
        by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE)
      ) |>
      # Find the harvest year
      left_join(
        nrshrv_plot_stats |>
          filter(HARVEST == 1) |>
          select(STATECD, COUNTYCD, PLOT, INVNUM, HRVYR) |>
          rename(
            PRESCRIPTION = INVNUM,
            YEAR = HRVYR
          ),
        by = join_by(STATECD, COUNTYCD, PLOT)
      ) |>
      # Find the pre-harvest stand CN
      left_join(
        nrshrv_plot_stats |>
          filter(PRE_HARVEST == 1) |>
          select(CN, STATECD, COUNTYCD, PLOT) |>
          rename(STAND_CN = CN),
        by = join_by(STATECD, COUNTYCD, PLOT)
      ) |>
      select(STAND_CN, TREE_CN, PREV_TRE_CN, YEAR, PRESCRIPTION)

    # Verify that, in all cases where PREV_TRE_CN is not NULL, we lined
    # up the harvested tree with the correct pre-harvest tree.
    stopifnot(harvest_for_fvs |> filter(TREE_CN != PREV_TRE_CN) |> nrow() == 0)

    # fvs_run wants establishment in the form:
    # STAND_CN
    # SPECIES (FVS_SPCD)
    # DENSITY (TPA)
    # HEIGHT (FT)
    #estab_for_fvs <- nrs_estab_rate |>
    #  mutate(
    #    STAND_ID = sprintf("%04d%03d%05d", STATECD, COUNTYCD, PLOT)
    #  ) |>
    #  left_join(
    #    plots_for_fvs |> select(STAND_ID, STAND_CN),
    #    by = join_by(STAND_ID)
    #  ) |>
    #  select(STAND_CN, STATECD, COUNTYCD, PLOT, SPCD, RATE_PER_ACRE) |>
    #  mutate(RATE_PER_ACRE = floor(RATE_PER_ACRE * timestep)) |>
    #  rename(DENSITY = RATE_PER_ACRE) |>
    #  left_join(
    #    nrs_estab_height |>
    #      select(STATECD, COUNTYCD, PLOT, SPCD, HT),
    #    by = join_by(STATECD, COUNTYCD, PLOT, SPCD)
    #  ) |>
    #  mutate(HT = floor(HT)) |>
    #  rename(HEIGHT = HT) |>
    #  left_join(
    #    species_crosswalk |>
    #      select(SPCD, FVS_SPCD),
    #    by = join_by(SPCD)
    #  ) |>
    #  rename(SPECIES = FVS_SPCD) |>
    #  filter(!is.na(SPECIES) & !is.na(DENSITY) & !is.na(HEIGHT)) |>
    #  select(STAND_CN, SPECIES, DENSITY, HEIGHT)
      
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "NRSHarvest"
    mgmt_id <- "PRSC"
    
    # We communicate with FVS through files. FVSOnline shows a model in which
    # a "project" (the inputs and outputs of a single FVS run) live in a
    # single directory; we follow that model.
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = fiadb,
      title = title,
      mgmt_id = mgmt_id,
      stands = plots_for_fvs,
      #regen = estab_for_fvs,
      harvest = harvest_for_fvs,
      num_partitions = fvs_num_partitions,
      partition = fvs_partition,
      random_seed = fvs_randseed
    )
  },
  # iteration = "vector" branches execution for each partition value (see below)
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here.
  # cross() ensures that every combination of values for its arguments is processed
  # map() distributes each value of its argument to a separate sub-target (branch)
  # so cross(randseed, map(partition)) will run each partition in a separate branch,
  # and each branch will run with each value of randseed
  pattern = cross(fvs_randseed, map(fvs_partition))
)
```

## Run FVS: Survey

We also do 0-year projections of the same stands in every measurement year
to provide a comparison.

```{targets nrshrv_srvy}
tar_target(
  nrshrv_srvy,
  {
    # fvs_run wants a table of the form:
    # STAND_ID - arbitrary identifier for a stand
    # STAND_CN - CN for the plot
    # FIRST_YEAR - start of the projection; if this doesn't align with the actual
    #   year (MEASYEAR) of first survey, the stand will be projected from the
    #   survey year to the start of the projection.
    # LAST_YEAR - end of the projection
    timestep <- 10 # years; determined by FVSne variant
    
    plots_for_fvs <- nrshrv_plot |>
      left_join(
        nrshrv_plot_stats |> distinct(STATECD, COUNTYCD, PLOT, STAND_ID),
        by = join_by(STATECD, COUNTYCD, PLOT)
      ) |>
      rename(
        STAND_CN = CN,
        FIRST_YEAR = MEASYEAR
      ) |>
      mutate(
        LAST_YEAR = FIRST_YEAR
      )
    
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "NRSHarvest"
    mgmt_id <- "SRVY"
    
    # We communicate with FVS through files. FVSOnline shows a model in which
    # a "project" (the inputs and outputs of a single FVS run) live in a
    # single directory; we follow that model.
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = fiadb,
      title = title,
      mgmt_id = mgmt_id,
      stands = plots_for_fvs,
      regen = NULL, # No regen for survey
      harvest = NULL, # No harvest for survey
      num_partitions = fvs_num_partitions,
      partition = fvs_partition
    )
  },
  # iteration = "vector" branches execution for each partition value (see below)
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here.
  # cross() ensures that every combination of values for its arguments is processed
  # map() distributes each value of its argument to a separate sub-target (branch)
  # so cross(randseed, map(partition)) will run each partition in a separate branch,
  # and each branch will run with each value of randseed
  pattern = map(fvs_partition)
)
```


# Results

## Fault Analysis

Skipped for now.

## Load Results

Load the output from all FVS partitions into a single dataframe

Consolidate outputs that use multiple random seeds;
average the multiple runs with different random seeds.

### NRS Harvest PRSC

Carbon

```{targets nrshrv_prsc_carbon, tar_simple = TRUE}
fvs_read_output(nrshrv_prsc, "FVS_Carbon") |>
  group_by(StandID, Year) |> # Combine results from different random seeds
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    .groups = "keep"
  ) |>
  ungroup() |>
  left_join(
    nrshrv_plot_stats |>
      filter(!is.na(HRVYR)) |>
      distinct(STAND_ID, HRVYR) |>
      rename(StandID = STAND_ID, HarvestYear = HRVYR),
    by = join_by(StandID)
  ) |>
  mutate(
    YearsSinceHarvest = Year - HarvestYear
  )
```

Summary

```{targets nrshrv_prsc_summary, tar_simple = TRUE}
fvs_read_output(nrshrv_prsc, "FVS_Summary2_East") |>
  group_by(StandID, Year) |>
  summarize(
    BA = mean(BA),
    Tpa = mean(Tpa),
    .groups = 'keep'
  ) |>
  ungroup() |>
  left_join(
    nrshrv_plot_stats |>
      filter(!is.na(HRVYR)) |>
      distinct(STAND_ID, HRVYR) |>
      rename(StandID = STAND_ID, HarvestYear = HRVYR),
    by = join_by(StandID)
  ) |>
  mutate(
    YearsSinceHarvest = Year - HarvestYear
  )
```

### NRS Harvest SRVY

Carbon

```{targets nrshrv_srvy_carbon, tar_simple = TRUE}
fvs_read_output(nrshrv_srvy, "FVS_Carbon") |>
  select(StandID, Year, Aboveground_Total_Live) |>
  left_join(
    nrshrv_plot_stats |>
      filter(!is.na(HRVYR)) |>
      distinct(STAND_ID, HRVYR) |>
      rename(StandID = STAND_ID, HarvestYear = HRVYR),
    by = join_by(StandID)
  ) |>
  mutate(
    YearsSinceHarvest = Year - HarvestYear
  )
```

Summary

```{targets nrshrv_srvy_summary, tar_simple = TRUE}
fvs_read_output(nrshrv_srvy, "FVS_Summary2_East") |>
  select(StandID, Year, BA, Tpa) |>
  left_join(
    nrshrv_plot_stats |>
      filter(!is.na(HRVYR)) |>
      distinct(STAND_ID, HRVYR) |>
      rename(StandID = STAND_ID, HarvestYear = HRVYR),
    by = join_by(StandID)
  ) |>
  mutate(
    YearsSinceHarvest = Year - HarvestYear
  )
```

## Sanity Check

### Harvested Trees are Cut

Did we harvest the right trees?

FVS produces three tree tables:

 - FVS_ATRTList_East: After Treatement Tree List - live trees after treatment
 - FVS_CutList_East: Trees removed in treatment
 - FVS_TreeList_East: All trees on the plot
 
 FVS_TreeList_East includes trees from cycle (timestep) 0, which shows the
 trees as loaded. This precedes any tree records splitting that will confuse
 the connection between FVS and FIA trees.
 
 Note that a tree in TreeList may be in neither ATRTList nor CutList, e.g.
 if it died but was not cut during the cycle.
 
 Gather the tree lists from the FVS runs; the harvested trees are by
 necessity inventory trees, so there is no randomization and we can take
 only one of the random branches.
 
 After the first cycle, the trees get split and divided by FVS to represent
 differences in growth rate, but we can pick one series arbitrarily to inspect
 the behavior of the system. Metrics such as stand carbon etc. are aggregated
 from all random seeds in other datasets.

```{r fvs tree lists, eval = FALSE}
nrshrv_prsc_treelist <- fvs_read_output(nrshrv_prsc, "FVS_TreeList_East") |>
  group_by(StandID) |>
  filter(
    random_seed == min(random_seed, na.rm = TRUE)
  ) |>
  ungroup() |>
  arrange(StandID, Year, PtIndex, TreeIndex)

nrshrv_prsc_atrtlist <- fvs_read_output(nrshrv_prsc, "FVS_ATRTList_East") |>
  group_by(StandID) |>
  filter(
    Year == min(Year, na.rm = TRUE),
    random_seed == min(random_seed, na.rm = TRUE)
  ) |>
  ungroup() |>
  arrange(StandID, Year, PtIndex, TreeIndex)

nrshrv_prsc_cutlist  <- fvs_read_output(nrshrv_prsc, "FVS_CutList_East") |>
  group_by(StandID) |>
  filter(
    Year == min(Year, na.rm = TRUE),
    random_seed == min(random_seed, na.rm = TRUE)
  ) |>
  ungroup() |>
  arrange(StandID, Year, PtIndex, TreeIndex)
```

How many of nrshrv_tree_harvested are in nrshrv_prsc_cutlist?

```{r fia vs fvs harvested trees, eval = FALSE}
fvs_harvested_trees <- nrshrv_prsc_cutlist |>
  select(StandID, PtIndex, TreeId, SpeciesFIA, TPA, DBH) |>
  rename(
    STAND_ID = StandID,
    SUBP = PtIndex,
    TREE = TreeId,
    SPCD = SpeciesFIA,
    DIA = DBH
  ) |>
  mutate(
    SPCD = as.integer(SPCD),
    BA = TPA * pi * (DIA / 2) ^ 2,
    DIA_TENTHS = as.integer(0.5 + DIA * 10), # DIA_TENTHS is tenths of an inch
    FVS_HARVEST = 1
  )

stand_id_mixin <- nrshrv_plot_stats |>
  distinct(STATECD, COUNTYCD, PLOT, STAND_ID)

fia_harvested_trees <- fia_trees_filtered(
    fiadb,
    nrshrv_plot_stats |> filter(PRE_HARVEST == 1),
    filter = \(.data, com) {
      .data |>
        select(STATECD, COUNTYCD, PLOT, SUBP, TREE, SPCD, TPA_UNADJ, DIA) |>
        rename(TPA = TPA_UNADJ)
  }) |>
  inner_join(
    nrshrv_tree_harvested |>
      select(STATECD, COUNTYCD, PLOT, SUBP, TREE),
    by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE)
  ) |>
  left_join(
    stand_id_mixin,
    by = join_by(STATECD, COUNTYCD, PLOT)
  ) |>
  select(STAND_ID, SUBP, TREE, SPCD, TPA, DIA) |>
  mutate(
    TREE = as.character(TREE), # FVS TREE uses letters
    BA = TPA * pi * (DIA / 2) ^ 2,
    DIA_TENTHS = trunc(0.5 + DIA * 10), # DIA is now tenths of an inch
    FIA_HARVEST = 1
  )
```

```{r align harvest by tree, eval = FALSE}
align_by_tree <- fia_harvested_trees |>
  full_join(
    fvs_harvested_trees,
    by = join_by(STAND_ID, SUBP, TREE)
  )
align_by_tree |>
  filter(!is.na(FVS_HARVEST) & !is.na(FIA_HARVEST)) |>
  nrow() /
  align_by_tree |> nrow()
```

We were able to line up less than half the trees by identity.

What about lining up by diameter?

```{r align harvest by diameter, eval = FALSE}
align_by_dia <- fia_harvested_trees |>
  full_join(
    fvs_harvested_trees,
    by = join_by(STAND_ID, TREE, DIA_TENTHS)
  )

align_by_dia |>
  filter(!is.na(FVS_HARVEST) & !is.na(FIA_HARVEST)) |>
  nrow() /
  align_by_dia |> nrow()
```

Better; we were able to line up 97%, but diameter is not unique so the join
ended up being many-to-many, so the results are incorrect.

Instead of lining up trees, we can also look to see if approximately the
correct BA was harvested of each species on each plot.

```{r align harvest by basal area, eval = FALSE}
fia_harvested_ba <- fia_harvested_trees |>
  group_by(STAND_ID, SPCD) |>
  summarize(FIA_BA = sum(BA / 12), .groups = "keep") |>
  ungroup()

fvs_harvested_ba <- fvs_harvested_trees |>
  group_by(STAND_ID, SPCD) |>
  summarize(FVS_BA = sum(BA / 12), .groups = "keep") |>
  ungroup()

align_by_ba <- fia_harvested_ba |>
  full_join(
    fvs_harvested_ba,
    by = join_by(STAND_ID, SPCD)
  ) |>
  mutate(
    FIA_BA = coalesce(FIA_BA, 0),
    FVS_BA = coalesce(FVS_BA, 0),
    DELTA = abs(FIA_BA - FVS_BA),
    PROPORTION = FVS_BA / ((FVS_BA + FIA_BA) / 2),
    ERROR = abs(FIA_BA - FVS_BA) / ((FVS_BA + FIA_BA) / 2)
  ) |>
  left_join(species_crosswalk, by = join_by(SPCD))

summary(align_by_ba$ERROR)
```

```{r harvest 99%ile error, eval = FALSE}
align_by_ba |>
  mutate(RANK = percent_rank(ERROR)) |>
  filter(ERROR < 0.01) |>
  filter(RANK == max(RANK))
```

so >97.5% of plot/species are within 1% of requested

What are the outliers?

```{r fvs vs via harvest outliers, eval = FALSE}
outliers <- align_by_ba |>
  filter(ERROR > 0.02)
```

Some of these will be because FVS doesn't handle the species:
```{r fvs harvest unhandled species, eval = FALSE}
outliers |> filter(FVS_BA == 0) |> nrow()
```

7 out of 29.

Interestingly, there are 5 cases where FVS harvested species not requested:
```{r fia harvest unhandled species, eval = FALSE}
outliers |> filter(FIA_BA == 0) |> nrow()
```

Ten of these line up at the genus level:
```{r align harvest by genus, eval = FALSE}
missing_fvs_ba <- align_by_ba |>
  filter(FVS_BA == 0) |>
  select(!FVS_BA)
missing_fia_ba <- align_by_ba |>
  filter(FIA_BA == 0)
has_both_fia_and_fvs_ba <- align_by_ba |>
  filter(FIA_BA > 0 & FVS_BA > 0)
aligned_at_genus <- missing_fvs_ba |>
  left_join(
    missing_fia_ba |> select(STAND_ID, GENUS, FVS_BA),
    by = join_by(STAND_ID, GENUS)
  ) |>
  filter(!is.na(FIA_BA) & !is.na(FVS_BA)) |>
  mutate(
    DELTA = abs(FIA_BA - FVS_BA),
    PROPORTION = FVS_BA / ((FVS_BA + FIA_BA) / 2),
    ERROR = abs(FIA_BA - FVS_BA) / ((FVS_BA + FIA_BA) / 2)
  )
still_unaligned <- missing_fia_ba |>
  anti_join(
    aligned_at_genus,
    by = join_by(STAND_ID, GENUS)
  )

align_by_ba_2 <- bind_rows(
  has_both_fia_and_fvs_ba,
  aligned_at_genus,
  still_unaligned
)
```

```{r plot harvest ba error, eval = FALSE}
ggplot(align_by_ba_2, aes(PROPORTION)) +
  geom_histogram(binwidth = 0.05) +
  theme_bw() +
  ggtitle("Proportion of BA specified for harvested that was actually harvested") +
  ylab("Species/Plot Combinations") +
  xlab("Harvested Proportion")
```



### Projected Stands are Surveyed

Sanity check: do the projections line up with the surveys?

```{r projected matches measured, eval = FALSE}
projected <- nrshrv_prsc_summary |>
  group_by(StandID) |>
  filter(Year == max(Year) | Year == min(Year)) |>
  ungroup() |>
  select(StandID, Year) |>
  mutate(PROJECTED = 1)

measured <- nrshrv_srvy_summary |>
  group_by(StandID) |>
  filter(Year == max(Year) | Year == min(Year)) |>
  ungroup() |>
  select(StandID, Year) |>
  mutate(MEASURED = 1)

stopifnot(
  projected |>
    full_join(measured, by = join_by(StandID, Year)) |>
    filter(is.na(PROJECTED) | is.na(MEASURED)) |>
    nrow()
  == 0
)
```

## Carbon

```{r plot projected carbon, eval = FALSE}
ggplot(
    nrshrv_prsc_carbon,
    aes(x = YearsSinceHarvest, y = Aboveground_Total_Live)
  ) +
  geom_vline(xintercept = 0, color = "black", linetype  = "dashed", linewidth = 0.5) +
  geom_bin2d(bins = 25) +
  scale_fill_gradient(
    name = "Number of Plots",
    low = color_palette[1],
    high = color_palette[8],
    limits = c(0, 50)
  ) +
  theme_bw() +
  ggtitle("FVS Projected Carbon in Harvested Stands (no regen)") +
  ylab(bquote("Aboveground Live Carbon" ~(`Mg C` %.% ha^-1))) +
  xlab("Years since Harvest")
```

```{r plot measured carbon, eval = FALSE}
ggplot(
    nrshrv_srvy_carbon,
    aes(x = YearsSinceHarvest, y = Aboveground_Total_Live)
  ) +
  geom_vline(xintercept = 0, color = "black", linetype  = "dashed", linewidth = 0.5) +
  geom_bin2d(bins = 25) +
  scale_fill_gradient(
    name = "Number of Plots",
    # transform = "log10",
    low = color_palette[1],
    high = color_palette[8],
    limits = c(0, 50)
  ) +
  theme_bw() +
  ggtitle("FIA Measured Carbon in Harvested Stands") +
  ylab(bquote("Aboveground Live Carbon" ~(`Mg C` %.% ha^-1))) +
  xlab("Years since Harvest")
```

## Carbon Flux


```{r plot measured flux, eval = FALSE}
all_years <- tibble(YearsSinceHarvest = min(nrshrv_srvy_carbon$YearsSinceHarvest):max(nrshrv_srvy_carbon$YearsSinceHarvest))
num_years <- all_years |> nrow()

nrshrv_srvy_carbon |>
  group_by(StandID) |>
  arrange(YearsSinceHarvest) |>
  mutate(
    C_Flux = -(Aboveground_Total_Live - lag(Aboveground_Total_Live)),
    Prev_Years = lag(YearsSinceHarvest),
    Annual_C_Flux = C_Flux / (YearsSinceHarvest - Prev_Years),
    Min_Years = min(YearsSinceHarvest),
    Max_Years = max(YearsSinceHarvest)
  ) |>
  ungroup() |>
  full_join(
    expand.grid(
      StandID = unique(nrshrv_srvy_carbon$StandID),
      YearsSinceHarvest = all_years$YearsSinceHarvest
    ),
    by = join_by(StandID, YearsSinceHarvest)
  ) |>
  arrange(StandID, YearsSinceHarvest) |>
  fill(StandID, Annual_C_Flux, .direction = "up") |>
  fill(Min_Years, Max_Years, .direction = "updown") |>
  filter(YearsSinceHarvest >= Min_Years & YearsSinceHarvest <= Max_Years) |>
  ggplot(
    aes(x = YearsSinceHarvest, y = Annual_C_Flux)
  ) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.25) +
  geom_vline(xintercept = 0, color = "black", linewidth = 0.25) +
  geom_bin2d(binwidth = c(1, 1)) +
  scale_fill_gradient(
    name = "Number of Plots",
    low = color_palette[2],
    high = color_palette[9]
  ) +
  theme_bw() +
  ggtitle("FIA Measured Annual Carbon Flux for Harvested Plots") +
  ylab(bquote("Projected Carbon Flux" ~(`Mg C` %.% ha^-1 %.% yr^-1))) #+;

```

```{r plot projected flux, eval = FALSE}
all_years <- tibble(YearsSinceHarvest = min(nrshrv_prsc_carbon$YearsSinceHarvest):max(nrshrv_prsc_carbon$YearsSinceHarvest))
num_years <- all_years |> nrow()

nrshrv_prsc_carbon |>
  group_by(StandID) |>
  arrange(YearsSinceHarvest) |>
  mutate(
    C_Flux = -(Aboveground_Total_Live - lag(Aboveground_Total_Live)),
    Prev_Years = lag(YearsSinceHarvest),
    Annual_C_Flux = C_Flux / (YearsSinceHarvest - Prev_Years),
    Min_Years = min(YearsSinceHarvest),
    Max_Years = max(YearsSinceHarvest)
  ) |>
  ungroup() |>
  full_join(
    expand.grid(
      StandID = unique(nrshrv_prsc_carbon$StandID),
      YearsSinceHarvest = all_years$YearsSinceHarvest
    ),
    by = join_by(StandID, YearsSinceHarvest)
  ) |>
  arrange(StandID, YearsSinceHarvest) |>
  fill(StandID, Annual_C_Flux, .direction = "up") |>
  fill(Min_Years, Max_Years, .direction = "updown") |>
  filter(YearsSinceHarvest >= Min_Years & YearsSinceHarvest <= Max_Years) |>
  ggplot(
    aes(x = YearsSinceHarvest, y = Annual_C_Flux)
  ) +
  geom_bin2d(binwidth = c(1, 1)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_fill_gradient(
    name = "Number of Plots",
    low = color_palette[2],
    high = color_palette[9]
  ) +
  theme_bw() +
  ggtitle("FVS Projected Annual Carbon Flux for Harvested Plots") +
  ylab(bquote("Projected Carbon Flux" ~(`Mg C` %.% ha^-1 %.% yr^-1))) #+;

```
