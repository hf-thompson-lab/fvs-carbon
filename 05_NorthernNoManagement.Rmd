---
title: "Nunery Keeton Revisited"
author: "Nikolaus Bates-Haus"
output:
  word_document: default
  html_document: default
  pdf_document: default
editor_options:
  markdown:
    wrap: 72
---

```{r setup, include=FALSE}
library(tidyverse)
library(reshape2) # for melt()
library(RSQLite)
library(htmltools)
library(rmarkdown)
library(dbplyr)
library(measurements)
library(maps)
```

```{r source-functions}
source('R/functions.R')
```

## Grow-Only Plots in the Northeast

Find all FIA plots in the northeastern region that are grow-only, that have
a measurement year between 1999 and 2004, and have at least two measurements
between 1999 and 2024. We select 1999 becasue FIA changed
to the 4-subplot structure in 1999; we select 2004 so that we will have
at least 20 years of growth. We require two measurements so that we can compare
projected vs. actual growth between measurements.

Survey filters:

*  PLOT.MEASYEAR > 1999 - really, we want DESIGNCD (plot design) == 1
*  max(PLOT.MEASYEAR) - min(PLOT.MEASYEAR) >= 10
*  BALIVE > 0

Northeastern region:

*  SURVEY.RSCD == 24

Grow-only is described previously:

*  Only one condition: max(FIA.COND.CONDID) == 1
*  Survey was not skipped: COND.COND_STATUS_CD == 1
*  Plot was not disturbed: COND.DSTRBCD1 == 0 & COND.DSTRBCD2 == 0 & COND.DSTRBCD3 == 0
*  Plot was not treated: COND.TRTCD1 == 0 & TRTCD2 == 0 & TRTCD3 == 0

The functions in `functions.R` define these filters

Execute the filters to create a list of matching plots.

```{r plot_grow_only}
rds_file <- 'data/intermediate/plot_grow_only.rds'
if (file.exists(rds_file)) {
  plot_grow_only <- read_rds(rds_file)
} else {
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  fia_cond <- tbl(fia, 'COND') |>
    select(
      STATECD, COUNTYCD, PLOT, PLT_CN, CONDID, INVYR,
      COND_STATUS_CD, BALIVE, DSTRBCD1, DSTRBCD2, DSTRBCD3, TRTCD1, TRTCD2, TRTCD3
    )
  fia_plot <- tbl(fia, 'PLOT') |>
    # Narrow and rename columns to facilitate join
    select(CN, DESIGNCD, SRV_CN, MEASYEAR, ECOSUBCD) |>
    rename(PLT_CN = CN)
  fia_plotgeom <- tbl(fia, 'PLOTGEOM') |>
    # Narrow and rename columns to facilitate join
    select(CN, FVS_VARIANT) |>
    rename(PLT_CN = CN)
  
  plot_grow_only <- fia_cond |>
    left_join(fia_plot, by = join_by(PLT_CN)) |>
    left_join(fia_plotgeom, by = join_by(PLT_CN)) |>
    fvsne_plots_filter() |>
    modern_plots_filter() |>
    has_trees_filter() |>
    long_measurement_filter() |>
    forested_plots_filter() |>
    undisturbed_plots_filter() |>
    untreated_plots_filter() |>
    # single_condition_plots_filter() |>
    distinct(STATECD, COUNTYCD, PLOT) |>
    collect() |>
    arrange(STATECD, COUNTYCD, PLOT)
  
  dbDisconnect(fia)
  remove(fia, fia_cond, fia_plot, fia_plotgeom)
  
  write_rds(plot_grow_only, rds_file)
}
nrow(plot_grow_only)
```

### Locations

Where are these plots?

Fetch plots with measyear, invyr, latitude, longitude, and state information.

```{r plot_location}
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

# Survey has the research station code
fia_survey <- tbl(fia, 'SURVEY') |>
  select(CN, RSCD) |>
  rename(SRV_CN = CN)

# plot has invyr, measyr, lat and lon
fia_plot <- tbl(fia, 'PLOT') |>
  # Narrow and rename columns to facilitate join
  select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR, SRV_CN, ECOSUBCD, LAT, LON)

# research station has state name and abbreviation
fia_ref_research_station <- tbl(fia, 'REF_RESEARCH_STATION') |>
  select(STATECD, STATE_NAME, STATE_ABBR)

plot_location <- fia_plot |>
  semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
  left_join(fia_survey, by = join_by(SRV_CN)) |>
  left_join(fia_ref_research_station, by = join_by(STATECD)) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  # Pick just the first inventory year
  filter(min_rank(INVYR) == 1) |> 
  ungroup() |>
  collect() |>
  rename(
    long = LON,
    lat = LAT
  ) |>
  mutate(group = sprintf('%02d%03d%05d', STATECD, COUNTYCD, PLOT))

dbDisconnect(fia)
remove(fia, fia_plot, fia_survey, fia_ref_research_station)
```

How many plots are in each state?

```{r state_plot_counts}
state_plot_counts <- plot_location |>
  group_by(STATE_NAME) |>
  summarize(COUNT = n()) |>
  ungroup() |>
  arrange(desc(COUNT))
knitr::kable(state_plot_counts)
```

Show the plots on a map.

```{r map_states}
northeastern_states <- plot_location |>
  distinct(STATE_NAME) |>
  mutate(region = str_to_lower(STATE_NAME))
map_states <- map_data('state', northeastern_states$region)

ggplot(map_states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(data = plot_location, color = alpha("blue", alpha = 0.5)) +
  coord_quickmap()
```

### Stand Statistics

We can gather per-stand statistics such as BALIVE and CARBON_AG from the FIA
data for these plots over time.

```{r stand_stats}
rds_file <- 'data/intermediate/stand_stats.rds'
if (file.exists(rds_file)) {
  stand_stats <- read_rds(rds_file)
} else {
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  
  measyear <- tbl(fia, 'PLOT') |>
    select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR, DESIGNCD, ECOSUBCD)
  
  forest_type <- tbl(fia, 'REF_FOREST_TYPE') |>
    select(VALUE, MEANING) |>
    rename(FORTYPCD = VALUE) |>
    rename(FORTYPE = MEANING)
  
  tree_stats <- tbl(fia, 'TREE') |>
    select(STATECD, COUNTYCD, PLOT, CONDID, INVYR, DIA, CARBON_AG, TPA_UNADJ) |>
    group_by(STATECD, COUNTYCD, PLOT, CONDID, INVYR) |>
    summarize(
      CARBON_AG = sum(CARBON_AG, na.rm = TRUE),
      CPA = sum(CARBON_AG * TPA_UNADJ, na.rm = TRUE),
      BA_TREES = sum(if_else(DIA >= 1, TPA_UNADJ, 0), na.rm = TRUE),
      .groups = "keep"
    )
  
  stand_stats <- tbl(fia, 'COND') |>
    select(STATECD, COUNTYCD, PLOT, INVYR, STDAGE, BALIVE, FORTYPCD) |>
    semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
    group_by(STATECD, COUNTYCD, PLOT, INVYR) |>
    # QMD = sqrt(sum(DIA^2) / n)
    # Which is equivalent to
    # QMD = sqrt(sum(BALIVE * TPA_UNADJ) / (n * k)), where n is number of trees,
    # and k is π/576 ≅ 0.005454 for B in square feet and QMD in inches;
    # and k is π/40000 ≅ 0.0000785 for B in square meters and QMD in centimeters.
    # (see https://www.sciencedirect.com/science/article/pii/S2197562023000453 ,
    # https://doi.org/10.1016/j.fecs.2023.100114 )
    # When computing QMD from BA we need to use the same trees for BA and n;
    # FIADB data dictionary 2.5.51 BALIVE says "Basal area in square feet per
    # acre of all live trees ω1.0 inch d.b.h/d.r.c sampled in the condition."
    summarize(
      BALIVE = sum(BALIVE, na.rm = TRUE),
      FORTYPCD = max(FORTYPCD, na.rm = TRUE),
      STDAGE = max(STDAGE, na.rm = TRUE),
      .groups = "keep"
    ) |>
    ungroup() |>
    left_join(measyear, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    left_join(tree_stats, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    left_join(forest_type, by = join_by(FORTYPCD)) |>
    rename(`Forest Type` = FORTYPE) |>
    mutate(FORTYPCD = floor(FORTYPCD / 10) * 10) |>
    left_join(forest_type, by = join_by(FORTYPCD)) |>
    rename(`Forest Type Group` = FORTYPE) |>
    collect() |>
    modern_plots_filter() |>
    has_trees_filter() |>
    mutate(
      `Forest Type Group` = str_replace(`Forest Type Group`, ' group', ''),
      BALIVE_METRIC = conv_multiunit(BALIVE, "ft2 / acre", "m2 / hectare"),
      QMD = sqrt(BALIVE / (BA_TREES * (pi / 576))),
      QMD_METRIC = sqrt(BALIVE_METRIC / (BA_TREES * (pi / 40000))),
      CARBON_METRIC = conv_multiunit(CPA, "lbs / acre", "Mg / hectare")
    ) |> 
    group_by(STATECD, COUNTYCD, PLOT) |>
    mutate(
      BALIVE_START = if_else(MEASYEAR == min(MEASYEAR, na.rm = TRUE), BALIVE_METRIC, NA),
      BALIVE_DELTA = BALIVE_METRIC - max(BALIVE_START, na.rm = TRUE),
      YEARS = MEASYEAR - min(MEASYEAR, na.rm = TRUE)
    ) |> 
    ungroup()
  
  dbDisconnect(fia)
  remove(fia, measyear, forest_type, tree_stats)
  
  write_rds(stand_stats, rds_file)
}
```

Plot location with visual distinction by ecotype and forest type

```{r plot_location_by_ecotype}
plot_location_tmp <- plot_location |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, long, lat, group)

plot_location_type <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  consolidate_forest_type_groups_filter() |>
  select(STATECD, COUNTYCD, PLOT, INVYR, ECOSUBCD, `Forest Type`, `Forest Type Group`) |>
  left_join(plot_location_tmp, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  mutate(
    # If we're just stripping off subregion, could also do this as
    #   substr(ECOSUBCD, 1, nchar(ECOSUBCD) - 1)
    # but using sub() gives us more flexibility.
    ECOCD = sub(
      x = ECOSUBCD,
      # M? - Mountain
      # \d+ - Region
      # [A-Z] - Ecoregion
      # [a-z] - Ecosubregion
      pattern = "(M?)(\\d+)([A-Z])([a-z])",
      replacement = "\\1\\2\\3"
    )
  )

ggplot(map_states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
#  geom_point(plot_location_type, mapping = aes(long, lat, group = group, color = `Forest Type Group`)) +
  geom_point(
    plot_location_type,
    mapping = aes(long, lat, group = group, color = ECOCD),
#    show.legend = FALSE
  ) +
  coord_quickmap()

remove(plot_location_tmp)
```

```{r plot_location_by_forest_type}
ggplot(map_states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(
    plot_location_type,
    mapping = aes(long, lat, group = group, color = `Forest Type Group`)) +
  coord_quickmap()
```

Look at BA over time; first, by stand age, then as change over calendar time.

```{r balive_vs_stdage}
ggplot(
    data = stand_stats |>
      consolidate_forest_type_groups_filter() |>
      filter(!is.na(STDAGE)),
    mapping = aes(x = STDAGE, y = BALIVE_METRIC)
  ) +
  geom_point(alpha = 0.25) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nMeasured BA (m²/ha) vs Stand Age")
```

```{r balive_delta_vs_years}
ggplot(
    stand_stats |>
      consolidate_forest_type_groups_filter() |>
      filter(YEARS > 10),
    aes(x = YEARS, y = BALIVE_DELTA)
  ) +
  geom_point(
    size = 2,
    alpha = 0.25,
  ) +
  geom_abline(intercept = 0, slope = 0) +
  scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20, 22)) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nChange in FIA Measured BA (m² / ha) vs. Projection Years")
```

```{r seen_types}
latest_measyear <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    MEASYEAR = max(MEASYEAR),
    .groups = "keep"
  ) |>
  ungroup()

seen_types <- stand_stats |>
  semi_join(latest_measyear, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR)) |>
  group_by(`Forest Type Group`) |>
  summarize(
    CARBON_AG_METRIC = sum(conv_unit(CARBON_AG, "lbs", "Mg")),
    .groups = "keep"
  )

seen_types |>
  ggplot(
    aes(y = fct_reorder(`Forest Type Group`, CARBON_AG_METRIC), x = CARBON_AG_METRIC)
  ) +
  scale_x_log10() +
  geom_col() +
  ggtitle("Total Carbon by Forest Type Group (Mg)") +
  ylab("Forest Type") +
  xlab("Carbon")
```

## Run FVS

### Generate Keyfile

An FVS run is scripted by a keyfile. The keyfile describes how to run the
model and extensions, including where to read input, all parameters to
control processing, and where to write output.

The keyfile is structured by stand; each stand is a separate run of the
model.

To run in parallel, a separate keyfile must be generated for each partition
to be run in parallel. Each partition must send its output to a separate
location, and these can be assembled into a single output as a post-
processing step.

#### Stand Identification

For each stand, we need:

-  StdIdent: Stand Identifier, from fia.FVS_STANDINIT_PLOT.FVS_STAND_ID
-  StandCN: Stand control number, from fia.PLOT.CN
-  MgmtId: Management ID, for no treatment, this is NONE

#### Time

We will run the model from first measurement year to last measurement year,
with as many 10-year timesteps as we can get. We will add an initial timestep
that is less than 10 years to get to a 10 year boundary. We choose a 10-year
timestep because FVSne is calibrated to 10 years, and running with a different
length timestep introduces bias. The bias is less with shorter timesteps than
with longer timesteps, so using a short timestep to adjust length introduces
less bias than using a long timestep.

There are two years of interest for each plot: FIRSTYEAR, which is
the minimum fia.PLOT.MEASYEAR for the modern plot design; and
LASTYEAR, which is the maximum of the same.

-  InvYear: Inventory Year, set to FIRSTYEAR
-  TimeInt: Time Interval, there may be two entries:
   -  TimeInt 0: Default time interval, 10 years
   -  TimeInt 1: First cycle time interval, (LASTYEAR - FIRSTYEAR) %% 10
-  NumCycle: Number of cycles to run, int((LASTYEAR - FIRSTYEAR) / 10) + 1,
   and +1 again if there is a TimeInt 1.

Note that the number of cycles is the number of full 10-year cycles
plus one if there is a short first cycle. Since metrics are printed at the start
of each cycle, we need LASTYEAR to be the first year of a cycle, and work
backwards from that.

#### Input

There are two inputs, Stand and Tree. Both are configured to use a database
query.

Within a Database subsection:

-  DSNIn: Data Source Name (DSN) for input; SQLite filename
-  StandSQL: SQL query to fetch a stand, given %Stand_CN%
-  TreeSQL: SQL query to fetch all trees for a stand, given %Stand_CN%

#### Fire and Fuels

Carbon is calculated by the fire and fuels extension.

-  FMIn: Starts configuration of Fire and Fuels extension
-  CarbRept: Carbon Report; save to database (2)
-  CarbCut: Harvested Carbon Report; disable (0)
-  CarbCalc: Carbon calculation; metric (1)
-  FuelOut: Fuel Output, disable (0)
-  FuelRept: Fuel Report, disable (0)

Fire and Fuels also interacts with the database extension; it provides additional
Database keywords to configure Fire and Fuels output to the database.

Within a Database section:

-  CarbReDB: FVS_Carbon and FVS_Hrv_Carbon tables: database (2)
-  FuelReDB: FVS_Consumption table: database (2)
-  FuelsOut: FVS_Fuels table: database (2)

#### Regeneration, Ingrowth, and Establishment

The Northeastern variant is a partial establishment model, so it does not
automatically perform natural regeneration. We will therefore use actual
ingrowth from the FIA data.

##### Observed Ingrowth

fia.TREE_GRM_COMPONENT.MICR_COMPONENT_AL_FOREST is set to 'INGROWTH' when
the tree is judged to be 'established'. Only one record for the tree will
be marked 'INGROWTH'; it may have other records with other components, e.g.
'SURVIVOR'.

```{r ingrowth}
# We want ingrowth for all the plots in plot_grow_only
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

# Get PLT_CN for all plots in plot_grow_only, for all valid INVYR
plt_cns <- tbl(fia, 'PLOT') |>
  semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
  select(CN) |>
  distinct() |> # should be redundant, but doesn't appear to be
  rename(PLT_CN = CN)

# Get all the Tree Growth, Removal, and Mortality entries for those plots,
# where MICR_COMPONENT_AL_FOREST = 'INGROWTH'
ingrowth <- tbl(fia, 'TREE_GRM_COMPONENT') |>
  semi_join(plt_cns, by = join_by(PLT_CN)) |>
  ingrowth_filter() |>
  select(
    TRE_CN, PREV_TRE_CN, PLT_CN,# STATECD, COUNTYCD, PLOT,
    DIA_BEGIN, DIA_MIDPT, DIA_END, ANN_DIA_GROWTH, ANN_HT_GROWTH,
    MICR_COMPONENT_AL_FOREST, MICR_TPAGROW_UNADJ_AL_FOREST,
    SUBP_COMPONENT_AL_FOREST, SUBP_TPAGROW_UNADJ_AL_FOREST
  ) |>
  collect() # It ends up faster to materialize and copy back for pre_ingrowth
dbDisconnect(fia)
rm(fia, plt_cns)
nrow(ingrowth)
```

There are ~55,000 trees that ingrow over the 20 years, so about one tree per
plot per year.
Most of these trees are over the 3"DBH diameter limit on ingrowth set by FVS.

##### Ingrown Tree History

Trees >1" DBH that grow on the microplot are in the TREE table in FIA,
so in some cases we should be able to follow a tree back to the point when it
was <=3"DBH.

```{r prev_tree}
rds_file <- 'data/intermediate/prev_tree.rds'
if (file.exists(rds_file)) {
  prev_tree <- read_rds(rds_file)
} else {
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  fia_tree <- tbl(fia, 'TREE')
  fia_tree_cols <- function(.data) {
    .data |>
      select(
        CN, PLT_CN, PREV_TRE_CN,
        INVYR, MEASYEAR, STATECD, COUNTYCD, PLOT, SUBP, TREE, CONDID,
        STATUSCD, SPCD, DIA, DIAHTCD, HT, HTCD, ACTUALHT, BHAGE, TOTAGE, SITREE,
        PREVDIA, P2A_GRM_FLG, PREV_STATUS_CD, TPA_UNADJ
      )
  }
  
  measyear_mixin <- tbl(fia, 'PLOT') |>
    select(CN, MEASYEAR) |>
    rename(PLT_CN = CN)

    # Start with the ingrown trees to walk back the chain of previous trees
  prev_tre_cns <- ingrowth |>
    select(TRE_CN) |>
    filter(!is.na(TRE_CN)) |>
    rename(CN = TRE_CN) |>
    distinct()
  
  # SQLite3 takes days to do the semi_join at scale (despite joining on an index),
  # so we run in chunks of 1000 which completes in about 30 minutes.
  progress_total = nrow(prev_tre_cns)
  prev_tree <- NULL
  while (nrow(prev_tre_cns) > 0) {
    progress_remaining = nrow(prev_tre_cns)
    print(paste0(
      progress_remaining,
      " / ",
      progress_total,
      " remaining"
    ))
    chunk <- prev_tre_cns |> head(1000)
    more_prev_trees <- fia_tree |>
      semi_join(chunk, by = join_by(CN), copy = TRUE) |>
      left_join(measyear_mixin, by = join_by(PLT_CN)) |>
      fia_tree_cols() |>
      collect()
    prev_tree <- rbind(prev_tree, more_prev_trees) |>
      distinct() # Should be redundant, but isn't
  
    # Add all new prev_tre_cn to the pool
    prev_tre_cns <- prev_tre_cns |>
      union_all(
        more_prev_trees |>
        select(PREV_TRE_CN) |>
        filter(!is.na(PREV_TRE_CN)) |>
        rename(CN = PREV_TRE_CN)
      ) |>
      distinct() |>
      # remove already processed prev_tre_cns
      anti_join(chunk, by = join_by(CN))
  }
  
  next_tre_mixin <- prev_tree |>
    select(CN, PREV_TRE_CN) |>
    rename(NEXT_TRE_CN = CN, CN = PREV_TRE_CN)

  prev_tree <- prev_tree |>
    left_join(next_tre_mixin, by = join_by(CN))
  
  dbDisconnect(fia)
  remove(fia, fia_tree, fia_tree_cols, measyear_mixin, prev_tre_cns,
         progress_total, progress_remaining, chunk,
         more_prev_trees, next_tre_mixin)

  write_rds(prev_tree, rds_file)
}
```

Walk the tree history to see what diameter we can get to.

```{r starting_trees}
# CN - the latest CN for this tree
# DIA - the latest DIA for this tree
# PREV_TRE_CN - the next earlier CN for this tree, if any
# FRST_DIA - the earliest available DIA for this tree
# FRST_TRE_CN - the earliest available CN for this tree
starting_trees <- ingrowth |>
  select(TRE_CN, PREV_TRE_CN, DIA_END) |>
  rename(CN = TRE_CN, DIA = DIA_END) |>
  # Initialize FRST_TRE_CN to CN; we'll overwrite this
  # as we walk the chain of PREV_TRE_CNs
  mutate(FRST_DIA = DIA, FRST_TRE_CN = CN)

trees_rhs <- prev_tree |>
  select(CN, PREV_TRE_CN, DIA)

prev_tre_cns <- starting_trees |>
  select(PREV_TRE_CN) |>
  filter(!is.na(PREV_TRE_CN)) |>
  distinct()

iterations <- 0
while (nrow(prev_tre_cns) > 0) {
  print(paste0(
    "Iteration: ",
    iterations <- iterations + 1,
    ", CNs: ",
    nrow(prev_tre_cns)
  ))
  tmp_trees <- starting_trees |>
    left_join(trees_rhs, by = join_by(PREV_TRE_CN == CN))
  starting_trees <- tmp_trees |>
    rename(DIA = DIA.x) |>
    mutate( # Update FRST_DIA
      FRST_DIA = if_else(is.na(DIA.y), FRST_DIA, DIA.y)
    ) |>
    mutate( # Update FRST_CN
      FRST_TRE_CN = if_else(is.na(PREV_TRE_CN), FRST_TRE_CN, PREV_TRE_CN)
    ) |>
    mutate( # Move PREV_TRE_CN one time hop
      PREV_TRE_CN = PREV_TRE_CN.y
    ) |>
    select(CN, PREV_TRE_CN, DIA, FRST_TRE_CN, FRST_DIA)
  prev_tre_cns <- tmp_trees |>
    select(PREV_TRE_CN.y) |>
    rename(PREV_TRE_CN = PREV_TRE_CN.y) |>
    filter(!is.na(PREV_TRE_CN))
}

measyear_mixin <- prev_tree |>
  select(CN, MEASYEAR)

starting_trees <- starting_trees |>
  left_join(measyear_mixin, by = join_by(CN)) |>
  left_join(
    measyear_mixin |> rename(FRST_MEASYEAR = MEASYEAR),
    by = join_by(FRST_TRE_CN == CN)
  )

rm(trees_rhs, prev_tre_cns, tmp_trees, iterations)
```

How many trees ingrow with DBH>3?
```{r dbh_gt_3}
prev_tree |> filter(DIA > 3) |> nrow()
```

How many of those are traceable back to when they had DBH <= 3?
```{r dbh_le_3}
starting_trees |> filter(DIA > 3 & FRST_DIA <= 3) |> nrow() 
```

For the remaining ~44,500 trees, we will need to back-project. TREE_GRM_COMPONENT
provides annualized growth rates for both DIA and HT.

##### Back-Projecting Trees

fia.TREE_GRM_COMPONENT.ANN_DIA_GROWTH specifies annual diameter growth rate.
Looking at the values in this column, they seem small. We can check the
stated growth rate for trees where we have a previous observation.

```{r fia_growth_rate}
fia_growth_rate <- starting_trees |>
  filter(FRST_DIA < DIA) |>
  # Add on FIA growth rate
  left_join(ingrowth |> select(TRE_CN, ANN_DIA_GROWTH), by = join_by(CN == TRE_CN)) |>
  mutate(DIA_PROJ = DIA - (MEASYEAR - FRST_MEASYEAR) * ANN_DIA_GROWTH) |>
  mutate(DIA_ERR = (DIA_PROJ - FRST_DIA) / FRST_DIA) |>
  arrange(DIA_ERR)

# How many of these get within 10% of starting diameter?
fia_growth_rate |> filter(abs(DIA_ERR) < 0.1) |> nrow() /
  fia_growth_rate |> nrow()
```

This shows that using the FIA growth rate, only 34% of trees back-project
to within 10% of their first surveyed diameter, so we can't rely on the FIA
growth rate when we don't have previous tree records for an ingrown tree.

Ideas:

* use the earliest ANN_DIA_GROWTH to back-project
* compute our own growth rate from a subsequent tree record
* compute our own species-wide growth rate for the date range and site
  * can look at seedling / sapling growth rates and use them
  * can look at seedling / sapling growth rates and correlate them with
    growth rates for trees with DBH>=5, then use those modeled rates
  * can compute a species-wide growth rate for a date range
* plot change in dbh by age class, see if it is uniform
  * maybe look at the difference in annual diameter growth across classes
    within the same plot, in order to normalize for plot?
  * by species
  * by stand class - new growth / secondary / tertiary / old growth

Notes:

* Regeneration is heavily influenced by many things, from canopy structure
  to seed availability to predation to timing of canopy opening
* See competing articles on "Oh no! We get only sugar maple and no beech!"
  vs. "Oh no! We get only beech and no sugar maple!"
* The best indicator of regeneration will unquestionably be actual regeneration
* "composition is stabilized by local landforms and that diversity increases
  with hydrologic catchment area"

> TODO Nik: get subsequent trees the same way we got previous trees. Use
> DIA to compute a growth rate. Back-project that and see how accurate it is.

Find the diameter growth rate, per species, per plot, over time.

```{r tree_growth}
rds_file <- 'data/intermediate/tree_growth.rds'
if (file.exists(rds_file)) {
  tree_growth <- read_rds(rds_file)
} else {
  # FIA.TREE.CN - sequence number
  # FIA.TREE.TREE - TREE number
  # FIA.TREE.CONDID - condition class; 1 = live tree
  # FIA.TREE.SPCD - species code
  # FIA.TREE.DIA - current diameter
  # FIA.TREE.DIAHTCD - where diameter was taken, 1 = DBH
  # FIA.TREE.HT - height
  # We want ingrowth for all the plots in plot_grow_only
  
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  measyear_mixin <- tbl(fia, 'PLOT') |>
    select(CN, MEASYEAR) |>
    rename(PLT_CN = CN)
  
  species_mixin <- tbl(fia, 'REF_SPECIES') |>
    select(SPCD, SCIENTIFIC_NAME)
  
  prev_tre_mixin <- tbl(fia, 'TREE') |>
    select(CN, PLT_CN, DIA) |>
    left_join(measyear_mixin, by = join_by(PLT_CN)) |>
    rename(
      PREV_TRE_CN = CN,
      PREV_PLT_CN = PLT_CN,
      PREV_MEASYEAR = MEASYEAR,
      PREV_DIA = DIA
    )
  
  tree_growth <- tbl(fia, 'TREE') |>
    semi_join(
      plot_grow_only |> arrange(STATECD, COUNTYCD, PLOT),
      by = join_by(STATECD, COUNTYCD, PLOT),
      copy = TRUE
    ) |>
    # Live trees
    filter(CONDID == 1) |>
    # Self-join to previous tree to get growth increment
    left_join(prev_tre_mixin, by = join_by(PREV_TRE_CN)) |>
    left_join(species_mixin, by = join_by(SPCD)) |>
    left_join(measyear_mixin, by = join_by(PLT_CN)) |>
    mutate(
      DIA_INCR = DIA - PREV_DIA,
      AGE_INCR = MEASYEAR - PREV_MEASYEAR,
      ANN_DIA_GROWTH = DIA_INCR / AGE_INCR
    ) |>
    # Many trees will have no previous tree, filter those out.
    filter(!is.na(PREV_TRE_CN)) |>
    select(
      CN, PREV_TRE_CN, PLT_CN, PREV_PLT_CN,
      STATECD, COUNTYCD, PLOT, SUBP, TREE, SPCD, SCIENTIFIC_NAME,
      MEASYEAR, PREV_MEASYEAR, DIA, PREV_DIA, DIA_INCR, AGE_INCR, ANN_DIA_GROWTH
    ) |>
    arrange(STATECD, COUNTYCD, PLOT, SUBP, TREE, MEASYEAR) |>
    collect()
  
  dbDisconnect(fia)
  rm(fia, measyear_mixin, species_mixin, prev_tre_mixin)
  
  write_rds(tree_growth, rds_file)
}
```

```{r tree_growth_rate}
tree_growth_rate <- tree_growth |>
  group_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD) |>
  summarize(
    PREV_MEASYEAR = min(PREV_MEASYEAR, na.rm = TRUE),
    DIA_INCR = mean(DIA_INCR, na.rm = TRUE),
    ANN_DIA_GROWTH = mean(ANN_DIA_GROWTH, na.rm = TRUE),
    .groups = 'keep'
  ) |>
  ungroup()
```

Can we use that to back-project ingrown trees?

```{r manual_back_projection}
location_mixin <- prev_tree |>
  select(CN, STATECD, COUNTYCD, PLOT, SPCD)

manual_back_projection <- starting_trees |>
  filter(FRST_DIA < DIA) |>
  left_join(location_mixin, by = join_by(CN)) |>
  # Add on growth rate
  left_join(tree_growth_rate, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)) |>
  mutate(DIA_PROJ = DIA - (MEASYEAR - FRST_MEASYEAR) * ANN_DIA_GROWTH) |>
  mutate(DIA_ERR = (DIA_PROJ - FRST_DIA) / FRST_DIA) |>
  arrange(DIA_ERR)
print(manual_back_projection|>filter(is.na(DIA_ERR))|>nrow())
manual_back_projection |> filter(abs(DIA_ERR) < 0.1) |> nrow() /
  manual_back_projection |> nrow()
```

44%, which is less awful. Also, 36 trees end up with no ANN_DIA_GROWTH.
Next up:
* walk back using multiple growth rates
* back-project to when the tree was 3" DBH

prev_tree has one tree record for each year the tree was inventoried.
We can fill in a DIA_EST using the growth interval, and iterate until
they're all filled in. Or 4 times, which is safer.

```{r init_stepwise_manual_back_projection}
manual_back_projection <- prev_tree |>
  # Start with trees that have a previous tree (so we can back-project from them),
  # but have no next tree (so nothing can back-project to them)
  filter(!is.na(PREV_TRE_CN) & is.na(NEXT_TRE_CN)) |>
  select(CN, STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD, PREV_TRE_CN, NEXT_TRE_CN, DIA) |>
  # This will add: PREV_MEASYEAR, DIA_INCR, ANN_DIA_GROWTH
  left_join(
    growth_rate |> select(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD, DIA_INCR),
    by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)
  ) |>
  # We can get a perfect estimate if we know the actual value :-D
  mutate(DIA_EST = DIA) |>
  mutate(PREV_DIA_EST = DIA - DIA_INCR) |>
  mutate(DIA_ERR = abs((DIA - DIA_EST) / DIA))
# Back-projectable trees:
manual_back_projection |> nrow()
```

```{r stepwise_manual_back_projection}
prev_tre_cns <- manual_back_projection |>
  select(PREV_TRE_CN) |>
  filter(!is.na(PREV_TRE_CN)) |>
  distinct()

checkpoint <- function(.data, message) {
  print(message)
  .data
}

iterations <- 0
while (nrow(prev_tre_cns) > 0) {
  print(paste0(
    "Iteration: ",
    iterations <- iterations + 1,
    ", CNs: ",
    nrow(prev_tre_cns)
  ))
  tmp_trees <- prev_tree |>
    semi_join(prev_tre_cns, by = join_by(CN == PREV_TRE_CN)) |>
    select(CN, STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD, PREV_TRE_CN, NEXT_TRE_CN, DIA) |>
    # Join on growth rates
    left_join(
      growth_rate |> select(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD, DIA_INCR),
      by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)
    ) |>
    # Join on previously estimated diameter
    left_join(
      manual_back_projection |>
        select(PREV_TRE_CN, PREV_DIA_EST) |>
        rename(CN = PREV_TRE_CN, DIA_EST = PREV_DIA_EST),
      by = join_by(CN)
    ) |>
    mutate(DIA_ERR = abs((DIA - DIA_EST) / DIA)) |>
    # Estimate the next previous tree diameter
    mutate(PREV_DIA_EST = DIA_EST - DIA_INCR)
  manual_back_projection <- bind_rows(manual_back_projection, tmp_trees)
  # The next set of prev_tre_cns is:
  prev_tre_cns <- manual_back_projection |>
    # All PREV_TRE_CN mentioned
    select(PREV_TRE_CN) |>
    filter(!is.na(PREV_TRE_CN)) |>
    distinct() |>
    # that have not already been processed
    anti_join(
      manual_back_projection |>
        select(CN) |>
        filter(!is.na(CN)) |>
        distinct(),
      by = join_by(PREV_TRE_CN == CN)
    )
}
print(manual_back_projection|>filter(is.na(DIA_ERR))|>nrow())
manual_back_projection |> filter(abs(DIA_ERR) < 0.1) |> nrow() /
  manual_back_projection |> nrow()
```

Up to 70% WOOOO!!!

##### Translating to FVS

For each timestep, we will find the trees that establish during that timestep,
and add a record describing the tree at the time of establishment.

Note that FIA establishes at 5" DBH, whereas FVS establishes at 3" DBH,
and FVS puts an upper bound on height based on expectations for 3" DBH trees.
We can follow PREV_TRE_CN backward to find when the tree was 3" DBH; note
that this might be a long time ago. As an alternative, we could multiply TPA
by DIA^2 / 3^2 and set the height to (3/DIA)*HT - this would give us the same
total basal area in trees of reduced height.

Because of the way time is set up in FVS, establishment is scheduled for the
year prior to the start of a cycle. Within the cycle, each tree that is
established gets its own Natural keyword. This specifies:

-  Year: The (actual) year in which the tree is marked as INGROWTH
-  Species: The 2-character FVS species code
-  TPA: Trees per acre; prefer the TPA from the tree record over TPAGROW_UNADJ
   from the establishment record (the two should be the same)
-  Survivorship: Always 100%
-  Age: average age at the year of establishment. Leave this blank.
-  Height: Average height.  Use fia.TREE.HT, but see above note.
-  Shade: 0 = uniform, 1 = prefer shade; 2 = prefer sun. Use 0.

FVS is semi-spatial; it is aware of subplots and microplots, and how many
trees are on each. There does not appear to be a way to designate which
subplot a tree establishes on; presumably, the TPA is distributed across
subplots.

#### Output

We use database output; it is easiest to work with. Many output options take
a parameter that is 0 to disable output, 1 for file output, 2 for database
output, and 3 for both file and database output.

Within a Database section:

-  DSNOut: Data Source Name (DSN) for output; SQLite filename
-  Summary: Configure FVS_Summary; use version 2
-  Computdb: Configure FVS_Compute; disable
-  MisRpts: Configure Mistletoe reports; disable

#### Processing Order

Each stand has its own section of the keyword file, including everything from
StdIdent to Process. Each stand is processed before moving to the next stand.

At the end of all stands, the Stop keyword tells FVS to exit cleanly.

#### Example

```
StdIdent
230202502686        NoManagement
StandCN
52967848010538
MgmtId
NONE
InvYear         2002
TimeInt            0        10
TimeInt            1         2
NumCycle           3

FMIn
CarbRept           2
CarbCut            2
CarbCalc           0         1    0.0425         9        11
FuelOut            2
FuelRept           2
End

Database

DSNIn
SQLite_FIADB_ENTIRE.db

StandSQL
SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL

TreeSQL
SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL

DSNOut
FVS_NoManagement_NONE.db

Summary            2
Computdb           0         1
MisRpts            2
CarbReDB           2
FuelReDB           2
FuelsOut           2

END

Process

Stop
```

#### Keword File Generation

Gather stand IDs and CNs for keywordfile generation.

We gather two series of stands:

-  stands_projected is a list of stands and inventory years to grow out to 2025
-  stands_surveyed is a list of stands and inventory years to grow for 0 years
   in each survey year.

When generating keyword files, we create one per partition,
distributing across partitions using round-robin on STAND_ID.

keywordfile_section is a function to generate a keywordfile section from
information about a run and a stand.

```{r keywordfile_section}
keywordfile_section <- function(Title, MgmtId, StandID, StandCN, FirstYear, LastYear, Partition) {
  TimeConfig <- fvs_TimeConfig(FirstYear, LastYear)
  c(
    fvs_kwd0("StdIdent"),
    paste0(StandID, " ", Title),
    fvs_kwd0("StandCN"),
    StandCN,
    fvs_kwd0("MgmtId"),
    MgmtId,
    TimeConfig,
    fvs_kwd0("FMIn"), # Fire and Fuels Extension
    fvs_kwd0("CarbRept"),
    fvs_kwd0("CarbCut"),
    fvs_kwd5("CarbCalc", 1, 1, 0.0425, 9, 11),
    fvs_kwd0("FuelOut"),
    fvs_kwd0("FuelRept"),
    fvs_kwd0("End"), # FMIn
    fvs_kwd0("Database"), # Database extension
    fvs_kwd0("DSNIn"),
    "SQLite_FIADB_ENTIRE.db",
    fvs_kwd0("StandSQL"),
    "SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'",
    fvs_kwd0("EndSQL"), # StandSQL
    fvs_kwd0("TreeSQL"),
    "SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'",
    fvs_kwd0("EndSQL"), # TreeSQL
    fvs_kwd0("DSNOut"),
    paste0("FVS_", Title, "_", MgmtId, "_", Partition, ".db"),
    fvs_kwd1("Summary",  2),
    fvs_kwd2("Computdb", 0, 1),
    fvs_kwd1("MisRpts",  2),
    fvs_kwd1("CarbReDB", 2),
    fvs_kwd1("FuelReDB", 2),
    fvs_kwd1("FuelsOut", 2),
    fvs_kwd0("End"), # Database
    fvs_kwd0("Process"),
    recursive = TRUE
  )
}

```

Find the stands we want to project; these are the grow-only stands starting
in their first measurement year.

```{r stands_projected}
timeframe <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    INVYR = min(INVYR),
    FIRSTYEAR = min(MEASYEAR, na.rm = TRUE),
    LASTYEAR = max(MEASYEAR, na.rm = TRUE),
    .groups = "keep"
  ) |>
  ungroup()


fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
fia_fvs_standinit_plot <- tbl(fia, 'FVS_StandInit_Plot') |>
  select(STAND_CN, STAND_ID)

stands_projected <- tbl(fia, 'PLOT') |>
  filter(DESIGNCD == 1) |>
  select(CN, STATECD, COUNTYCD, PLOT, INVYR) |>
  rename(STAND_CN = CN) |>
  inner_join(timeframe, by = join_by(STATECD, COUNTYCD, PLOT, INVYR), copy = TRUE) |>
  left_join(fia_fvs_standinit_plot, by = join_by(STAND_CN)) |>
  collect()

dbDisconnect(fia)
remove(fia, fia_fvs_standinit_plot)
```

The first run is to project from the first measurement year to 2025. These
are given management ID "NONE".

```{r FVS_Northeastern_NONE_part.key}
for (partition in 1:8) {
  filename <- paste0("data/fvs/FVS_Northeastern_NONE_", partition, ".key")
  unlink(filename)
  apply(
    stands_projected |> 
      filter((as.numeric(STAND_ID) %% 8) == (partition - 1)) |>
      arrange(STAND_ID),
    1,
    function(row) {
      write_lines(
        keywordfile_section(
          "Northeastern",
          "NONE",
          row['STAND_ID'],
          row['STAND_CN'],
          row['FIRSTYEAR'],
          row['LASTYEAR'],
          partition
        ),
        filename,
        append = TRUE
      )
    }
  )
  write_lines("Stop", filename, append = TRUE)
}
```

The second run is a zero-year projection to have FVS calculate the carbon
in surveyed stands in each year they are surveyed.

```{r stands_surveyed}
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
fia_fvs_standinit_plot <- tbl(fia, 'FVS_StandInit_Plot') |>
  select(STAND_CN, STAND_ID)

stands_surveyed <- tbl(fia, 'PLOT') |>
  select(CN, STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR, DESIGNCD) |>
  filter(DESIGNCD == 1) |>
  rename(STAND_CN = CN) |>
  semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
  left_join(fia_fvs_standinit_plot, by = join_by(STAND_CN)) |>
  collect()

dbDisconnect(fia)
remove(fia, fia_fvs_standinit_plot)
```

The second run is to do a 0-year projection for each measurement year. These
are given management ID "SRVY".

```{r FVS_Northeastern_SRVY_part.key}
for (partition in 1:8) {
  filename <- paste0("data/fvs/FVS_Northeastern_SRVY_", partition, ".key")
  unlink(filename)
  apply(
    stands_surveyed |>
      filter((as.numeric(STAND_ID) %% 8) == (partition - 1)) |>
      arrange(STAND_ID),
    1,
    function(row) {
      write_lines(
        keywordfile_section(
          "Northeastern",
          "SRVY",
          row['STAND_ID'],
          row['STAND_CN'],
          row['MEASYEAR'],
          row['MEASYEAR'],
          partition
        ),
        filename,
        append = TRUE
      )
    }
  )
  write_lines("Stop", filename, append = TRUE)
}
```

#### Run FVS.

```{r run_fvs}
# TODO nik: Run FVS directly from R.
# Batch file to run FVS in parallel:
# for %%p in (FVS_Northeastern_%1_*.key) do del %%~np.db
# for %%p in (FVS_Northeastern_%1_*.key) do start \FVS\FVSbin\FVSne.exe --keywordfile=%%p
```

## Results

### Load Results

Load the output from all FVS partitions into a single dataframe

```{r FVS_Carbon}
FVS_Carbon_NONE <- NULL
FVS_Carbon_SRVY <- NULL
FVS_Summary2_East_NONE <- NULL
FVS_Summary2_East_SRVY <- NULL

for (partition in 1:8) {
  fvs_out_db <- DBI::dbConnect(
    RSQLite::SQLite(),
    paste0('data/fvs/FVS_Northeastern_NONE_', partition, '.db')
  )
  fvs_carbon_tbl = tbl(fvs_out_db, 'FVS_Carbon') |>
    mutate(Partition = partition)
  fvs_summary2_east_tbl = tbl(fvs_out_db, 'FVS_Summary2_East') |>
    mutate(Partition = partition)

  FVS_Carbon_NONE <- bind_rows(FVS_Carbon_NONE, fvs_carbon_tbl |> collect())
  FVS_Summary2_East_NONE <- bind_rows(FVS_Summary2_East_NONE, fvs_summary2_east_tbl |> collect())
  
  dbDisconnect(fvs_out_db)

  fvs_out_db <- DBI::dbConnect(
    RSQLite::SQLite(),
    paste0('data/fvs/FVS_Northeastern_SRVY_', partition, '.db')
  )
  fvs_carbon_tbl = tbl(fvs_out_db, 'FVS_Carbon') |>
    mutate(Partition = partition)
  fvs_summary2_east_tbl = tbl(fvs_out_db, 'FVS_Summary2_East') |>
    mutate(Partition = partition)

  FVS_Carbon_SRVY <- bind_rows(FVS_Carbon_SRVY, fvs_carbon_tbl |> collect())
  FVS_Summary2_East_SRVY <- bind_rows(FVS_Summary2_East_SRVY, fvs_summary2_east_tbl |> collect())
  
  dbDisconnect(fvs_out_db)
}

remove(fvs_out_db, fvs_carbon_tbl, fvs_summary2_east_tbl)
```

Sanity check: did we get the outputs we requested?
```{r sanity-check-expected-output}
matched_carbon_tmp <- stands_projected |>
  left_join(
    FVS_Carbon_NONE |>
      select(StandID, Year, Aboveground_Total_Live) |> 
      rename(
        STAND_ID = StandID,
        FIRSTYEAR = Year,
        Starting_Carbon = Aboveground_Total_Live
      ),
    by = join_by(STAND_ID, FIRSTYEAR)
  ) |>
  left_join(
    FVS_Carbon_NONE |>
      select(StandID, Year, Aboveground_Total_Live) |>
      rename(
        STAND_ID = StandID,
        LASTYEAR = Year,
        Ending_Carbon = Aboveground_Total_Live
        ),
    by = join_by(STAND_ID, LASTYEAR)
  ) |>
  mutate(partition = (as.numeric(STAND_ID) %% 8) + 1)
missing_start <- matched_carbon_tmp |>
  filter(is.na(Starting_Carbon)) |> 
  nrow()
print(missing_start)
missing_end <- matched_carbon_tmp |>
  filter(is.na(Ending_Carbon)) |> 
  nrow()
print(missing_end)
stopifnot(missing_start == 0)
stopifnot(missing_end == 0)
remove(
  matched_carbon_tmp,
  missing_start,
  missing_end
)
```

Filter projections to corresponding observations

```{r projected_vs_measured}
projected_carbon_tmp <- FVS_Carbon_NONE |>
  select(StandID, Year, Total_Stand_Carbon) |>
  rename(Projected_Carbon = Total_Stand_Carbon)

projected_ba_tmp <- FVS_Summary2_East_NONE |>
  select(StandID, Year, BA) |>
  mutate(Projected_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare"))

projected_tmp <- projected_carbon_tmp |>
  full_join(projected_ba_tmp, by = join_by(StandID, Year)) |>
  mutate(STAND_ID = paste0(
     substring(StandID, 1, 2),
     substring(StandID, 5, 12)
  )) |>
  select(STAND_ID, Year, Projected_Carbon, Projected_BA)

surveyed_carbon_tmp <- FVS_Carbon_SRVY |>
  select(StandID, Year, Total_Stand_Carbon) |>
  rename(Measured_Carbon = Total_Stand_Carbon)

surveyed_ba_tmp <- FVS_Summary2_East_SRVY |>
  select(StandID, Year, BA) |>
  mutate(Measured_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare"))

surveyed_tmp <- surveyed_carbon_tmp |>
  full_join(surveyed_ba_tmp, by = join_by(StandID, Year)) |>
  mutate(STAND_ID = paste0(
     substring(StandID, 1, 2),
     substring(StandID, 5, 12)
  )) |>
  select(STAND_ID, Year, Measured_Carbon, Measured_BA)

projected_vs_measured <- stand_stats |>
  mutate(STAND_ID = sprintf(paste0(
    '%02d',  '%03d',   '%05d'),
    STATECD, COUNTYCD, PLOT
  )) |>
  rename(Year = MEASYEAR) |>
  select(
    STAND_ID, Year,
    STDAGE, `Forest Type`, `Forest Type Group`, ECOSUBCD,
    QMD, QMD_METRIC
  ) |>
  left_join(projected_tmp, by = join_by(STAND_ID, Year)) |>
  left_join(surveyed_tmp, by = join_by(STAND_ID, Year)) |>
  consolidate_forest_type_groups_filter() |>
  group_by(STAND_ID) |>
  mutate(
    ECOCD = substr(ECOSUBCD, 1, nchar(ECOSUBCD) - 1),
    First_Year = min(Year, na.rm = TRUE),
    Last_Year = max(Year, na.rm = TRUE),
    Starting_Carbon = max(if_else(Year == First_Year, Measured_Carbon, 0), na.rm = TRUE),
    Projected_Carbon_Delta = Projected_Carbon - Starting_Carbon,
    Projected_Carbon_Flux = if_else(Year == First_Year, 0, Projected_Carbon_Delta / (Year - First_Year)),
    Measured_Carbon_Delta = Measured_Carbon - Starting_Carbon,
    Measured_Carbon_Flux = if_else(Year == First_Year, 0, Measured_Carbon_Delta / (Year - First_Year)),
    Starting_BA = max(if_else(Year == First_Year, Measured_BA, 0), na.rm = TRUE),
    Projected_BA_Delta = Projected_BA - Starting_BA,
    Measured_BA_Delta = Measured_BA - Starting_BA
  ) |>
  ungroup() |>
  filter(Year == First_Year | Year == Last_Year) |>
  filter(!is.na(Projected_Carbon) & !is.na(Measured_Carbon)) |>
  mutate(Projection_Years = Year - First_Year) |>
  mutate(BA_Residual = Projected_BA - Measured_BA) |>
  mutate(BA_Error = 2 * abs(BA_Residual) / (Projected_BA + Measured_BA)) |>
  mutate(BA_Delta_Residual = Projected_BA_Delta - Measured_BA_Delta) |>
  mutate(Carbon_Residual = Projected_Carbon - Measured_Carbon) |>
  mutate(Carbon_Error = 2 * abs(Carbon_Residual) / (Projected_Carbon + Measured_Carbon)) |>
  mutate(Carbon_Delta_Residual = Projected_Carbon_Delta - Measured_Carbon_Delta) |>
  mutate(Carbon_Flux_Residual = Projected_Carbon_Flux - Measured_Carbon_Flux)

remove(
  projected_carbon_tmp,
  projected_ba_tmp,
  projected_tmp,
  surveyed_carbon_tmp,
  surveyed_ba_tmp,
  surveyed_tmp
)
```

Run a quick check to make sure the plots grew during the projection period,
rather than shrank.

```{r sanity-check-plots-grew}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Measured_BA_Delta)
  ) +
  geom_point(
    size = 2,
    alpha = 0.25,
  ) +
  geom_abline(intercept = 0, slope = 0) +
  scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20, 22)) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nChange in FVS Measured BA (m² / ha) vs. Projection Years")
```

### Carbon Projection

```{r projected_carbon_vs_measured_carbon}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_Carbon, y = Projected_Carbon, color = Projection_Years)
  ) +
  geom_point(
#    size = 2,
    alpha = 0.25,
  ) +
  geom_abline(intercept = 0, slope = 1) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjected vs. Measured Carbon (Mg/ha)") +
  coord_cartesian(xlim = c(0, 300), ylim = c(0, 300))
```

```{r projected_carbon_vs_measured_carbon_with_trendline}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_Carbon, y = Projected_Carbon, color = Projection_Years)
  ) +
  geom_point(
#    size = 2,
    alpha = 0.25,
  ) +
  geom_abline(intercept = 0, slope = 1) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    color = 'brown',
    linetype = 'dashed',
    fullrange = TRUE,
    se = FALSE
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjected vs. Measured Carbon (Mg/ha)") +
  coord_cartesian(xlim = c(0, 300), ylim = c(0, 300))
```

#### Carbon Flux

Which is great, but for large BA plots, only a small portion will be projected,
so the error is masked by the pre-existing BA. So, instead, look at measured
vs. projected carbon change.

```{r measured_vs_projected_carbon_change}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_Carbon_Delta, y = Projected_Carbon_Delta, color = Projection_Years)
  ) +
  geom_point(
#    size = 2,
    alpha = 0.25,
  ) +
  geom_abline(intercept = 0, slope = 1) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    color = 'brown',
    linetype = 'dashed',
    fullrange = TRUE,
    se = FALSE
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjected vs. Measured Carbon Change (Mg/ha)") +
  coord_cartesian(xlim = c(-100, 100), ylim = c(-100, 100))
```

```{r measured_vs_projected_carbon_flux}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_Carbon_Flux, y = Projected_Carbon_Flux, color = Projection_Years)
  ) +
  geom_point(
#    size = 2,
    alpha = 0.25,
  ) +
  geom_abline(intercept = 0, slope = 1) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    color = 'brown',
    linetype = 'dashed',
    fullrange = TRUE,
    se = FALSE
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjected vs. Measured Carbon Flux (Mg/ha/year)") +
  coord_cartesian(xlim = c(-10, 10), ylim = c(-10, 10))
```

#### Residuals

Let's look at carbon flux residuals.
This is Mg of carbon per hectare per year.

```{r carbon-flux-by-forest-type}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(Carbon_Flux_Residual, fct_reorder(`Forest Type Group`, Measured_Carbon, .fun = sum))
  ) +
  geom_vline(xintercept = 0, color = 'red') +
  geom_boxplot(varwidth = TRUE) +
  # scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  geom_point(
    data = projected_vs_measured |>
      filter(Projection_Years > 0) |> 
      group_by(`Forest Type Group`) |> 
      summarize(
        Measured_Carbon_Flux = mean(Measured_Carbon_Flux),
        Measured_Carbon = sum(Measured_Carbon),
        .groups = 'keep'
      ) |> 
      ungroup(),
    aes(Measured_Carbon_Flux),
    color = 'blue',
    shape = 4,
    size = 3
  ) +
  ggtitle(paste0(
    "FVS Projected Carbon Flux Residual by Forest Type Group",
    "\n",
    "for Grow-Only FIA Plots in the Northeast"
  )) +
  xlab(paste0(
    "Carbon Flux Residual (Mg/ha/year)",
    "\n",
    "(X = Mean Measured Carbon Flux)"
  )) +
  ylab("Forest Type Group")

```

```{r carbon-flux-by-forest-type-detail}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(Carbon_Flux_Residual, fct_reorder(`Forest Type Group`, Measured_Carbon, .fun = sum))
  ) +
  geom_vline(xintercept = 0, color = 'red') +
  geom_boxplot(varwidth = TRUE) +
  geom_point(
    data = projected_vs_measured |>
      filter(Projection_Years > 0) |> 
      group_by(`Forest Type Group`) |> 
      summarize(
        Measured_Carbon_Flux = mean(Measured_Carbon_Flux),
        Measured_Carbon = sum(Measured_Carbon),
        .groups = 'keep'
      ) |> 
      ungroup(),
    aes(Measured_Carbon_Flux),
    color = 'blue',
    shape = 4,
    size = 3
  ) +
#  scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  coord_cartesian(xlim = c(-2, 2)) +
  scale_x_continuous(breaks = c(-2, -1, 0, 1, 2)) +
  ggtitle(paste0(
    "FVS Projected Carbon Flux Residual by Forest Type Group",
    "\n",
    "for Grow-Only FIA Plots in the Northeast"
  )) +
  xlab(paste0(
    "Carbon Flux Residual (Mg/ha/year)",
    "\n",
    "(X = Mean Measured Carbon Flux)"
  )) +
  ylab("Forest Type Group")
```

```{r carbon-flux-by-ecoregion}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(Carbon_Flux_Residual, fct_reorder(ECOCD, Measured_Carbon, .fun = sum))
  ) +
  geom_vline(xintercept = 0, color = 'red') +
  geom_boxplot(varwidth = TRUE) +
#  scale_y_discrete(guide = guide_axis(n.dodge = 2)) +
  coord_cartesian(xlim = c(-2, 2)) +
  scale_x_continuous(breaks = c(-2, -1, 0, 1, 2)) +
  ggtitle("Grow-Only Stands\nCarbon Flux Residual by Ecoregion") +
  xlab("Carbon Flux Residual (Mg/ha/year)")
```

#### Residuals vs. Years Projected

```{r carbon_residual_vs_projection_years}
ggplot(
    projected_vs_measured|> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Carbon_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Projection Error (Mg/ha) vs. Projection Years")
```


```{r carbon_error_vs_projection_years}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Carbon_Error)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  coord_cartesian(xlim = c(10, 20), ylim = c(0, 1)) +
  scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20)) +
  ggtitle("Grow-Only Stands\nCarbon Projection Error (fraction) vs. Projection years")
  
```

```{r carbon_flux_residual_vs_projection_years}
ggplot(
    projected_vs_measured|> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Carbon_Flux_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Projection Flux Residual (Mg/ha) vs. Projection Years")
```

#### Residuals vs. BA

```{r carbon_residual_vs_measured_ba}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    mapping = aes(x = Measured_BA, y = Carbon_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Projection Residuals (Mg/ha) vs. Measured BA (m²/ha)")
  
```


```{r carbon_error_vs_measured_ba}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      filter(Carbon_Error < 1),
    aes(x = Measured_BA, y = Carbon_Error)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Projection Error (fraction) vs. Measured BA (m² / ha)")
```

This omits outliers; looking just at the outliers (error >= 2x value):

```{r carbon_error_vs_measured_ba_outliers}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      filter(Carbon_Error >= 1),
    aes(x = Measured_BA, y = Carbon_Error)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  coord_cartesian(xlim = c(0, 80), ylim = c(-15, 15)) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Projection Error Outliers vs. Measured BA (m² / ha)")

```

```{r carbon_flux_residual_vs_measured_ba}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    mapping = aes(x = Measured_BA, y = Carbon_Flux_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Flux Residual (Mg/ha) vs. Measured BA (m²/ha)")
  
```

#### Residuals vs. QMD

```{r carbon_residuals_vs_qmd}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> filter(QMD_METRIC < 100),
    aes(x = QMD_METRIC, y = Carbon_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Projection Error (Mg/ha) vs. Measured QMD (cm)")
```

```{r carbon_flux_residuals_vs_qmd}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> filter(QMD_METRIC < 100),
    aes(x = QMD_METRIC, y = Carbon_Flux_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Flux Residual (Mg/ha) vs. Measured QMD (cm)")
```

### Basal Area Projection

```{r projected_ba_vs_measured_ba}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_BA, y = Projected_BA, color = Projection_Years)
  ) +
  geom_point(
#    size = 2,
    alpha = 0.25,
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  geom_abline(intercept = 0, slope = 1) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjected vs. Measured Basal Area (m²/ha)")
```

#### Residuals vs. Years Projected

```{r ba_residual_vs_projection_years}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = BA_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20, 22)) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nBA Residual (m²/ha) vs. Projection Years")
  
```

```{r ba_error_vs_projection_years}
ggplot(
    projected_vs_measured |> filter(BA_Error < 1),
    aes(x = Projection_Years, y = BA_Error)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nBA Projection Error (fraction) vs. Projection years")
  
```

#### Residuals vs. QMD

```{r ba_residual_vs_qmd}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> filter(QMD_METRIC < 100),
    aes(x = QMD_METRIC, y = BA_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nBA Projection Residual (m²/ha) vs. Measured QMD (cm)")
```
