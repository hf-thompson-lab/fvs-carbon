---
title: "Nunery Keeton Revisited"
author: "Nikolaus Bates-Haus"
output:
  word_document: default
  html_document: default
  pdf_document: default
editor_options:
  markdown:
    wrap: 72
---

```{r setup, include=FALSE}
library(tidyverse)
library(reshape2) # for melt()
library(RSQLite)
library(htmltools)
library(rmarkdown)
library(dbplyr)
library(measurements)
library(maps)
library(pbapply) # Progress bar for long operations
```

```{r source-functions}
source('R/functions.R')
```

```{r species_mixin}
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

jenkins_spgrpcd_mixin <- read_csv(
    "data/raw/FIADB_11.5.17_JENKINS_SPGRPCD.csv", 
    col_types = cols(JENKINS_SPGRPCD = col_integer())
  ) |>
  select(JENKINS_SPGRPCD, NAME) |>
  rename(JENKINS_SPGRP_NAME = NAME)

species_mixin <- tbl(fia, 'REF_SPECIES') |>
  select(SPCD, GENUS, SPECIES, E_SPGRPCD, JENKINS_SPGRPCD, SCIENTIFIC_NAME) |>
  left_join(
    tbl(fia, 'REF_SPECIES_GROUP') |> distinct(SPGRPCD, NAME),
    by = join_by(E_SPGRPCD == SPGRPCD)
  ) |>
  rename(SPGRPCD = E_SPGRPCD, SPGRP_NAME = NAME) |>
  collect() |>
  left_join(jenkins_spgrpcd_mixin, by = join_by(JENKINS_SPGRPCD))

dbDisconnect(fia)

rm(fia, jenkins_spgrpcd_mixin)
```

## Grow-Only Plots in the Northeast

Find all FIA plots in the northeastern region that are grow-only, that have
a measurement year between 1999 and 2004, and have at least two measurements
between 1999 and 2024. We select 1999 becasue FIA changed
to the 4-subplot structure in 1999; we select 2004 so that we will have
at least 20 years of growth. We require two measurements so that we can compare
projected vs. actual growth between measurements.

Survey filters:

*  PLOT.MEASYEAR > 1999 - really, we want DESIGNCD (plot design) == 1
*  max(PLOT.MEASYEAR) - min(PLOT.MEASYEAR) >= 10
*  BALIVE > 0

Northeastern region:

*  SURVEY.RSCD == 24

Grow-only is described previously:

*  Only one condition: max(FIA.COND.CONDID) == 1
*  Survey was not skipped: COND.COND_STATUS_CD == 1
*  Plot was not disturbed: COND.DSTRBCD1 == 0 & COND.DSTRBCD2 == 0 & COND.DSTRBCD3 == 0
*  Plot was not treated: COND.TRTCD1 == 0 & TRTCD2 == 0 & TRTCD3 == 0

The functions in `functions.R` define these filters

Execute the filters to create a list of matching plots.

```{r plot_grow_only}
rds_file <- 'data/intermediate/plot_grow_only.rds'
if (file.exists(rds_file)) {
  plot_grow_only <- read_rds(rds_file)
} else {
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  fia_cond <- tbl(fia, 'COND') |>
    select(
      STATECD, COUNTYCD, PLOT, PLT_CN, CONDID, INVYR,
      COND_STATUS_CD, BALIVE, DSTRBCD1, DSTRBCD2, DSTRBCD3, TRTCD1, TRTCD2, TRTCD3
    )
  fia_plot <- tbl(fia, 'PLOT') |>
    # Narrow and rename columns to facilitate join
    select(CN, DESIGNCD, SRV_CN, MEASYEAR, ECOSUBCD) |>
    rename(PLT_CN = CN)
  fia_plotgeom <- tbl(fia, 'PLOTGEOM') |>
    # Narrow and rename columns to facilitate join
    select(CN, FVS_VARIANT) |>
    rename(PLT_CN = CN)
  
  plot_grow_only <- fia_cond |>
    left_join(fia_plot, by = join_by(PLT_CN)) |>
    left_join(fia_plotgeom, by = join_by(PLT_CN)) |>
    fvsne_plots_filter() |>
    modern_plots_filter() |>
    has_trees_filter() |>
    long_measurement_filter() |>
    forested_plots_filter() |>
    undisturbed_plots_filter() |>
    untreated_plots_filter() |>
    # single_condition_plots_filter() |>
    distinct(STATECD, COUNTYCD, PLOT) |>
    collect() |>
    arrange(STATECD, COUNTYCD, PLOT)
  
  dbDisconnect(fia)
  remove(fia, fia_cond, fia_plot, fia_plotgeom)
  
  write_rds(plot_grow_only, rds_file)
}
nrow(plot_grow_only)
```

### Locations

Where are these plots?

Fetch plots with measyear, invyr, latitude, longitude, and state information.

```{r plot_location}
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

# Survey has the research station code
fia_survey <- tbl(fia, 'SURVEY') |>
  select(CN, RSCD) |>
  rename(SRV_CN = CN)

# plot has invyr, measyr, lat and lon
fia_plot <- tbl(fia, 'PLOT') |>
  # Narrow and rename columns to facilitate join
  select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR, SRV_CN, ECOSUBCD, LAT, LON)

# research station has state name and abbreviation
fia_ref_research_station <- tbl(fia, 'REF_RESEARCH_STATION') |>
  select(STATECD, STATE_NAME, STATE_ABBR)

plot_location <- fia_plot |>
  semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
  left_join(fia_survey, by = join_by(SRV_CN)) |>
  left_join(fia_ref_research_station, by = join_by(STATECD)) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  # Pick just the first inventory year
  filter(min_rank(INVYR) == 1) |> 
  ungroup() |>
  collect() |>
  rename(
    long = LON,
    lat = LAT
  ) |>
  mutate(group = sprintf('%02d%03d%05d', STATECD, COUNTYCD, PLOT))

dbDisconnect(fia)
remove(fia, fia_plot, fia_survey, fia_ref_research_station)
```

How many plots are in each state?

```{r state_plot_counts}
state_plot_counts <- plot_location |>
  group_by(STATE_NAME) |>
  summarize(COUNT = n()) |>
  ungroup() |>
  arrange(desc(COUNT))
knitr::kable(state_plot_counts)
```

Show the plots on a map.

```{r map_states}
northeastern_states <- plot_location |>
  distinct(STATE_NAME) |>
  mutate(region = str_to_lower(STATE_NAME))
map_states <- map_data('state', northeastern_states$region)

ggplot(map_states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(data = plot_location, color = alpha("blue", alpha = 0.5)) +
  coord_quickmap()
```

### Stand Statistics

We can gather per-stand statistics such as BALIVE and CARBON_AG from the FIA
data for these plots over time.

```{r stand_stats}
rds_file <- 'data/intermediate/stand_stats.rds'
if (file.exists(rds_file)) {
  stand_stats <- read_rds(rds_file)
} else {
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  
  measyear <- tbl(fia, 'PLOT') |>
    select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR, DESIGNCD, ECOSUBCD)
  
  forest_type <- tbl(fia, 'REF_FOREST_TYPE') |>
    select(VALUE, MEANING) |>
    rename(FORTYPCD = VALUE) |>
    rename(FORTYPE = MEANING)
  
  tree_stats <- tbl(fia, 'TREE') |>
    select(STATECD, COUNTYCD, PLOT, CONDID, INVYR, DIA, CARBON_AG, TPA_UNADJ) |>
    group_by(STATECD, COUNTYCD, PLOT, CONDID, INVYR) |>
    summarize(
      CARBON_AG = sum(CARBON_AG, na.rm = TRUE),
      CPA = sum(CARBON_AG * TPA_UNADJ, na.rm = TRUE),
      BA_TREES = sum(if_else(DIA >= 1, TPA_UNADJ, 0), na.rm = TRUE),
      .groups = "keep"
    )
  
  stand_stats <- tbl(fia, 'COND') |>
    select(STATECD, COUNTYCD, PLOT, INVYR, STDAGE, BALIVE, FORTYPCD) |>
    semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
    group_by(STATECD, COUNTYCD, PLOT, INVYR) |>
    # QMD = sqrt(sum(DIA^2) / n)
    # Which is equivalent to
    # QMD = sqrt(sum(BALIVE * TPA_UNADJ) / (n * k)), where n is number of trees,
    # and k is π/576 ≅ 0.005454 for B in square feet and QMD in inches;
    # and k is π/40000 ≅ 0.0000785 for B in square meters and QMD in centimeters.
    # (see https://www.sciencedirect.com/science/article/pii/S2197562023000453 ,
    # https://doi.org/10.1016/j.fecs.2023.100114 )
    # When computing QMD from BA we need to use the same trees for BA and n;
    # FIADB data dictionary 2.5.51 BALIVE says "Basal area in square feet per
    # acre of all live trees ω1.0 inch d.b.h/d.r.c sampled in the condition."
    summarize(
      BALIVE = sum(BALIVE, na.rm = TRUE),
      FORTYPCD = max(FORTYPCD, na.rm = TRUE),
      STDAGE = max(STDAGE, na.rm = TRUE),
      .groups = "keep"
    ) |>
    ungroup() |>
    left_join(measyear, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    left_join(tree_stats, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
    left_join(forest_type, by = join_by(FORTYPCD)) |>
    rename(`Forest Type` = FORTYPE) |>
    mutate(FORTYPCD = floor(FORTYPCD / 10) * 10) |>
    left_join(forest_type, by = join_by(FORTYPCD)) |>
    rename(`Forest Type Group` = FORTYPE) |>
    collect() |>
    modern_plots_filter() |>
    has_trees_filter() |>
    mutate(
      `Forest Type Group` = str_replace(`Forest Type Group`, ' group', ''),
      BALIVE_METRIC = conv_multiunit(BALIVE, "ft2 / acre", "m2 / hectare"),
      QMD = sqrt(BALIVE / (BA_TREES * (pi / 576))),
      QMD_METRIC = sqrt(BALIVE_METRIC / (BA_TREES * (pi / 40000))),
      CARBON_METRIC = conv_multiunit(CPA, "lbs / acre", "Mg / hectare")
    ) |> 
    group_by(STATECD, COUNTYCD, PLOT) |>
    mutate(
      BALIVE_START = if_else(MEASYEAR == min(MEASYEAR, na.rm = TRUE), BALIVE_METRIC, NA),
      BALIVE_DELTA = BALIVE_METRIC - max(BALIVE_START, na.rm = TRUE),
      YEARS = MEASYEAR - min(MEASYEAR, na.rm = TRUE)
    ) |> 
    ungroup()
  
  dbDisconnect(fia)
  remove(fia, measyear, forest_type, tree_stats)
  
  write_rds(stand_stats, rds_file)
}
```

Plot location with visual distinction by ecotype and forest type

```{r plot_location_by_ecotype}
plot_location_tmp <- plot_location |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, long, lat, group)

plot_location_type <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  consolidate_forest_type_groups_filter() |>
  select(STATECD, COUNTYCD, PLOT, INVYR, ECOSUBCD, `Forest Type`, `Forest Type Group`) |>
  left_join(plot_location_tmp, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  mutate(
    # If we're just stripping off subregion, could also do this as
    #   substr(ECOSUBCD, 1, nchar(ECOSUBCD) - 1)
    # but using sub() gives us more flexibility.
    ECOCD = sub(
      x = ECOSUBCD,
      # M? - Mountain
      # \d+ - Region
      # [A-Z] - Ecoregion
      # [a-z] - Ecosubregion
      pattern = "(M?)(\\d+)([A-Z])([a-z])",
      replacement = "\\1\\2\\3"
    )
  )

ggplot(map_states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
#  geom_point(plot_location_type, mapping = aes(long, lat, group = group, color = `Forest Type Group`)) +
  geom_point(
    plot_location_type,
    mapping = aes(long, lat, group = group, color = ECOCD),
#    show.legend = FALSE
  ) +
  coord_quickmap() +
  ggtitle("Plot Location with Ecoregion")

remove(plot_location_tmp)
```

```{r plot_location_by_forest_type}
ggplot(map_states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(
    plot_location_type,
    mapping = aes(long, lat, group = group, color = `Forest Type Group`)) +
  coord_quickmap() +
  ggtitle("Plot Location with Forest Type")
```

Look at BA over time; first, by stand age, then as change over calendar time.

```{r balive_vs_stdage}
ggplot(
    data = stand_stats |>
      consolidate_forest_type_groups_filter() |>
      filter(!is.na(STDAGE)),
    mapping = aes(x = STDAGE, y = BALIVE_METRIC)
  ) +
  geom_point(alpha = 0.25) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nMeasured BA (m²/ha) vs Stand Age")
```

```{r balive_delta_vs_years}
ggplot(
    stand_stats |>
      consolidate_forest_type_groups_filter() |>
      filter(YEARS > 10),
    aes(x = YEARS, y = BALIVE_DELTA)
  ) +
  geom_point(
    size = 2,
    alpha = 0.25,
  ) +
  geom_abline(intercept = 0, slope = 0) +
  scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20, 22)) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nChange in FIA Measured BA (m² / ha) vs. Projection Years")
```

```{r seen_types}
latest_measyear <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    MEASYEAR = max(MEASYEAR),
    .groups = "keep"
  ) |>
  ungroup()

seen_types <- stand_stats |>
  semi_join(latest_measyear, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR)) |>
  group_by(`Forest Type Group`) |>
  summarize(
    CARBON_AG_METRIC = sum(conv_unit(CARBON_AG, "lbs", "Mg")),
    .groups = "keep"
  )

seen_types |>
  ggplot(
    aes(y = fct_reorder(`Forest Type Group`, CARBON_AG_METRIC), x = CARBON_AG_METRIC)
  ) +
  scale_x_log10() +
  geom_col() +
  ggtitle("Total Carbon by Forest Type Group (Mg)") +
  ylab("Forest Type") +
  xlab("Carbon")
```

### Regeneration, Ingrowth, and Establishment

The Northeastern variant is a partial establishment model, so it does not
automatically perform natural regeneration. We will therefore use actual
ingrowth from the FIA data.

#### Observed Ingrowth

fia.TREE_GRM_COMPONENT will mark a tree as 'INGROWTH' when
the tree is judged to be 'established', with a corresponding TREE record.
A tree marked 'INGROWTH' may have multiple TREE records if it is inventoried
after ingrowth, and if it grows on a microplot, in which case it will be
tracked from the time it is 1" DBH. If the tree grows on the microplot, then
its ingrowth is marked in MICR_COMPONENT_AL_FOREST; otherwise it is marked
in SUBP_COMPONENT_AL_FOREST. Multiple TREE_GRM_COMPONENT records for the tree
can be marked 'INGROWTH', in different inventories. It may also have other
records with other components, e.g. trees on the microplot will have a
'SURVIVOR' record in each inventory prior to ingrowth.

```{r grm_ingrown}
# We want ingrowth for all the plots in plot_grow_only
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

# Get PLT_CN for all plots in plot_grow_only, for all valid INVYR
plt_cns_mixin <- tbl(fia, 'PLOT') |>
  semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
  select(CN, MEASYEAR) |>
  distinct() |> # should be redundant, but doesn't appear to be
  rename(PLT_CN = CN)

tree_mixin <- tbl(fia, 'TREE') |>
  select(CN, STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR) |>
  rename(TRE_CN = CN)

# Get all the Tree Growth, Removal, and Mortality entries for those plots that
# are marked as INGROWTH, either on a microplot or subplot.
grm_ingrown <- tbl(fia, 'TREE_GRM_COMPONENT') |>
  inner_join(plt_cns_mixin, by = join_by(PLT_CN)) |>
  ingrowth_filter() |>
  select(
    TRE_CN, PREV_TRE_CN, PLT_CN, MEASYEAR,
    DIA_BEGIN, DIA_MIDPT, DIA_END, ANN_DIA_GROWTH, ANN_HT_GROWTH,
    MICR_COMPONENT_AL_FOREST, MICR_TPAGROW_UNADJ_AL_FOREST,
    SUBP_COMPONENT_AL_FOREST, SUBP_TPAGROW_UNADJ_AL_FOREST
  ) |>
  # Pick only the first ingrowth record
  left_join(tree_mixin, by = join_by(TRE_CN)) |>
  group_by(STATECD, COUNTYCD, PLOT, SUBP, TREE) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  collect()
dbDisconnect(fia)
rm(fia, plt_cns_mixin)
print(paste0("Ingrown trees: ", grm_ingrown |> nrow()))
print(paste0(
  "  ",
  nrow(grm_ingrown) /
    nrow(plot_grow_only) /
    (max(grm_ingrown$MEASYEAR) - min(grm_ingrown$MEASYEAR)),
  " ingrown trees / plot / year"))
print(paste0("Ingrown trees over 3\" DBH: ", grm_ingrown |> filter(DIA_END > 3) |> nrow()))
```

#### FVS Restrictions on Ingrowth

FIA marks a tree as INGROWTH when it reaches 5" DBH; FVS Establishment
is restricted to trees <= 3" DBH:

Trees are injected into FVS via the Regeneration and Establishment model,
using the `Estab` keyword. This allows trees to be added to a plot during
a run. Normally these trees are seedlings, which the model will then grow;
the HTADJ keyword overrides the seedling processing and allows injection of
saplings.

The FVS guide to the Regeneration and Establishment model,
Appendix C on details for keywords, for HTADJ, says:

> Adjust regeneration tree heights before they are passed
> to the Prognosis Model. Heights after adjustment are
> bounded between the minimum establishment height
> listed in table 1 and the height of a tree 3 inches d.b.h.

```{r grm_ingrown_histogram}
grm_ingrown |>
  mutate(
    `> 3" DBH` = if_else(DIA_END > 3, MEASYEAR, NA),
    `≤ 3" DBH` = if_else(DIA_END <= 3, MEASYEAR, NA)
  ) |>
  select(TRE_CN, `> 3" DBH`, `≤ 3" DBH`) |>
  melt(
    id.vars = c('TRE_CN'),
    variable.name = 'Diameter at Ingrowth',
    value.name = 'Year'
  ) |>
  filter(!is.na(Year)) |>
  ggplot(aes(Year, fill = `Diameter at Ingrowth`)) +
    geom_histogram(binwidth = 1) +
    scale_fill_manual(values = c("red", "blue")) +
    ggtitle('Ingrown trees on NRS grow-only plots') +
    xlab('Year') +
    ylab('Count')

```

```{r grm_ingrown_boxplot}
grm_ingrown |>
  select(DIA_END) |>
  ggplot(aes(DIA_END)) +
  geom_boxplot() +
  scale_y_continuous(breaks = NULL) +
  xlab('Diameter at Ingrowth (inches)') +
  geom_vline(xintercept = 3, color = 'red')
```

There are ~55,000 trees that ingrow over the 25 years, so about 2 trees per
plot per 3 years.
Most of these trees are over the 3"DBH diameter limit on ingrowth set by FVS.

#### Tree History

Trees >=1" DBH that grow on the microplot are in the TREE table in FIA,
so in some cases we should be able to follow a tree back to the point when it
was <=3" DBH. The microplot is ~8% of the plot, so we would expect ~8% of
ingrown trees to have observations prior to ingrowth, assuming that it
normally takes more than the average inter-inventory timespan (5 years) for
a tree to reach ingrowth size.

For this section, we'll use the following terminology, aligned with the FIA
database:

- Tree - an individual observation of a tree; a single record in the TREE table
- Tree History - a sequence of Trees linked by CN / PREV_TRE_CN in the TREE table
- First Tree - the Tree in a Tree History with the earliest INVYEAR
- Last Tree - the Tree in a Tree History with the latest INVYEAR

We identify a Tree History by the CN of the last tree in the history.

tree_ingrown - all tree records for ingrown trees, including pre- and
               post-ingrowth

NB: This takes about 5 minutes on a laptop.

```{r tree_ingrown}
rds_file <- 'data/intermediate/tree_ingrown.rds'
if (file.exists(rds_file)) {
  tree_ingrown <- read_rds(rds_file)
} else {
  # CNs of the ingrown trees; these will be the heads of the tree histories
  grm_ingrown_cns <- grm_ingrown |>
    select(TRE_CN) |>
    rename(CN = TRE_CN)
  
  # Re-use the database connection
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

  # fetch_trees - fetch all of the trees that have ever been live on a plot
  fetch_trees <- function(row) {
    statecd <- row[["STATECD"]]
    countycd <- row[["COUNTYCD"]]
    plot <- row[["PLOT"]]

    measyear_mixin <- tbl(fia, 'PLOT') |>
      select(CN, MEASYEAR) |>
      rename(PLT_CN = CN)
  
    all_trees <- tbl(fia, 'TREE') |>
      filter(
        STATECD == statecd &
        COUNTYCD == countycd &
        PLOT == plot
      ) |>
      # Only live trees
      filter(CONDID == 1) |>
      left_join(measyear_mixin, by = join_by(PLT_CN)) |>
      select(
        CN, PLT_CN, PREV_TRE_CN,
        INVYR, MEASYEAR, STATECD, COUNTYCD, PLOT, SUBP, TREE, CONDID,
        STATUSCD, SPCD, DIA, DIAHTCD, HT, HTCD, ACTUALHT, BHAGE, TOTAGE, SITREE,
        PREVDIA, P2A_GRM_FLG, PREV_STATUS_CD, TPA_UNADJ
      ) |>
      collect()
    
    # Start with the trees at the time of ingrowth
    tree_ingrown <- all_trees |>
      semi_join(grm_ingrown_cns, by = join_by(CN))

    prev_tre_cns <- tree_ingrown |>
      select(PREV_TRE_CN) |>
      filter(!is.na(PREV_TRE_CN)) |>
      distinct() 

    while (nrow(prev_tre_cns) > 0) {
      more_trees <- all_trees |>
        semi_join(prev_tre_cns, by = join_by(CN == PREV_TRE_CN))
      tree_ingrown <- rbind(tree_ingrown, more_trees) |>
        distinct() # Should be redundant, but isn't
      prev_tre_cns <- more_trees |>
        select(PREV_TRE_CN) |>
        filter(!is.na(PREV_TRE_CN)) |>
        distinct()
    }
    return(tree_ingrown)
  }

  tree_ingrown <- reduce(
    pbapply(plot_grow_only, 1, fetch_trees),
    bind_rows
  )
  
  next_tre_mixin <- tree_ingrown |>
    select(CN, PREV_TRE_CN) |>
    rename(NEXT_TRE_CN = CN, CN = PREV_TRE_CN)

  tree_ingrown <- tree_ingrown |>
    left_join(next_tre_mixin, by = join_by(CN))
  
  dbDisconnect(fia)

  remove(fia, grm_ingrown_cns, next_tre_mixin)

  write_rds(tree_ingrown, rds_file)
}
```

Walk the tree history to see what diameter we can get to.

```{r tree_ingrown_last}
# CN - the latest CN for this tree
# DIA - the latest DIA for this tree
# PREV_TRE_CN - the next earlier CN in this tree history, if any
# FRST_DIA - the earliest available DIA in this tree history
# FRST_TRE_CN - the earliest available CN in this tree history
tree_ingrown_last <- grm_ingrown |>
  select(TRE_CN, PREV_TRE_CN, DIA_END) |>
  rename(CN = TRE_CN, DIA = DIA_END) |>
  # Initialize FRST_TRE_CN to CN; we'll overwrite this
  # as we walk the chain of PREV_TRE_CNs
  mutate(FRST_DIA = DIA, FRST_TRE_CN = CN)

trees_rhs <- tree_ingrown |>
  select(CN, PREV_TRE_CN, DIA)

tree_cns_todo <- tree_ingrown_last |>
  select(PREV_TRE_CN) |>
  filter(!is.na(PREV_TRE_CN)) |>
  distinct()

iterations <- 0
while (nrow(tree_cns_todo) > 0) {
  print(paste0(
    "Iteration: ",
    iterations <- iterations + 1,
    ", CNs: ",
    nrow(tree_cns_todo)
  ))
  tmp_trees <- tree_ingrown_last |>
    left_join(trees_rhs, by = join_by(PREV_TRE_CN == CN))
  tree_ingrown_last <- tmp_trees |>
    rename(DIA = DIA.x) |>
    mutate( # Update FRST_DIA
      FRST_DIA = if_else(is.na(DIA.y), FRST_DIA, DIA.y)
    ) |>
    mutate( # Update FRST_CN
      FRST_TRE_CN = if_else(is.na(PREV_TRE_CN), FRST_TRE_CN, PREV_TRE_CN)
    ) |>
    mutate( # Move PREV_TRE_CN one time hop
      PREV_TRE_CN = PREV_TRE_CN.y
    ) |>
    select(CN, PREV_TRE_CN, DIA, FRST_TRE_CN, FRST_DIA)
  tree_cns_todo <- tmp_trees |>
    select(PREV_TRE_CN.y) |>
    rename(PREV_TRE_CN = PREV_TRE_CN.y) |>
    filter(!is.na(PREV_TRE_CN))
}

measyear_mixin <- tree_ingrown |>
  select(CN, MEASYEAR)

tree_ingrown_last <- tree_ingrown_last |>
  left_join(measyear_mixin, by = join_by(CN)) |>
  left_join(
    measyear_mixin |> rename(FRST_MEASYEAR = MEASYEAR),
    by = join_by(FRST_TRE_CN == CN)
  )

rm(trees_rhs, tree_cns_todo, tmp_trees, iterations)
```

How many trees ingrow with DBH>3?
```{r dbh_gt_3}
tree_ingrown_last |> filter(DIA > 3) |> nrow()
```

How many of those are traceable back to when they had DBH <= 3?
```{r dbh_le_3}
tree_ingrown_last |> filter(DIA > 3 & FRST_DIA <= 3) |> nrow() 
```

For the remaining trees we will need to back-project.

#### Back-Projecting Trees

##### FIA Estimated Growth Rate

fia.TREE_GRM_COMPONENT.ANN_DIA_GROWTH specifies annual diameter growth rate.
Looking at the values in this column, they seem small. We can check the
growth rate for trees where we have a previous observation by projecting
diameter growth backwards to the first MEASYEAR and seeing how close we
get to the first observed diameter.

```{r tree_growth_fia}
tree_growth_fia <- tree_ingrown_last |>
  filter(FRST_DIA < DIA) |>
  # Add on FIA growth rate
  left_join(grm_ingrown |> select(TRE_CN, ANN_DIA_GROWTH), by = join_by(CN == TRE_CN)) |>
  mutate(DIA_EST = DIA - (MEASYEAR - FRST_MEASYEAR) * ANN_DIA_GROWTH) |>
  mutate(DIA_ERR = abs(100 * (DIA_EST - FRST_DIA) / FRST_DIA)) |>
  filter(!is.na(DIA_ERR)) |>
  arrange(DIA_ERR)

ggplot(tree_growth_fia, aes(DIA_ERR, after_stat(100 * count / sum(count)))) +
  geom_histogram(binwidth = 10, position = position_nudge(5)) +
  #geom_freqpoly() +
  ggtitle("Diameter Projection Error using FIA Growth Rate") +
  ylab("Frequency (%)") +
  xlab("Error (%) (binwidth = 10%)")
```

This shows that using the FIA growth rate, only 20% of trees back-project
to within 10% of their first surveyed diameter, so we can't rely on the FIA
growth rate when we don't have previous tree records for an ingrown tree.

Notes:

* Regeneration is heavily influenced by many things, from canopy structure
  to seed availability to predation to timing of canopy opening
* See competing articles on "Oh no! We get only sugar maple and no beech!"
  vs. "Oh no! We get only beech and no sugar maple!"
* "composition is stabilized by local landforms and [...] diversity increases
  with hydrologic catchment area"
* The best indicator of regeneration will unquestionably be actual regeneration

##### Observed Growth Rates

To estimate the time at which an ingrown tree was 3" DBH, we can project
growth backward in time based on the growth rates of similar trees. Defining
"similar" needs to be done with care. We can validate a model using the 8% of
ingrown trees for which we have measurements prior to ingrowth. We can use
our method to project these trees back in time to the earliest measurement,
and see how close we get to the measured value.

To do this, we need to caputre how much each tree grew in each inventory.

tree_growth - adds DIA/HT_DELTA, AGE_DELTA, and ANN_DIA/HT_DELTA to each tree
  *_DELTA - diameter change since previous inventory
  *_DELTA - age change since previous inventory
  ANN_*_DELTA - annualize rate of diameter change since previous inventory
  
Note that tree_growth is all trees, not just ingrown trees.

```{r tree_growth}
rds_file <- 'data/intermediate/tree_growth.rds'
if (file.exists(rds_file)) {
  tree_growth <- read_rds(rds_file)
} else {
  # FIA.TREE.CN - sequence number
  # FIA.TREE.TREE - TREE number
  # FIA.TREE.CONDID - condition class; 1 = live tree
  # FIA.TREE.SPCD - species code
  # FIA.TREE.DIA - current diameter
  # FIA.TREE.DIAHTCD - where diameter was taken, 1 = DBH
  # FIA.TREE.HT - height
  # FIA.TREE.SPGRPCD is broader than SPCD, group by that instead
  # FIA.TREE.CCLCD - Crown Class code
  # We want ingrowth for all the plots in plot_grow_only
  
  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  measyear_mixin <- tbl(fia, 'PLOT') |>
    select(CN, MEASYEAR) |>
    rename(PLT_CN = CN)
  
  prev_tre_mixin <- tbl(fia, 'TREE') |>
    select(CN, PLT_CN, DIA, HT) |>
    left_join(measyear_mixin, by = join_by(PLT_CN)) |>
    rename(
      PREV_TRE_CN = CN,
      PREV_PLT_CN = PLT_CN,
      PREV_MEASYEAR = MEASYEAR,
      PREV_DIA = DIA,
      PREV_HT = HT
    )

  tree_growth <- tbl(fia, 'TREE') |>
    semi_join(
      plot_grow_only |> arrange(STATECD, COUNTYCD, PLOT),
      by = join_by(STATECD, COUNTYCD, PLOT),
      copy = TRUE
    ) |>
    # Live trees
    filter(CONDID == 1) |>
    # Many trees will have no previous tree, filter those out.
    filter(!is.na(PREV_TRE_CN)) |>
    # Self-join to previous tree to get growth increment
    left_join(prev_tre_mixin, by = join_by(PREV_TRE_CN)) |>
    left_join(measyear_mixin, by = join_by(PLT_CN)) |>
    mutate(
      DIA_DELTA = DIA - PREV_DIA,
      AGE_DELTA = MEASYEAR - PREV_MEASYEAR,
      ANN_DIA_DELTA = DIA_DELTA / AGE_DELTA,
      HT_DELTA = HT - PREV_HT,
      ANN_HT_DELTA = HT_DELTA / AGE_DELTA
    ) |>
    select(
      CN, PREV_TRE_CN, PLT_CN, PREV_PLT_CN,
      STATECD, COUNTYCD, PLOT, SUBP, TREE, SPCD,
      MEASYEAR, PREV_MEASYEAR, CCLCD, DIA, PREV_DIA, HT, PREV_HT,
      AGE_DELTA, DIA_DELTA, ANN_DIA_DELTA, HT_DELTA, ANN_HT_DELTA
    ) |>
    arrange(STATECD, COUNTYCD, PLOT, SUBP, TREE, MEASYEAR) |>
    collect()
  
  dbDisconnect(fia)

  tree_growth <- tree_growth |>
    left_join(species_mixin, by = join_by(SPCD))

  rm(fia, measyear_mixin, prev_tre_mixin)

  write_rds(tree_growth, rds_file)
}
```

Measurement is imperfect, leading to some outliers in the growth table. We
can look at different outlier removal strategies and the resulting distribution
of observations:

```{r plot_tree_growth}
tree_growth |>
  select(CN, SPGRPCD, JENKINS_SPGRP_NAME, ANN_DIA_DELTA) |>
  filter(!is.na(ANN_DIA_DELTA)) |>
  group_by(SPGRPCD) |>
  arrange(ANN_DIA_DELTA) |>
  mutate(
    ONE_OUTLIER = (row_number() < (n() * 0.01)) | (row_number() > (n() - n() * 0.01)),
    TWO_OUTLIER = (row_number() < (n() * 0.025)) | (row_number() > (n() - n() * 0.025))
  ) |>
  ungroup() |>
  group_by(JENKINS_SPGRP_NAME) |>
  mutate(
    GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())
  ) |>
  ungroup() |>
  mutate(
    `1%` = if_else(!ONE_OUTLIER, ANN_DIA_DELTA, NA),
    `2.5%` = if_else(!TWO_OUTLIER, ANN_DIA_DELTA, NA),
    `0%` = ANN_DIA_DELTA
  ) |>
  select(CN, GROUP_NAME, `1%`, `2.5%`, `0%`) |>
  melt(
    id.vars = c("CN", "GROUP_NAME"),
    variable.name = "Outliers Removed",
    value.name = "Growth Rate"
  ) |>
  filter(!is.na(`Growth Rate`)) |>
  mutate(`Outliers Removed` = factor(`Outliers Removed`, levels = c("0%", "1%", "2.5%"))) |>
  ggplot(
      aes(`Growth Rate`, fct_rev(fct_infreq(GROUP_NAME)), fill = `Outliers Removed`)
    ) +
    geom_boxplot() +
    scale_fill_discrete(breaks = c("2.5%", "1%", "0%")) +
    ggtitle("Measured Annual Growth with Outliers Removed by Species") +
    xlab(bquote("Annual Growth " ~(inches %*% year^{-1}))) +
    ylab("Species Group")

```



##### Estimated Growth Rate

From the observed growth with outliers removed, we can compute per-species,
per-plot, per-inventory growth rates. We can then apply these growth rates
to ingrown trees to back-project them to their starting diameter.

For each plot/species/inventory, we compute the growth rate of that species
on that plot in that inventory, based on the trees of that species on that plot
during that inventory. Some variations filter out growth outliers.

For growth rate, we prioritize:

1. The mean growth rate of at least 3 dominant trees of the species during the inventory;
2. The mean growth rate of at least 3 trees of any dominance of the species during the inventory;
3. The mean growth rate of at least 3 trees of any dominance of the species group during the inventory;
4. The mean growth rate of at least 3 trees of any dominance of the species group on the plot during any inventory.

tree_growth_rate - all computable growth rates for all plot/species/inventory

```{r tree_growth_rate}
tree_growth_with_outliers <- tree_growth |>
  filter(!is.na(ANN_DIA_DELTA)) |>
  group_by(SPCD) |>
  arrange(ANN_DIA_DELTA) |>
  mutate(
    OUTLIER_ONE = (row_number() > (n() * 0.01)) & (row_number() < (n() - n() * 0.01)),
    DIA_DELTA_ONE = if_else(OUTLIER_ONE, DIA_DELTA, NA),
    OUTLIER_TWO = (row_number() > (n() * 0.025)) & (row_number() < (n() - n() * 0.025)),
    DIA_DELTA_TWO = if_else(OUTLIER_TWO, DIA_DELTA, NA)
  ) |>
  ungroup()

tree_growth_dom <- tree_growth_with_outliers |>
  filter(CCLCD <= 3) |>
  group_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD) |>
  summarize(
    DIA_DELTA = mean(DIA_DELTA, na.rm = TRUE),
    COUNT = n(),
    COUNT_ONE = sum(OUTLIER_ONE, na.rm = TRUE),
    COUNT_TWO = sum(OUTLIER_TWO, na.rm = TRUE),
    DIA_DELTA_DOM = mean(DIA_DELTA, na.rm = TRUE),
    DIA_DELTA_DOM_ONE = mean(DIA_DELTA_ONE, na.rm = TRUE),
    DIA_DELTA_DOM_TWO = mean(DIA_DELTA_TWO, na.rm = TRUE),
    .groups = 'keep'
  ) |>
  ungroup() |>
  mutate(
    DIA_DELTA_DOM = if_else(COUNT >= 3, DIA_DELTA_DOM, NA),
    DIA_DELTA_DOM_ONE = if_else(COUNT_ONE >= 3, DIA_DELTA_DOM_ONE, NA),
    DIA_DELTA_DOM_TWO = if_else(COUNT_TWO >= 3, DIA_DELTA_DOM_TWO, NA)
  ) |>
  select(
    STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
    DIA_DELTA_DOM, DIA_DELTA_DOM_ONE, DIA_DELTA_DOM_TWO
    )

tree_growth_spcd <- tree_growth_with_outliers |>
  group_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD) |>
  summarize(
    DIA_DELTA = mean(DIA_DELTA, na.rm = TRUE),
    COUNT = n(),
    COUNT_ONE = sum(OUTLIER_ONE, na.rm = TRUE),
    COUNT_TWO = sum(OUTLIER_TWO, na.rm = TRUE),
    DIA_DELTA_SPCD = mean(DIA_DELTA, na.rm = TRUE),
    DIA_DELTA_SPCD_ONE = mean(DIA_DELTA_ONE, na.rm = TRUE),
    DIA_DELTA_SPCD_TWO = mean(DIA_DELTA_TWO, na.rm = TRUE),
    .groups = 'keep'
  ) |>
  ungroup() |>
  mutate(
    DIA_DELTA_SPCD = if_else(COUNT >= 3, DIA_DELTA_SPCD, NA),
    DIA_DELTA_SPCD_ONE = if_else(COUNT_ONE >= 3, DIA_DELTA_SPCD_ONE, NA),
    DIA_DELTA_SPCD_TWO = if_else(COUNT_TWO >= 3, DIA_DELTA_SPCD_TWO, NA)
  ) |>
  select(
    STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
    DIA_DELTA_SPCD, DIA_DELTA_SPCD_ONE, DIA_DELTA_SPCD_TWO
  )

tree_growth_spgrpcd <- tree_growth_with_outliers |>
  group_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPGRPCD) |>
  summarize(
    DIA_DELTA = mean(DIA_DELTA, na.rm = TRUE),
    COUNT = n(),
    COUNT_ONE = sum(OUTLIER_ONE, na.rm = TRUE),
    COUNT_TWO = sum(OUTLIER_TWO, na.rm = TRUE),
    DIA_DELTA_SPGRPCD = mean(DIA_DELTA, na.rm = TRUE),
    DIA_DELTA_SPGRPCD_ONE = mean(DIA_DELTA_ONE, na.rm = TRUE),
    DIA_DELTA_SPGRPCD_TWO = mean(DIA_DELTA_TWO, na.rm = TRUE),
    .groups = 'keep'
  ) |>
  ungroup() |>
  mutate(
    DIA_DELTA_SPGRPCD = if_else(COUNT >= 3, DIA_DELTA_SPGRPCD, NA),
    DIA_DELTA_SPGRPCD_ONE = if_else(COUNT_ONE >= 3, DIA_DELTA_SPGRPCD_ONE, NA),
    DIA_DELTA_SPGRPCD_TWO = if_else(COUNT_TWO >= 3, DIA_DELTA_SPGRPCD_TWO, NA)
  ) |>
  select(
    STATECD, COUNTYCD, PLOT, MEASYEAR, SPGRPCD,
    DIA_DELTA_SPGRPCD, DIA_DELTA_SPGRPCD_ONE, DIA_DELTA_SPGRPCD_TWO
  )

tree_growth_multiyear <- tree_growth_with_outliers |>
  mutate(
    ANN_DIA_DELTA = DIA_DELTA / (MEASYEAR - PREV_MEASYEAR),
    ANN_DIA_DELTA_ONE = DIA_DELTA_ONE / (MEASYEAR - PREV_MEASYEAR),
    ANN_DIA_DELTA_TWO = DIA_DELTA_TWO / (MEASYEAR - PREV_MEASYEAR)
  ) |>
  group_by(STATECD, COUNTYCD, PLOT, SPGRPCD) |>
  summarize(
    COUNT = n(),
    COUNT_ONE = sum(OUTLIER_ONE, na.rm = TRUE),
    COUNT_TWO = sum(OUTLIER_TWO, na.rm = TRUE),
    ANN_DIA_DELTA_MULTIYEAR = mean(ANN_DIA_DELTA, na.rm = TRUE),
    ANN_DIA_DELTA_MULTIYEAR_ONE = mean(ANN_DIA_DELTA_ONE, na.rm = TRUE),
    ANN_DIA_DELTA_MULTIYEAR_TWO = mean(ANN_DIA_DELTA_TWO, na.rm = TRUE),
    .groups = 'keep'
  ) |>
  ungroup() |>
  mutate(
    ANN_DIA_DELTA_MULTIYEAR = if_else(COUNT >= 3, ANN_DIA_DELTA_MULTIYEAR, NA),
    ANN_DIA_DELTA_MULTIYEAR_ONE = if_else(COUNT_ONE >= 3, ANN_DIA_DELTA_MULTIYEAR_ONE, NA),
    ANN_DIA_DELTA_MULTIYEAR_TWO = if_else(COUNT_TWO >= 3, ANN_DIA_DELTA_MULTIYEAR_TWO, NA)
  ) |>
  select(
    STATECD, COUNTYCD, PLOT, SPGRPCD,
    ANN_DIA_DELTA_MULTIYEAR, ANN_DIA_DELTA_MULTIYEAR_ONE, ANN_DIA_DELTA_MULTIYEAR_TWO
  )

tree_growth_rate <- tree_growth_with_outliers |>
  distinct(STATECD, COUNTYCD, PLOT, MEASYEAR, PREV_MEASYEAR, SPCD) |>
  left_join(species_mixin, by = join_by(SPCD)) |>
  left_join(tree_growth_dom, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)) |>
  left_join(tree_growth_spcd, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)) |>
  left_join(tree_growth_spgrpcd, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPGRPCD)) |>
  left_join(tree_growth_multiyear, by = join_by(STATECD, COUNTYCD, PLOT, SPGRPCD)) |>
  mutate(
    DIA_DELTA = coalesce(
      DIA_DELTA_DOM,
      DIA_DELTA_SPCD,
      DIA_DELTA_SPGRPCD
    ),
    ANN_DIA_DELTA = coalesce(
      DIA_DELTA / (MEASYEAR - PREV_MEASYEAR),
      ANN_DIA_DELTA_MULTIYEAR
    ),
    DIA_DELTA_ONE = coalesce(
      DIA_DELTA_DOM_ONE,
      DIA_DELTA_SPCD_ONE,
      DIA_DELTA_SPGRPCD_ONE
    ),
    ANN_DIA_DELTA_ONE = coalesce(
      DIA_DELTA_ONE / (MEASYEAR - PREV_MEASYEAR),
      ANN_DIA_DELTA_MULTIYEAR_ONE
    ),
    DIA_DELTA_TWO = coalesce(
      DIA_DELTA_DOM_TWO,
      DIA_DELTA_SPCD_TWO,
      DIA_DELTA_SPGRPCD_TWO
    ),
    ANN_DIA_DELTA_TWO = coalesce(
      DIA_DELTA_TWO / (MEASYEAR - PREV_MEASYEAR),
      ANN_DIA_DELTA_MULTIYEAR_TWO
    )
  )
```

```{r tree_growth_rate_boxplot}
tree_growth_rate |>
  group_by(JENKINS_SPGRP_NAME) |>
  mutate(
    GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())
  ) |>
  ungroup() |>
  select(GROUP_NAME, ANN_DIA_DELTA, ANN_DIA_DELTA_ONE, ANN_DIA_DELTA_TWO) |>
  rename(`0%` = ANN_DIA_DELTA, `1%` = ANN_DIA_DELTA_ONE, `2.5%` = ANN_DIA_DELTA_TWO) |>
  melt(id.vars = c("GROUP_NAME"), value.name = "ANN_DIA_DELTA", variable.name = "Outliers Removed") |>
  filter(!is.na(ANN_DIA_DELTA)) |>
  ggplot(
      aes(ANN_DIA_DELTA, fct_rev(fct_infreq(GROUP_NAME)), fill = `Outliers Removed`)
    ) +
    geom_boxplot() +
    geom_vline(xintercept = 0, linetype = "dashed") +
    scale_fill_discrete(breaks = c("2.5%", "1%", "0%")) +
    coord_cartesian(xlim = c(-1, 1)) +
    theme_bw() +
    ggtitle("Measured Annual Diameter Growth of Ingrown Trees") +
    xlab(bquote("Annual Diameter Growth " ~(inches %*% year^{-1}))) +
    ylab("Species Group")

```

```{r tree_growth_rate_boxplot_metric}
tree_growth_rate |>
  group_by(JENKINS_SPGRP_NAME) |>
  mutate(
    GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())
  ) |>
  ungroup() |>
  select(GROUP_NAME, ANN_DIA_DELTA, ANN_DIA_DELTA_ONE, ANN_DIA_DELTA_TWO) |>
  rename(`0%` = ANN_DIA_DELTA, `1%` = ANN_DIA_DELTA_ONE, `2.5%` = ANN_DIA_DELTA_TWO) |>
  melt(id.vars = c("GROUP_NAME"), value.name = "ANN_DIA_DELTA", variable.name = "Outliers Removed") |>
  filter(!is.na(ANN_DIA_DELTA)) |>
  mutate(ANN_DIA_DELTA = conv_unit(ANN_DIA_DELTA, "inch", "meter") * pi * 2) |>
  ggplot(
      aes(ANN_DIA_DELTA, fct_rev(fct_infreq(GROUP_NAME)), fill = `Outliers Removed`)
    ) +
    geom_boxplot() +
    geom_vline(xintercept = 0, linetype = "dashed") +
    scale_fill_discrete(breaks = c("2.5%", "1%", "0%")) +
    coord_cartesian(xlim = c(-0.2, 0.2)) +
    theme_bw() +
    ggtitle("Measured Annual Basal Area Growth of Ingrown Trees") +
    xlab(bquote("Annual Basal Area Growth " ~(m^2 %*% year^{-1}))) +
    ylab("Species Group")

```

##### One-Shot Back-Projection

Can we use that to back-project ingrown trees?

```{r manual_back_projection}
location_mixin <- tree_ingrown |>
  select(CN, STATECD, COUNTYCD, PLOT, SPCD)

manual_back_projection <- tree_ingrown_last |>
  filter(FRST_DIA < DIA) |> # Trees that grow
  left_join(location_mixin, by = join_by(CN)) |>
  # Add on growth rate
  left_join(tree_growth_rate, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)) |>
  mutate(
    DIA_EST = DIA - (MEASYEAR - FRST_MEASYEAR) * ANN_DIA_DELTA_MULTIYEAR,
    DIA_ERR = (DIA_EST - FRST_DIA) / FRST_DIA,
    DIA_EST_ONE = DIA - (MEASYEAR - FRST_MEASYEAR) * ANN_DIA_DELTA_MULTIYEAR_ONE,
    DIA_ERR_ONE = (DIA_EST_ONE - FRST_DIA) / FRST_DIA,
    DIA_EST_TWO = DIA - (MEASYEAR - FRST_MEASYEAR) * ANN_DIA_DELTA_MULTIYEAR_TWO,
    DIA_ERR_TWO = (DIA_EST_TWO - FRST_DIA) / FRST_DIA
  ) |>
  arrange(DIA_ERR)

manual_back_projection |>
  group_by() |>
  summarize(
    COUNT = n(),
    MISSING = sum(is.na(DIA_EST), na.rm = TRUE) / COUNT,
    MISSING_ONE = sum(is.na(DIA_EST_ONE), na.rm = TRUE) / COUNT,
    MISSING_TWO = sum(is.na(DIA_EST_TWO), na.rm = TRUE) / COUNT,
    HIT = sum(abs(DIA_ERR) < 0.1, na.rm = TRUE) / COUNT,
    HIT_ONE = sum(abs(DIA_ERR_ONE) < 0.1, na.rm = TRUE) / COUNT,
    HIT_TWO = sum(abs(DIA_ERR_TWO) < 0.1, na.rm = TRUE) / COUNT,
    .groups = 'keep'
  ) |>
  ungroup() |>
  pivot_longer(everything()) |>
  knitr::kable()
```

Still less than half the trees back-project to within 10% of their first
measured diameter.

##### Stepwise Back-Projection

Rather than try to project back to starting diameter in one step, we can
project the diameter back to the estimated diameter at the previous measurement,
and repeat back in time until we get to the starting diameter. This will
better use per-inventory diameters.

tree_ingrown has one tree record for each year an ingrown tree was inventoried.
We can fill in a DIA_EST using the growth interval, and iterate until
they're all filled in.

```{r init_stepwise_manual_back_projection}
manual_back_projection <- tree_ingrown |>
  # Start with actually ingrown trees
  semi_join(grm_ingrown, by = join_by(CN == TRE_CN)) |>
  select(CN, STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD, PREV_TRE_CN, DIA) |>
  left_join(
    tree_growth_rate |>
      select(
        STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
        DIA_DELTA, DIA_DELTA_ONE, DIA_DELTA_TWO
      ),
    by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)
  ) |>
  # We can get a perfect estimate if we know the actual value :-D
  mutate(
    DIA_EST = DIA,
    DIA_EST_ONE = DIA,
    DIA_EST_TWO = DIA
  ) |>
  mutate(
    PREV_DIA_EST = DIA - DIA_DELTA,
    PREV_DIA_EST_ONE = DIA - DIA_DELTA_ONE,
    PREV_DIA_EST_TWO = DIA - DIA_DELTA_TWO
  ) |>
  mutate(
    DIA_ERR = abs((DIA - DIA_EST) / DIA),
    DIA_ERR_ONE = abs((DIA - DIA_EST_ONE) / DIA),
    DIA_ERR_TWO = abs((DIA - DIA_EST_TWO) / DIA),
  )

# Back-projectable trees:
manual_back_projection |> nrow()
```

```{r stepwise_manual_back_projection}
prev_tre_cns <- manual_back_projection |>
  select(PREV_TRE_CN) |>
  filter(!is.na(PREV_TRE_CN))

iterations <- 0
while (nrow(prev_tre_cns) > 0) {
  print(paste0(
    "Iteration: ",
    iterations <- iterations + 1,
    ", CNs: ",
    nrow(prev_tre_cns)
  ))
  tmp_trees <- tree_ingrown |>
    semi_join(prev_tre_cns, by = join_by(CN == PREV_TRE_CN)) |>
    select(CN, STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD, PREV_TRE_CN, DIA) |>
        # Join on growth rates
    left_join(
      tree_growth_rate |>
        select(
          STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
          DIA_DELTA, DIA_DELTA_ONE, DIA_DELTA_TWO
        ),
      by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)
    ) |>
    # Join on previously estimated diameter
    left_join(
      manual_back_projection |>
        select(PREV_TRE_CN, PREV_DIA_EST, PREV_DIA_EST_ONE, PREV_DIA_EST_TWO) |>
        rename(
          CN = PREV_TRE_CN,
          DIA_EST = PREV_DIA_EST,
          DIA_EST_ONE = PREV_DIA_EST_ONE,
          DIA_EST_TWO = PREV_DIA_EST_TWO
        ),
      by = join_by(CN)
    ) |>
    mutate(
      DIA_ERR = abs(DIA - DIA_EST) / DIA,
      DIA_ERR_ONE = abs(DIA - DIA_EST_ONE) / DIA,
      DIA_ERR_TWO = abs(DIA - DIA_EST_TWO) / DIA
    ) |>
    # Estimate the next previous tree diameter
    mutate(
      PREV_DIA_EST = DIA_EST - DIA_DELTA,
      PREV_DIA_EST_ONE = DIA_EST_ONE - DIA_DELTA_ONE,
      PREV_DIA_EST_TWO = DIA_EST_TWO - DIA_DELTA_TWO
    )
  # Apparently, some trees can be tracked back before the end of time
  # or something, so we can end up with some PREV_TRE_CNs that are
  # dangling refrences.
  if (nrow(tmp_trees) == 0) {
    break
  }
  manual_back_projection <- bind_rows(manual_back_projection, tmp_trees)
  num_duplicate_cns <- manual_back_projection |>
    group_by(CN) |>
    filter(n() > 1) |>
    ungroup() |> nrow()
  stopifnot(num_duplicate_cns == 0)
  # The next set of prev_tre_cns is:
  prev_tre_cns <- manual_back_projection |>
    # All PREV_TRE_CN mentioned
    select(PREV_TRE_CN) |>
    filter(!is.na(PREV_TRE_CN)) |>
    distinct() |>
    # that have not already been processed
    anti_join(
      manual_back_projection |>
        select(CN) |>
        filter(!is.na(CN)) |>
        distinct(),
      by = join_by(PREV_TRE_CN == CN)
    )
}
manual_back_projection |>
  group_by() |>
  summarize(
    COUNT = n(),
    MISSING = sum(is.na(DIA_EST), na.rm = TRUE) / COUNT,
    MISSING_ONE = sum(is.na(DIA_EST_ONE), na.rm = TRUE) / COUNT,
    MISSING_TWO = sum(is.na(DIA_EST_TWO), na.rm = TRUE) / COUNT,
    HIT = sum(abs(DIA_ERR) < 0.1, na.rm = TRUE) / COUNT,
    HIT_ONE = sum(abs(DIA_ERR_ONE) < 0.1, na.rm = TRUE) / COUNT,
    HIT_TWO = sum(abs(DIA_ERR_TWO) < 0.1, na.rm = TRUE) / COUNT,
    .groups = 'keep'
  ) |>
  ungroup() |>
  pivot_longer(everything()) |>
  knitr::kable()

```

Apply Back-Projection

```{r projected_vs_measured_annual_growth}
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')

projected_annual_growth <- tree_ingrown_last |>
  filter(MEASYEAR != FRST_MEASYEAR) |>
  left_join(
    manual_back_projection |>
      select(CN, SPCD, DIA_EST, DIA_EST_ONE, DIA_EST_TWO),
    by = join_by(FRST_TRE_CN == CN)
  ) |>

  # Be metric
  mutate(
    DIA = conv_unit(DIA, "in", "cm"),
    FRST_DIA = conv_unit(FRST_DIA, "in", "cm"),
    DIA_EST = conv_unit(DIA_EST, "in", "cm"),
    DIA_EST_ONE = conv_unit(DIA_EST_ONE, "in", "cm"),
    DIA_EST_TWO = conv_unit(DIA_EST_TWO, "in", "cm"),
  ) |>

  mutate(
    ANN_DIA = (DIA - FRST_DIA) / (MEASYEAR - FRST_MEASYEAR),
    DIA_ERR = (FRST_DIA - DIA_EST),
    ANN_DIA_EST = (DIA - DIA_EST) / (MEASYEAR - FRST_MEASYEAR),
    ANN_DIA_ERR = DIA_ERR / (MEASYEAR - FRST_MEASYEAR),
    DIA_ERR_ONE = (FRST_DIA - DIA_EST_ONE),
    ANN_DIA_EST_ONE = (DIA - DIA_EST_ONE) / (MEASYEAR - FRST_MEASYEAR),
    ANN_DIA_ERR_ONE = DIA_ERR_ONE / (MEASYEAR - FRST_MEASYEAR),
    DIA_ERR_TWO = (FRST_DIA - DIA_EST_TWO),
    ANN_DIA_EST_TWO = (DIA - DIA_EST_TWO) / (MEASYEAR - FRST_MEASYEAR),
    ANN_DIA_ERR_TWO = DIA_ERR_TWO / (MEASYEAR - FRST_MEASYEAR),
  ) |>
  filter(!is.na(DIA_ERR)) |>
  left_join(species_mixin, by = join_by(SPCD)) |>
  group_by(JENKINS_SPGRP_NAME) |>
  mutate(GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())) |>
  ungroup() |>
  select(CN, GROUP_NAME, ANN_DIA, ANN_DIA_EST, ANN_DIA_EST_ONE, ANN_DIA_EST_TWO) |>
  rename(
    `Measured` = ANN_DIA,
    `Estimated` = ANN_DIA_EST,
    `Est - 1%` = ANN_DIA_EST_ONE,
    `Est - 2.5%` = ANN_DIA_EST_TWO
  ) |>
  melt(
    id.vars = c("CN", "GROUP_NAME"),
    variable.name = "Series",
    value.name = "Growth"
  ) |>
  filter(!is.na(Growth)) |>
  mutate(Growth = conv_unit(Growth, "in", "m") * pi * 2)
ggplot(
  projected_annual_growth,
  aes(Growth, fct_rev(fct_infreq(GROUP_NAME)), fill = `Series`)
) +
  geom_boxplot(outlier.size = 0.1) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_fill_discrete(breaks = rev(levels(projected_annual_growth$Series))) +
  #coord_cartesian(xlim = c(-0.2, 0.2)) +
  theme_bw() +
  ggtitle("Projected Annual Growth of Ingrown Trees") +
  xlab(bquote("Change in Basal Area " ~(m^2 %*% year^{-1}))) +
  ylab("Species Group")
```

This looks usable.

##### Back-Project to <= 3" DBH

Using estimated diameter, what portion of ingrown trees
can we project back to 3" DBH before the first MEASYEAR?

```{r init_tree_ingrown_three}
tree_ingrown_three <- tree_ingrown |>
  # Start with actually ingrown trees
  semi_join(grm_ingrown, by = join_by(CN == TRE_CN)) |>
  select(CN, STATECD, COUNTYCD, PLOT, TREE, MEASYEAR, SPCD, DIA) |>
  left_join(
    tree_growth_rate |>
      select(
        STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
        PREV_MEASYEAR,
        DIA_DELTA, DIA_DELTA_ONE, DIA_DELTA_TWO
      ),
    by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)
  ) |>
  # Fill in estimated diameters
  mutate(
    FRST_MEASYEAR = if_else(DIA > 3, PREV_MEASYEAR, MEASYEAR),
    FRST_DIA_EST = if_else(DIA > 3, DIA - DIA_DELTA, DIA),
    FRST_DIA_EST_ONE = if_else(DIA > 3, DIA - DIA_DELTA_ONE, DIA),
    FRST_DIA_EST_TWO = if_else(DIA > 3, DIA - DIA_DELTA_TWO, DIA)
  ) |>
  mutate(
    PREV_MEASYEAR = if_else(FRST_DIA_EST > 3, PREV_MEASYEAR, NA)
  )
```

```{r tree_ingrown_three}
# Graft on the growth for the previous inventory
# project back that growth
# calculate the estimated diameter
# anything that's at 3", or that doesn't have a prev_measyear, gets filtered out
# (set to NULL?)
# move prev_measyear back a notch
# repeat
prev_measyears <- tree_ingrown_three |>
  filter(!is.na(PREV_MEASYEAR)) |>
  select(CN, PREV_MEASYEAR)

# Less efficient, but amusing and probably worth it:
# run prev_measyear back by max(prev_measyears), so
# we can print the year we're projecting. Then
# do the join on tree_ingrown_three and tree_growth_rate
# with appropriate measyears.
iterations <- 0
while (nrow(prev_measyears) > 0) {
  print(paste0(
    "Iteration: ",
    iterations <- iterations + 1,
    ", Trees: ",
    nrow(prev_measyears),
    ", Years: ",
    min(prev_measyears$PREV_MEASYEAR),
    " - ",
    max(prev_measyears$PREV_MEASYEAR)
  ))

  tree_ingrown_three <- tree_ingrown_three |>
    select(!starts_with("DIA_DELTA")) |>
    left_join(
      tree_growth_rate |>
        select(
          STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
          PREV_MEASYEAR,
          DIA_DELTA, DIA_DELTA_ONE, DIA_DELTA_TWO
        ),
      by = join_by(STATECD, COUNTYCD, PLOT, PREV_MEASYEAR == MEASYEAR, SPCD)
    ) |>
    select(!"PREV_MEASYEAR") |>
    rename(PREV_MEASYEAR = PREV_MEASYEAR.y) |>
    # Update estimated diameters, but only if growth joined on
    mutate(
      FRST_MEASYEAR = if_else(!is.na(DIA_DELTA), PREV_MEASYEAR, FRST_MEASYEAR),
      FRST_DIA_EST =
        if_else(!is.na(DIA_DELTA), FRST_DIA_EST - DIA_DELTA, FRST_DIA_EST),
      FRST_DIA_EST_ONE =
        if_else(!is.na(DIA_DELTA), FRST_DIA_EST_ONE - DIA_DELTA_ONE, FRST_DIA_EST_ONE),
      FRST_DIA_EST_TWO =
        if_else(!is.na(DIA_DELTA), FRST_DIA_EST_TWO - DIA_DELTA_TWO, FRST_DIA_EST_TWO)
    ) |>
    mutate(
      PREV_MEASYEAR = if_else(!is.na(DIA_DELTA) & FRST_DIA_EST > 3, PREV_MEASYEAR, NA)
    )

  # This generally completes in 4 iterations; if we hit 10 something's wrong.
  if (iterations > 10) {
    print("Too many iterations")
    break
  }

  prev_measyears <- tree_ingrown_three |>
    filter(!is.na(PREV_MEASYEAR)) |>
    select(CN, PREV_MEASYEAR)
}

tree_ingrown_three |>
  group_by() |>
  summarize(
    COUNT = n(),
    MISSING = sum(is.na(FRST_DIA_EST), na.rm = TRUE) / COUNT,
    MISSING_ONE = sum(is.na(FRST_DIA_EST_ONE), na.rm = TRUE) / COUNT,
    MISSING_TWO = sum(is.na(FRST_DIA_EST_TWO), na.rm = TRUE) / COUNT,
    HIT = sum(FRST_DIA_EST <= 3, na.rm = TRUE) / COUNT,
    HIT_ONE = sum(FRST_DIA_EST_ONE <= 3, na.rm = TRUE) / COUNT,
    HIT_TWO = sum(FRST_DIA_EST_TWO <= 3, na.rm = TRUE) / COUNT,
    .groups = 'keep'
  ) |>
  ungroup() |>
  pivot_longer(everything()) |>
  knitr::kable()
```

## Run FVS

### Generate Keyfile

An FVS run is scripted by a keyfile. The keyfile describes how to run the
model and extensions, including where to read input, all parameters to
control processing, and where to write output.

The keyfile is structured by stand; each stand is a separate run of the
model.

To run in parallel, a separate keyfile must be generated for each partition
to be run in parallel. Each partition must send its output to a separate
location, and these can be assembled into a single output as a post-
processing step.

#### Stand Identification

For each stand, we need:

-  StdIdent: Stand Identifier, from fia.FVS_STANDINIT_PLOT.FVS_STAND_ID
-  StandCN: Stand control number, from fia.PLOT.CN
-  MgmtId: Management ID, for no treatment, this is NONE

#### Time

We will run the model from first measurement year to last measurement year,
with as many 10-year timesteps as we can get. We will add an initial timestep
that is less than 10 years to get to a 10 year boundary. We choose a 10-year
timestep because FVSne is calibrated to 10 years, and running with a different
length timestep introduces bias. The bias is less with shorter timesteps than
with longer timesteps, so using a short timestep to adjust length introduces
less bias than using a long timestep.

There are two years of interest for each plot: FIRSTYEAR, which is
the minimum fia.PLOT.MEASYEAR for the modern plot design; and
LASTYEAR, which is the maximum of the same.

-  InvYear: Inventory Year, set to FIRSTYEAR
-  TimeInt: Time Interval, there may be two entries:
   -  TimeInt 0: Default time interval, 10 years
   -  TimeInt 1: First cycle time interval, (LASTYEAR - FIRSTYEAR) %% 10
-  NumCycle: Number of cycles to run, int((LASTYEAR - FIRSTYEAR) / 10) + 1,
   and +1 again if there is a TimeInt 1.

Note that the number of cycles is the number of full 10-year cycles
plus one if there is a short first cycle. Since metrics are printed at the start
of each cycle, we need LASTYEAR to be the first year of a cycle, and work
backwards from that.

#### Input

There are two inputs, Stand and Tree. Both are configured to use a database
query.

Within a Database subsection:

-  DSNIn: Data Source Name (DSN) for input; SQLite filename
-  StandSQL: SQL query to fetch a stand, given %Stand_CN%
-  TreeSQL: SQL query to fetch all trees for a stand, given %Stand_CN%

#### Regeneration, Ingrowth, and Establishment

The Northeastern variant is a partial establishment model, so it does not
automatically perform natural regeneration. We will therefore use actual
ingrowth from the FIA data.

#### Fire and Fuels

Carbon is calculated by the fire and fuels extension.

-  FMIn: Starts configuration of Fire and Fuels extension
-  CarbRept: Carbon Report; save to database (2)
-  CarbCut: Harvested Carbon Report; disable (0)
-  CarbCalc: Carbon calculation; metric (1)
-  FuelOut: Fuel Output, disable (0)
-  FuelRept: Fuel Report, disable (0)

Fire and Fuels also interacts with the database extension; it provides additional
Database keywords to configure Fire and Fuels output to the database.

Within a Database section:

-  CarbReDB: FVS_Carbon and FVS_Hrv_Carbon tables: database (2)
-  FuelReDB: FVS_Consumption table: database (2)
-  FuelsOut: FVS_Fuels table: database (2)


##### Translating to FVS

For each timestep, we will find the trees that establish during that timestep,
and add a record describing the tree at the time of establishment.

Note that FIA establishes at 5" DBH, whereas FVS establishes at 3" DBH,
and FVS puts an upper bound on height based on expectations for 3" DBH trees.
We can follow PREV_TRE_CN backward to find when the tree was 3" DBH; note
that this might be a long time ago. As an alternative, we could multiply TPA
by DIA^2 / 3^2 and set the height to (3/DIA)*HT - this would give us the same
total basal area in trees of reduced height.

Because of the way time is set up in FVS, establishment is scheduled for the
year prior to the start of a cycle. Within the cycle, each tree that is
established gets its own Natural keyword. This specifies:

-  Year: The (actual) year in which the tree is marked as INGROWTH
-  Species: The 2-character FVS species code
-  TPA: Trees per acre; prefer the TPA from the tree record over TPAGROW_UNADJ
   from the establishment record (the two should be the same)
-  Survivorship: Always 100%
-  Age: average age at the year of establishment. Leave this blank.
-  Height: Average height.  Use fia.TREE.HT, but see above note.
-  Shade: 0 = uniform, 1 = prefer shade; 2 = prefer sun. Use 0.

FVS is semi-spatial; it is aware of subplots and microplots, and how many
trees are on each. There does not appear to be a way to designate which
subplot a tree establishes on; presumably, the TPA is distributed across
subplots.

#### Output

We use database output; it is easiest to work with. Many output options take
a parameter that is 0 to disable output, 1 for file output, 2 for database
output, and 3 for both file and database output.

Within a Database section:

-  DSNOut: Data Source Name (DSN) for output; SQLite filename
-  Summary: Configure FVS_Summary; use version 2
-  Computdb: Configure FVS_Compute; disable
-  MisRpts: Configure Mistletoe reports; disable

#### Processing Order

Each stand has its own section of the keyword file, including everything from
StdIdent to Process. Each stand is processed before moving to the next stand.

At the end of all stands, the Stop keyword tells FVS to exit cleanly.

#### Example

```
StdIdent
230202502686        NoManagement
StandCN
52967848010538
MgmtId
NONE
InvYear         2002
TimeInt            0        10
TimeInt            1         2
NumCycle           3

FMIn
CarbRept           2
CarbCut            2
CarbCalc           0         1    0.0425         9        11
FuelOut            2
FuelRept           2
End

Database

DSNIn
SQLite_FIADB_ENTIRE.db

StandSQL
SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL

TreeSQL
SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL

DSNOut
FVS_NoManagement_NONE.db

Summary            2
Computdb           0         1
MisRpts            2
CarbReDB           2
FuelReDB           2
FuelsOut           2

END

Process

Stop
```

#### Keword File Generation

Gather stand IDs and CNs for keywordfile generation.

We gather two series of stands:

-  stands_projected is a list of stands and inventory years to grow out to 2025
-  stands_surveyed is a list of stands and inventory years to grow for 0 years
   in each survey year.

When generating keyword files, we create one per partition,
distributing across partitions using round-robin on STAND_ID.

keywordfile_section is a function to generate a keywordfile section from
information about a run and a stand.

```{r keywordfile_section}
keywordfile_section <- function(
    Title, MgmtId, StandID, StandCN,
    FirstYear, LastYear, Timestep,
    Partition, RandSeed = NA
  ) {
  TimeConfig <- fvs_TimeConfig(FirstYear, LastYear, Timestep)
  if (!is.na(RandSeed)) {
    RandSeed <- fvs_kwd1("RANNSEED", RandSeed)
  } else {
    RandSeed <- c()
  }
  c(
    fvs_kwd0("StdIdent"),
    paste0(StandID, " ", Title),
    fvs_kwd0("StandCN"),
    StandCN,
    fvs_kwd0("MgmtId"),
    MgmtId,
    TimeConfig,
    RandSeed,
    fvs_kwd0("FMIn"), # Fire and Fuels Extension
    fvs_kwd0("CarbRept"),
    fvs_kwd0("CarbCut"),
    fvs_kwd5("CarbCalc", 1, 1, 0.0425, 9, 11),
    fvs_kwd0("FuelOut"),
    fvs_kwd0("FuelRept"),
    fvs_kwd0("End"), # FMIn
    fvs_kwd0("Database"), # Database extension
    fvs_kwd0("DSNIn"),
    "SQLite_FIADB_ENTIRE.db",
    fvs_kwd0("StandSQL"),
    "SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'",
    fvs_kwd0("EndSQL"), # StandSQL
    fvs_kwd0("TreeSQL"),
    "SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'",
    fvs_kwd0("EndSQL"), # TreeSQL
    fvs_kwd0("DSNOut"),
    paste0("FVS_", Title, "_", MgmtId, "_", Partition, ".db"),
    fvs_kwd1("Summary",  2),
    fvs_kwd2("Computdb", 0, 1),
    fvs_kwd1("MisRpts",  2),
    fvs_kwd1("CarbReDB", 2),
    fvs_kwd1("FuelReDB", 2),
    fvs_kwd1("FuelsOut", 2),
    fvs_kwd0("End"), # Database
    fvs_kwd0("Process"),
    recursive = TRUE
  )
}

```

Find the stands we want to project; these are the grow-only stands starting
in their first measurement year.

```{r stands_projected}
timeframe <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    INVYR = min(INVYR),
    FIRSTYEAR = min(MEASYEAR, na.rm = TRUE),
    LASTYEAR = max(MEASYEAR, na.rm = TRUE),
    .groups = "keep"
  ) |>
  ungroup()


fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
fia_fvs_standinit_plot <- tbl(fia, 'FVS_StandInit_Plot') |>
  select(STAND_CN, STAND_ID)

stands_projected <- tbl(fia, 'PLOT') |>
  select(CN, STATECD, COUNTYCD, PLOT, INVYR) |>
  rename(STAND_CN = CN) |>
  inner_join(timeframe, by = join_by(STATECD, COUNTYCD, PLOT, INVYR), copy = TRUE) |>
  left_join(fia_fvs_standinit_plot, by = join_by(STAND_CN)) |>
  collect()

dbDisconnect(fia)
remove(fia, fia_fvs_standinit_plot)
```

The first run is to project from the first measurement year to 2025. These
are given management ID "NONE".

```{r NRSGrowOnlyPrj-10year}
for (timestep in c(1, 10)) {
  for (rannseed in c(1,3,5)) {
    for (partition in 1:8) {
      title <- "NRSGrowOnly"
      mgmtid <- paste0(timestep, "Y", rannseed)
      filename <- paste0("data/fvs/FVS_", title, "_", mgmtid, "_", partition, ".key")
      unlink(filename)
      apply(
        stands_projected |> 
          filter((as.numeric(STAND_ID) %% 8) == (partition - 1)) |>
          arrange(STAND_ID, FIRSTYEAR),
        1,
        function(row) {
          write_lines(
            keywordfile_section(
              title,
              mgmtid,
              row['STAND_ID'],
              row['STAND_CN'],
              row['FIRSTYEAR'],
              row['LASTYEAR'],
              timestep,
              partition,
              rannseed # Random Seed
            ),
            filename,
            append = TRUE
          )
        }
      )
      write_lines("Stop", filename, append = TRUE)
    }
  }
}
```

The second run is a zero-year projection to have FVS calculate the carbon
in surveyed stands in each year they are surveyed.

```{r stands_surveyed}
fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
fia_fvs_standinit_plot <- tbl(fia, 'FVS_StandInit_Plot') |>
  select(STAND_CN, STAND_ID)

stands_surveyed <- tbl(fia, 'PLOT') |>
  select(CN, STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR, DESIGNCD) |>
  filter(DESIGNCD == 1) |>
  rename(STAND_CN = CN) |>
  semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
  left_join(fia_fvs_standinit_plot, by = join_by(STAND_CN)) |>
  collect()

dbDisconnect(fia)
remove(fia, fia_fvs_standinit_plot)
```

The second run is to do a 0-year projection for each measurement year. These
are given management ID "SRVY".

```{r NRSGrowOnlyObs-0year}
timestep <- 1
for (partition in 1:8) {
  title <- "NRSGrowOnly"
  mgmtid <- "0Y0"
  filename <- paste0("data/fvs/FVS_", title, "_", mgmtid, "_", partition, ".key")
  unlink(filename)
  apply(
    stands_surveyed |>
      filter((as.numeric(STAND_ID) %% 8) == (partition - 1)) |>
      arrange(STAND_ID, MEASYEAR),
    1,
    function(row) {
      write_lines(
        keywordfile_section(
          title,
          mgmtid,
          row['STAND_ID'],
          row['STAND_CN'],
          row['MEASYEAR'],
          row['MEASYEAR'],
          timestep,
          partition
        ),
        filename,
        append = TRUE
      )
    }
  )
  write_lines("Stop", filename, append = TRUE)
}
```

#### Run FVS.

```{r run_fvs}
# TODO nik: Run FVS directly from R.
# Batch file to run FVS in parallel:
# for %%p in (FVS_Northeastern_%1_*.key) do del %%~np.db
# for %%p in (FVS_Northeastern_%1_*.key) do start \FVS\FVSbin\FVSne.exe --keywordfile=%%p
```

## Results

### Load Results

Load the output from all FVS partitions into a single dataframe

```{r FVS_Carbon}
FVS_Carbon <- NULL
FVS_Summary2_East <- NULL

title <- "NRSGrowOnly"
for (timestep in c(0, 1, 10)) {
  for (rannseed in c(0, 1, 3, 5)) {
    for (partition in 1:8) {
      mgmtid <- paste0(timestep, "Y", rannseed)
      filename <- paste0("data/fvs/FVS_", title, "_", mgmtid, "_", partition, ".db")
      if (file.exists(filename)) {
        print(paste0("Reading ", filename))
        fvs_out_db <- DBI::dbConnect(RSQLite::SQLite(), filename)
        fvs_carbon_tbl = tbl(fvs_out_db, 'FVS_Carbon') |>
          mutate(
            Title = title,
            MgmtId = mgmtid,
            Timestep = timestep,
            RanNSeed = rannseed,
            Partition = partition
          ) |>
          collect()
        FVS_Carbon <- bind_rows(FVS_Carbon, fvs_carbon_tbl)

        fvs_summary2_east_tbl = tbl(fvs_out_db, 'FVS_Summary2_East') |>
          mutate(
            Title = title,
            MgmtId = mgmtid,
            Timestep = timestep,
            RanNSeed = rannseed,
            Partition = partition
          ) |>
          collect()
        FVS_Summary2_East <- bind_rows(FVS_Summary2_East, fvs_summary2_east_tbl)
  
        dbDisconnect(fvs_out_db)
      } else {
        print(paste0("Skipping ", filename))
      }
    }
  }
}

remove(fvs_out_db, fvs_carbon_tbl, fvs_summary2_east_tbl)
```
Consolidate outputs; average the multiple runs with different random seeds.

```{r FVS_Carbon_NONE}
FVS_Carbon_NONE <- FVS_Carbon |>
  filter(Timestep == 10) |>
#  filter(RanNSeed == 1)
  group_by(StandID, Year) |>
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    Total_Stand_Carbon = mean(Total_Stand_Carbon),
    .groups = 'keep'
  ) |>
  ungroup()

FVS_Carbon_ANNL <- FVS_Carbon |>
  filter(Timestep == 1) |>
#  filter(RanNSeed == 1)
  group_by(StandID, Year) |>
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    Total_Stand_Carbon = mean(Total_Stand_Carbon),
    .groups = 'keep'
  ) |>
  ungroup()

# There is no projection for the observed run, so no need to average
FVS_Carbon_SRVY <- FVS_Carbon |>  
  filter(Timestep == 0)
```

Sanity check: did we get the outputs we requested?

```{r sanity-check-expected-output}
matched_carbon_tmp <- stands_projected |>
  left_join(
    FVS_Carbon_NONE |>
      select(StandID, Year, Aboveground_Total_Live) |> 
      rename(
        STAND_ID = StandID,
        FIRSTYEAR = Year,
        Starting_Carbon = Aboveground_Total_Live
      ),
    by = join_by(STAND_ID, FIRSTYEAR)
  ) |>
  left_join(
    FVS_Carbon_NONE |>
      select(StandID, Year, Aboveground_Total_Live) |>
      rename(
        STAND_ID = StandID,
        LASTYEAR = Year,
        Ending_Carbon = Aboveground_Total_Live
        ),
    by = join_by(STAND_ID, LASTYEAR)
  ) |>
  mutate(partition = (as.numeric(STAND_ID) %% 8) + 1)
missing_start <- matched_carbon_tmp |>
  filter(is.na(Starting_Carbon)) |> 
  nrow()
print(missing_start)
missing_end <- matched_carbon_tmp |>
  filter(is.na(Ending_Carbon)) |> 
  nrow()
print(missing_end)
stopifnot(missing_start == 0)
stopifnot(missing_end == 0)
remove(
  matched_carbon_tmp,
  missing_start,
  missing_end
)
```

### Annual vs. Decadal Projections

```{r annual_vs_decadal}
decadal_carbon_tmp <- FVS_Carbon_NONE |>
  rename(Decadal_Carbon = Aboveground_Total_Live) |>
  mutate(STAND_ID = paste0(
     substring(StandID, 1, 2),
     substring(StandID, 5, 12)
  )) |>
  select(STAND_ID, Year, Decadal_Carbon)

annual_carbon_tmp <- FVS_Carbon_ANNL |>
  rename(Annual_Carbon = Aboveground_Total_Live) |>
  mutate(STAND_ID = paste0(
     substring(StandID, 1, 2),
     substring(StandID, 5, 12)
  )) |>
  select(STAND_ID, Year, Annual_Carbon)

annual_vs_decadal <- stand_stats |>
  filter(DESIGNCD == 1) |>
  mutate(STAND_ID = sprintf(paste0(
    '%02d',  '%03d',   '%05d'),
    STATECD, COUNTYCD, PLOT
  )) |>
  rename(Year = MEASYEAR) |>
  select(
    STAND_ID, Year,
    STDAGE, `Forest Type`, `Forest Type Group`, ECOSUBCD
  ) |>
  left_join(decadal_carbon_tmp, by = join_by(STAND_ID, Year)) |>
  left_join(annual_carbon_tmp, by = join_by(STAND_ID, Year)) |>
  # There's something funny going on with plots; i've yet to figure it out.
  filter(!is.na(Decadal_Carbon) & !is.na(Annual_Carbon)) |>
  consolidate_forest_type_groups_filter() |>
  group_by(STAND_ID) |>
  mutate(
    ECOCD = substr(ECOSUBCD, 1, nchar(ECOSUBCD) - 1),
    First_Year = min(Year, na.rm = TRUE),
    Last_Year = max(Year, na.rm = TRUE),
    Decadal_Starting_Carbon = max(if_else(Year == First_Year, Decadal_Carbon, 0), na.rm = TRUE),
    Decadal_Carbon_Delta = Decadal_Carbon - Decadal_Starting_Carbon,
    Decadal_Carbon_Flux = if_else(Year == First_Year, 0, Decadal_Carbon_Delta / (Year - First_Year)),
    Annual_Starting_Carbon = max(if_else(Year == First_Year, Annual_Carbon, 0), na.rm = TRUE),
    Annual_Carbon_Delta = Annual_Carbon - Annual_Starting_Carbon,
    Annual_Carbon_Flux = if_else(Year == First_Year, 0, Annual_Carbon_Delta / (Year - First_Year))
  ) |>
  ungroup() |>
  filter(First_Year != Last_Year) |>
  filter(Year == Last_Year | Year == First_Year) |>
  mutate(Projection_Years = Year - First_Year) |>
  mutate(Carbon_Residual = Decadal_Carbon - Annual_Carbon) |>
  mutate(Carbon_Error = 2 * abs(Carbon_Residual) / (Decadal_Carbon + Annual_Carbon)) |>
  mutate(Carbon_Delta_Residual = Decadal_Carbon_Delta - Annual_Carbon_Delta) |>
  mutate(Carbon_Flux_Residual = Decadal_Carbon_Flux - Annual_Carbon_Flux)

remove(
  decadal_carbon_tmp,
  annual_carbon_tmp
)
```

```{r plot_decadal_vs_annual}
ggplot(
    annual_vs_decadal |> filter(Projection_Years > 0) |> arrange(Projection_Years),
    aes(x = Decadal_Carbon_Flux, y = Annual_Carbon_Flux, color = Projection_Years)
  ) +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  geom_point(
    size = 2,
    alpha = 0.25,
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle(bquote("Annual Carbon Flux for 1- vs. 10-year Timestep")) +
  coord_cartesian(xlim = c(-1, 8), ylim = c(-1, 8)) +
  ylab(bquote("1-Year Timestep Annual Carbon Flux" ~ (MgC %*% ha^-1 %*% year^-1))) +
  xlab(bquote("10-Year Timestep Annual Carbon Flux" ~ (MgC %*% ha^-1 %*% year^-1)))
```

```{r carbon_flux_stats}
summary(annual_vs_decadal[,c("Annual_Carbon_Flux", "Decadal_Carbon_Flux")])
```

### Projected vs. Measured

Filter projections to corresponding observations.

projected_vs_measured has the projection and measurement for the quantities
of interest in the first and last year, and nothing in between.

```{r projected_vs_measured}
projected_carbon_tmp <- FVS_Carbon_NONE |>
  select(StandID, Year, Total_Stand_Carbon) |>
  rename(Projected_Carbon = Total_Stand_Carbon)

FVS_Summary2_East_NONE <- FVS_Summary2_East |>
  filter(Timestep == 10) |>
  group_by(StandID, Year) |>
  summarize(
    BA = mean(BA),
    .groups = 'keep'
  ) |>
  ungroup()

FVS_Summary2_East_SRVY <- FVS_Summary2_East |>  
  filter(Timestep == 0)

projected_ba_tmp <- FVS_Summary2_East_NONE |>
  select(StandID, Year, BA) |>
  mutate(Projected_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare"))

projected_tmp <- projected_carbon_tmp |>
  full_join(projected_ba_tmp, by = join_by(StandID, Year)) |>
  mutate(STAND_ID = paste0(
     substring(StandID, 1, 2),
     substring(StandID, 5, 12)
  )) |>
  select(STAND_ID, Year, Projected_Carbon, Projected_BA)

surveyed_carbon_tmp <- FVS_Carbon_SRVY |>
  select(StandID, Year, Total_Stand_Carbon) |>
  rename(Measured_Carbon = Total_Stand_Carbon)

surveyed_ba_tmp <- FVS_Summary2_East_SRVY |>
  select(StandID, Year, BA) |>
  mutate(Measured_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare"))

surveyed_tmp <- surveyed_carbon_tmp |>
  full_join(surveyed_ba_tmp, by = join_by(StandID, Year)) |>
  mutate(STAND_ID = paste0(
     substring(StandID, 1, 2),
     substring(StandID, 5, 12)
  )) |>
  select(STAND_ID, Year, Measured_Carbon, Measured_BA)

projected_vs_measured <- stand_stats |>
  mutate(STAND_ID = sprintf(paste0(
    '%02d',  '%03d',   '%05d'),
    STATECD, COUNTYCD, PLOT
  )) |>
  rename(Year = MEASYEAR) |>
  select(
    STAND_ID, Year,
    STDAGE, `Forest Type`, `Forest Type Group`, ECOSUBCD,
    QMD, QMD_METRIC
  ) |>
  left_join(projected_tmp, by = join_by(STAND_ID, Year)) |>
  left_join(surveyed_tmp, by = join_by(STAND_ID, Year)) |>
  consolidate_forest_type_groups_filter() |>
  group_by(STAND_ID) |>
  mutate(
    ECOCD = substr(ECOSUBCD, 1, nchar(ECOSUBCD) - 1),
    First_Year = min(Year, na.rm = TRUE),
    Last_Year = max(Year, na.rm = TRUE),
    Starting_Carbon = max(if_else(Year == First_Year, Measured_Carbon, 0), na.rm = TRUE),
    Projected_Carbon_Delta = Projected_Carbon - Starting_Carbon,
    Projected_Carbon_Flux = if_else(Year == First_Year, 0, Projected_Carbon_Delta / (Year - First_Year)),
    Measured_Carbon_Delta = Measured_Carbon - Starting_Carbon,
    Measured_Carbon_Flux = if_else(Year == First_Year, 0, Measured_Carbon_Delta / (Year - First_Year)),
    Starting_BA = max(if_else(Year == First_Year, Measured_BA, 0), na.rm = TRUE),
    Projected_BA_Delta = Projected_BA - Starting_BA,
    Measured_BA_Delta = Measured_BA - Starting_BA
  ) |>
  ungroup() |>
  filter(Year == First_Year | Year == Last_Year) |>
  filter(!is.na(Projected_Carbon) & !is.na(Measured_Carbon)) |>
  mutate(Projection_Years = Year - First_Year) |>
  mutate(BA_Residual = Projected_BA - Measured_BA) |>
  mutate(BA_Error = 2 * abs(BA_Residual) / (Projected_BA + Measured_BA)) |>
  mutate(BA_Delta_Residual = Projected_BA_Delta - Measured_BA_Delta) |>
  mutate(BA_Flux_Residual = BA_Delta_Residual / Projection_Years) |>
  mutate(Carbon_Residual = Projected_Carbon - Measured_Carbon) |>
  mutate(Carbon_Error = 2 * abs(Carbon_Residual) / (Projected_Carbon + Measured_Carbon)) |>
  mutate(Carbon_Delta_Residual = Projected_Carbon_Delta - Measured_Carbon_Delta) |>
  mutate(Carbon_Flux_Residual = Projected_Carbon_Flux - Measured_Carbon_Flux)

remove(
  projected_carbon_tmp,
  projected_ba_tmp,
  projected_tmp,
  surveyed_carbon_tmp,
  surveyed_ba_tmp,
  surveyed_tmp
)
```

Run a quick check to make sure the plots grew during the projection period,
rather than shrank.

```{r sanity-check-plots-grew}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Measured_BA_Delta)
  ) +
  geom_point(
    size = 2,
    alpha = 0.25,
  ) +
  geom_abline(intercept = 0, slope = 0) +
  #scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20, 22)) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nChange in FVS Measured BA (m² / ha) vs. Projection Years")
```

### Carbon Projection

```{r projected_carbon_vs_measured_carbon}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_Carbon, y = Projected_Carbon, color = Projection_Years)
  ) +
  geom_point(
#    size = 2,
    alpha = 0.25,
  ) +
  geom_abline(intercept = 0, slope = 1) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjected vs. Measured Carbon (Mg/ha)") +
  coord_cartesian(xlim = c(0, 300), ylim = c(0, 300))
```

```{r projected_carbon_vs_measured_carbon_with_trendline}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> arrange(Projection_Years),
    aes(x = Measured_Carbon, y = Projected_Carbon, color = Projection_Years)
  ) +
  geom_point(
#    size = 2,
    alpha = 0.25,
  ) +
  geom_abline(intercept = 0, slope = 1) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    color = 'brown',
    linetype = 'dashed',
    fullrange = TRUE,
    se = FALSE
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands FVS Projected vs. Measured Carbon") +
  xlab(bquote("Projected Stand Carbon" ~(Mg %*% ha^-1))) +
  ylab(bquote("Measured Stand Carbon" ~(Mg %*% ha^-1))) +
  coord_cartesian(xlim = c(0, 300), ylim = c(0, 300))
```

#### Carbon Flux

Which is great, but for large BA plots, only a small portion will be projected,
so the error is masked by the pre-existing BA. So, instead, look at measured
vs. projected carbon change.

```{r measured_vs_projected_carbon_change}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> arrange(Projection_Years),
    aes(x = Measured_Carbon_Delta, y = Projected_Carbon_Delta, color = Projection_Years)
  ) +
  geom_point(
#    size = 2,
    alpha = 0.25,
  ) +
  geom_abline(intercept = 0, slope = 1) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    color = 'brown',
    linetype = 'dashed',
    fullrange = TRUE,
    se = FALSE
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands FVS Projected vs. Measured Carbon Flux") +
  ylab(bquote("Projected Carbon Delta" ~(Mg %*% ha^-1))) +
  xlab(bquote("Measured Carbon Delta" ~(Mg %*% ha^-1))) +
  coord_cartesian(xlim = c(-100, 100), ylim = c(-100, 100))
```

```{r measured_vs_projected_carbon_flux}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> arrange(Projection_Years),
    aes(x = Measured_Carbon_Flux, y = Projected_Carbon_Flux, color = Projection_Years)
  ) +
  geom_point(
#    size = 2,
    alpha = 0.25,
  ) +
  geom_abline(intercept = 0, slope = 1) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    color = 'brown',
    linetype = 'dashed',
    fullrange = TRUE,
    se = FALSE
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands  FVS Projected vs. Measured Annual Carbon Flux") +
  xlab(bquote("Measured Annual Carbon Flux" ~(Mg %*% ha^-1 %*% year^-1))) +
  ylab(bquote("Projected Annual Carbon Flux" ~(Mg %*% ha^-1 %*% year^-1))) +
  coord_cartesian(xlim = c(-10, 10), ylim = c(-10, 10))
```

```{r projected-vs-measured-carbon-flux}
projected_vs_measured_with_n <- projected_vs_measured |>
  filter(Projection_Years > 0) |>
  group_by(`Forest Type Group`) |>
  mutate(`Forest Type Group` = paste0(`Forest Type Group`, ", n=", n())) |>
  ungroup()
  
ggplot(
    projected_vs_measured_with_n,
    aes(Projected_Carbon_Flux, fct_reorder(`Forest Type Group`, Measured_Carbon, .fun = sum))
  ) +
  geom_vline(xintercept = 0, color = 'red') +
  geom_boxplot(varwidth = TRUE) +
  # scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  geom_point(
    data = projected_vs_measured_with_n |>
      group_by(`Forest Type Group`) |> 
      summarize(
        Measured_Carbon_Flux = mean(Measured_Carbon_Flux),
        Measured_Carbon = sum(Measured_Carbon),
        .groups = 'keep'
      ) |> 
      ungroup(),
    aes(Measured_Carbon_Flux),
    color = 'blue',
    shape = 4,
    size = 3
  ) +
  ggtitle(bquote("Projected vs. Measured Annual Carbon Flux")) +
  xlab(bquote("Carbon Flux" ~(Mg %*% ha^-1 %*% year^-1))) +
  ylab("Forest Type Group")

```


#### Residuals

Let's look at carbon flux residuals.
This is Mg of carbon per hectare per year.

```{r carbon-flux-by-forest-type}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(Carbon_Flux_Residual, fct_reorder(`Forest Type Group`, Measured_Carbon, .fun = sum))
  ) +
  geom_vline(xintercept = 0, color = 'red') +
  geom_boxplot(varwidth = TRUE) +
  # scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  geom_point(
    data = projected_vs_measured |>
      filter(Projection_Years > 0) |> 
      group_by(`Forest Type Group`) |> 
      summarize(
        Measured_Carbon_Flux = mean(Measured_Carbon_Flux),
        Measured_Carbon = sum(Measured_Carbon),
        .groups = 'keep'
      ) |> 
      ungroup(),
    aes(Measured_Carbon_Flux),
    color = 'blue',
    shape = 4,
    size = 3
  ) +
  ggtitle(paste0(
    "FVS Projected Carbon Flux Residual by Forest Type Group",
    "\n",
    "for Grow-Only FIA Plots in the Northeast"
  )) +
  xlab(paste0(
    "Carbon Flux Residual (Mg/ha/year)",
    "\n",
    "(X = Mean Measured Carbon Flux)"
  )) +
  ylab("Forest Type Group")

```

```{r carbon-flux-by-forest-type-detail}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(Carbon_Flux_Residual, fct_reorder(`Forest Type Group`, Measured_Carbon, .fun = sum))
  ) +
  geom_vline(xintercept = 0, color = 'red') +
  geom_boxplot(varwidth = TRUE) +
  geom_point(
    data = projected_vs_measured |>
      filter(Projection_Years > 0) |> 
      group_by(`Forest Type Group`) |> 
      summarize(
        Measured_Carbon_Flux = mean(Measured_Carbon_Flux),
        Measured_Carbon = sum(Measured_Carbon),
        .groups = 'keep'
      ) |> 
      ungroup(),
    aes(Measured_Carbon_Flux),
    color = 'blue',
    shape = 4,
    size = 3
  ) +
#  scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  coord_cartesian(xlim = c(-5, 5)) +
  scale_x_continuous(breaks = c(-5, -2.5, 0, 2.5, 5)) +
  ggtitle(paste0(
    "FVS Projected Carbon Flux Residual by Forest Type Group",
    "\n",
    "for Grow-Only FIA Plots in the Northeast"
  )) +
  xlab(paste0(
    "Carbon Flux Residual (Mg/ha/year)",
    "\n",
    "(X = Mean Measured Carbon Flux)"
  )) +
  ylab("Forest Type Group")
```

```{r carbon-flux-by-ecoregion}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(Carbon_Flux_Residual, fct_reorder(ECOCD, Measured_Carbon, .fun = sum))
  ) +
  geom_vline(xintercept = 0, color = 'red') +
  geom_boxplot(varwidth = TRUE) +
#  scale_y_discrete(guide = guide_axis(n.dodge = 2)) +
  coord_cartesian(xlim = c(-5, 5)) +
  scale_x_continuous(breaks = c(-5, -2.5, 0, 2.5, 5)) +
  ggtitle("Grow-Only Stands\nCarbon Flux Residual by Ecoregion") +
  xlab("Carbon Flux Residual (Mg/ha/year)")
```

#### Residuals vs. Years Projected

```{r carbon_residual_vs_projection_years}
ggplot(
    projected_vs_measured|> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Carbon_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Projection Error (Mg/ha) vs. Projection Years")
```


```{r carbon_error_vs_projection_years}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Carbon_Error)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  coord_cartesian(xlim = c(10, 20), ylim = c(0, 1)) +
  scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20)) +
  ggtitle("Grow-Only Stands\nCarbon Projection Error (fraction) vs. Projection years")
  
```

```{r carbon_flux_residual_vs_projection_years}
ggplot(
    projected_vs_measured|> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Carbon_Flux_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Projection Flux Residual (Mg/ha) vs. Projection Years")
```

#### Residuals vs. BA

```{r carbon_residual_vs_measured_ba}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    mapping = aes(x = Measured_BA, y = Carbon_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Projection Residuals (Mg/ha) vs. Measured BA (m²/ha)")
  
```


```{r carbon_error_vs_measured_ba}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      filter(Carbon_Error < 1),
    aes(x = Measured_BA, y = Carbon_Error)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Projection Error (fraction) vs. Measured BA (m² / ha)")
```

This omits outliers; looking just at the outliers (error >= 2x value):

```{r carbon_error_vs_measured_ba_outliers}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      filter(Carbon_Error >= 1),
    aes(x = Measured_BA, y = Carbon_Error)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  coord_cartesian(xlim = c(0, 80), ylim = c(-15, 15)) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Projection Error Outliers vs. Measured BA (m² / ha)")

```

```{r carbon_flux_residual_vs_measured_ba}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    mapping = aes(x = Measured_BA, y = Carbon_Flux_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Flux Residual (Mg/ha) vs. Measured BA (m²/ha)")
  
```

#### Residuals vs. QMD

```{r carbon_residuals_vs_qmd}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> filter(QMD_METRIC < 100),
    aes(x = QMD_METRIC, y = Carbon_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Projection Error (Mg/ha) vs. Measured QMD (cm)")
```

```{r carbon_flux_residuals_vs_qmd}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> filter(QMD_METRIC < 100),
    aes(x = QMD_METRIC, y = Carbon_Flux_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  scale_x_log10() +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nCarbon Flux Residual (Mg/ha) vs. Measured QMD (cm)")
```

### Basal Area Projection

```{r projected_ba_vs_measured_ba}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_BA, y = Projected_BA, color = Projection_Years)
  ) +
  geom_point(
#    size = 2,
    alpha = 0.25,
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  geom_abline(intercept = 0, slope = 1) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nProjected vs. Measured Basal Area (m²/ha)")
```

```{r basal_area_trend}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      mutate(
        BA_Range = cut(Measured_BA, 0:19 * 5)
      ) |>
      group_by(`Forest Type Group`) |>
      mutate(`Forest Type Group` = paste0(`Forest Type Group`, ", n=", n())) |>
      ungroup()
    ,
    aes(x = BA_Range, y = BA_Flux_Residual)
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_boxplot(outlier.size = 0.1, varwidth = TRUE) +
  scale_fill_discrete(name = "Forest Type Group") +
  ggtitle("Measured vs. Projected BA for Grow-Only Stands") +
  ylab(bquote("BA Residual " (m^2 %*% hectare^-1 %*% year^-1))) +
  xlab(bquote("Measured Stand BA " (m^2 %*% hectare^-1)))

```

Can we plot plot location with size proportional to BA?

```{r plot_location_by_ecotype}
plot_location_tmp <- plot_location |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, long, lat, group)

plot_location_type <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == max(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  consolidate_forest_type_groups_filter() |>
  select(STATECD, COUNTYCD, PLOT, INVYR, BALIVE, `Forest Type Group`) |>
  left_join(plot_location_tmp, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  mutate(
    BA = conv_multiunit(BALIVE, "ft2 / acre", "m2 / hectare")
  )

ggplot(map_states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(
    plot_location_type,
    mapping = aes(long, lat, group = group, color = `Forest Type Group`, size = BA)
  ) +
  scale_size_binned_area(max_size = 3) +
  coord_quickmap() +
  ggtitle("Plot Location with Forest Type")

remove(plot_location_tmp)
```


#### Residuals vs. Years Projected

```{r ba_residual_vs_projection_years}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = BA_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20, 22)) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nBA Residual (m²/ha) vs. Projection Years")
  
```

```{r ba_error_vs_projection_years}
ggplot(
    projected_vs_measured |> filter(BA_Error < 1),
    aes(x = Projection_Years, y = BA_Error)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nBA Projection Error (fraction) vs. Projection years")
  
```

#### Residuals vs. QMD

```{r ba_residual_vs_qmd}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> filter(QMD_METRIC < 100),
    aes(x = QMD_METRIC, y = BA_Residual)
  ) +
  geom_point(
    alpha = 0.25
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'brown'
  ) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nBA Projection Residual (m²/ha) vs. Measured QMD (cm)")
```
