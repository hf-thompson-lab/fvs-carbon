---
title: "FVS Carbon Modeling Analysis"
author: "Nikolaus Bates-Haus"
output:
  html_document: default
  word_document: default
  pdf_document: default
editor_options:
  markdown:
    wrap: 72
---

# Setup

```{r setup, include=FALSE}
library(targets)
library(tarchetypes)
library(tidyverse)
library(reshape2) # melt()
library(measurements) # conv_unit and conv_multiunit
library(maps)
library(ggspatial)
options(scipen = 9) # Use integer notation for numbers under 9 digits
tar_source()
```


## Load targets results from other documents

```{r load tar objects defined elsewhere}
tar_load(fiadb)
tar_load(species_crosswalk)
```

## Preload targets results from this document

When tar_make() has already built the objects defined in this document,
run this block to pre-load them. You can then skip running ```{targets} blocks.

```{r load tar objects defined here, eval = FALSE}
get_this_rmd_file() |>
  tar_objects_defined_in_rmd() |>
  tar_load()
```

# Grow-Only Plots in the Northeast

Find all FIA plots in the northeastern region that are grow-only, that have
a measurement year between 1999 and 2004, and have at least two measurements
between 1999 and 2024. We select 1999 becasue FIA changed
to the 4-subplot structure in 1999; we select 2004 so that we will have
at least 20 years of growth. We require two measurements so that we can compare
projected vs. actual growth between measurements.

Survey filters:

*  PLOT.MEASYEAR > 1999 - really, we want DESIGNCD (plot design) == 1
*  max(PLOT.MEASYEAR) - min(PLOT.MEASYEAR) >= 10
*  BALIVE > 0

Northeastern region:

*  SURVEY.RSCD == 24

Grow-only is described previously:

*  Only one condition: max(FIA.COND.CONDID) == 1
*  Survey was not skipped: COND.COND_STATUS_CD == 1
*  Plot was not disturbed: COND.DSTRBCD1 == 0 & COND.DSTRBCD2 == 0 & COND.DSTRBCD3 == 0
*  Plot was not treated: COND.TRTCD1 == 0 & TRTCD2 == 0 & TRTCD3 == 0

The functions in `functions.R` define these filters

In addition, some plots have a lot of trees that are not supported by FVSne;
filter to plots where the most recent measurement shows at least 90% of basal area
is in trees supported by FVSne.

Execute the filters to create a list of matching plots.

```{targets nrs_plots_grown, tar_simple = TRUE}
# fvs_spcds: FIA SPCD if the species is supported by FVS
fvs_spcds <- species_crosswalk |>
  filter(!is.na(FVS_SPCD)) |>
  select(SPCD)

fia_plots_filtered(
  fiadb, filter = \(.data, con) {
    .data |>
      filter(INVYR >= 1999) |> # Do this first, it impacts later filters
      filter_plots_fvsne(con) |>
      filter_plots_modern(con) |>
      filter_plots_trees(con) |>
      filter_plots_long_measurement(con) |>
      filter_plots_forested(con) |>
      filter_plots_undisturbed(con) |>
      filter_plots_untreated(con) |>
      filter_plots_ba_frac(con, fvs_spcds, 0.9)
  })
```

How many plots is that?
```{r count nrs_plots_grown, eval = FALSE}
nrs_plots_grown |>
  distinct(STATECD, COUNTYCD, PLOT) |>
  nrow()
```

## Locations

Where are these plots?

First, find the states covered by FVSne.

In theory, we should use the FIA.PLOTGEOM.FVS_VARIANT to figure this out,
but that brings in states as far west as MN that have no FVSne plots anywhere
near them. Instead, we use NERS management area as the region.

```{targets fvsne_states, tar_simple = TRUE}
fia_plots_filtered(fiadb, plots = NULL, \(.data, con) {
  fia_state <- tbl(con, "REF_RESEARCH_STATION") |>
    distinct(STATECD, STATE_NAME, STATE_ABBR)

  .data |>
    filter_plots_ners(con) |>
    distinct(STATECD) |>
    left_join(fia_state, by = join_by(STATECD))
})
```

How many plots are in each state?

```{r state_plot_counts, eval = FALSE}
state_plot_counts <- nrs_plots_grown |>
  distinct(STATECD, COUNTYCD, PLOT) |>
  left_join(fvsne_states, by = join_by(STATECD)) |>
  group_by(STATE_NAME) |>
  summarize(COUNT = n()) |>
  ungroup() |>
  arrange(desc(COUNT))
knitr::kable(state_plot_counts)
```

Show the plots on a map.

```{r map nrs_plots_grown, eval = FALSE}
fvsne_states_map <- fvsne_states |>
  distinct(STATE_NAME) |>
  rename(region = STATE_NAME) |>
  _$region |>
  map_data('state', region = _)

plot_locations <- nrs_plots_grown |>
  filter(!is.na(LAT) & !is.na(LON)) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(row_number() == 1) |>
  ungroup() |>
  rename(lat = LAT, long = LON) |>
  mutate(group = sprintf('%02d%03d%05d', STATECD, COUNTYCD, PLOT))

ggplot(fvsne_states_map, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(data = plot_locations, color = alpha("blue", alpha = 0.5)) +
  coord_sf(crs = 4326) +
  annotation_scale(location = "br") +
  annotation_north_arrow(location = "tl",
    width = unit(1, "cm"),
    pad_x = unit(0.75, "cm"),
    pad_y = unit(0.5, "cm")
  ) +
  theme_bw()
```

## Stand Statistics

We can gather per-stand statistics such as BALIVE and CARBON_AG from the FIA
data for these plots over time.

```{targets nrs_plots_stats, tar_simple = TRUE}
fia_plots_filtered(fiadb, nrs_plots_grown, \(.data, con) {
    plots <- .data |> distinct(STATECD, COUNTYCD, PLOT, INVYR)
    plots_join_by <- join_by(STATECD, COUNTYCD, PLOT, INVYR)

    forest_type <- tbl(con, "REF_FOREST_TYPE") |>
      select(VALUE, MEANING) |>
      rename(FORTYPCD = VALUE) |>
      rename(FORTYPE = MEANING)
    
    tree_stats <- tbl(con, "TREE") |>
      inner_join(plots |> select(STATECD, COUNTYCD, PLOT, INVYR), by = plots_join_by) |>
      select(STATECD, COUNTYCD, PLOT, INVYR, DIA, CARBON_AG, TPA_UNADJ) |>
      group_by(STATECD, COUNTYCD, PLOT, INVYR) |>
      summarize(
        CARBON_AG = sum(CARBON_AG, na.rm = TRUE),
        CPA = sum(CARBON_AG * TPA_UNADJ, na.rm = TRUE),
        # Restrict to trees that match those used in QMD computation, below.
        BA_TREES = sum(if_else(DIA >= 1, TPA_UNADJ, 0), na.rm = TRUE),
        .groups = "keep"
      )
    
    cond_stats <- tbl(con, "COND") |>
      inner_join(plots |> select(STATECD, COUNTYCD, PLOT, INVYR), by = plots_join_by) |>
      select(STATECD, COUNTYCD, PLOT, INVYR, STDAGE, BALIVE, FORTYPCD) |>
      group_by(STATECD, COUNTYCD, PLOT, INVYR) |>
      # QMD = sqrt(sum(DIA^2) / n)
      # Which is equivalent to
      # QMD = sqrt(sum(BALIVE * TPA_UNADJ) / (n * k)), where n is number of trees,
      # and k is π/576 ≅ 0.005454 for B in square feet and QMD in inches;
      # and k is π/40000 ≅ 0.0000785 for B in square meters and QMD in centimeters.
      # (see https://www.sciencedirect.com/science/article/pii/S2197562023000453 ,
      # https://doi.org/10.1016/j.fecs.2023.100114 )
      # When computing QMD from BA we need to use the same trees for BA and n;
      # FIADB data dictionary 2.5.51 BALIVE says "Basal area in square feet per
      # acre of all live trees ω1.0 inch d.b.h/d.r.c sampled in the condition."
      summarize(
        BALIVE = sum(BALIVE, na.rm = TRUE),
        FORTYPCD = max(FORTYPCD, na.rm = TRUE),
        STDAGE = max(STDAGE, na.rm = TRUE),
        .groups = "keep"
      ) |>
      ungroup()
    
    .data |>
      select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR) |>
      left_join(cond_stats, by = plots_join_by) |>
      left_join(tree_stats, by = plots_join_by) |>
      left_join(forest_type, by = join_by(FORTYPCD)) |>
      rename(FOREST_TYPE = FORTYPE) |>
      mutate(
        STDAGE = if_else(STDAGE < 0, NA, STDAGE),
        FRTYGRCD = floor(FORTYPCD / 10) * 10
      ) |>
      left_join(forest_type, by = join_by(FRTYGRCD == FORTYPCD)) |>
      rename(FOREST_TYPE_GROUP = FORTYPE)
  }) |>
  filter_decode_forest_type_group() |>
  mutate(
    BALIVE_METRIC = conv_multiunit(BALIVE, "ft2 / acre", "m2 / hectare"),
    QMD = sqrt(BALIVE / (BA_TREES * (pi / 576))),
    QMD_METRIC = sqrt(BALIVE_METRIC / (BA_TREES * (pi / 40000))),
    CARBON_METRIC = conv_multiunit(CPA, "lbs / acre", "Mg / hectare")
  ) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  mutate(
    BALIVE_START = if_else(MEASYEAR == min(MEASYEAR, na.rm = TRUE), BALIVE_METRIC, NA),
    BALIVE_DELTA = BALIVE_METRIC - max(BALIVE_START, na.rm = TRUE),
    YEARS = MEASYEAR - min(MEASYEAR, na.rm = TRUE)
  ) |> 
  ungroup()
```

Plot location with visual distinction by forest type

```{r plot_location_by_ecotype, eval = FALSE}
plot_location_tmp <- nrs_plots_grown |>
  left_join(
    nrs_plots_stats |> select(STATECD, COUNTYCD, PLOT, INVYR, FOREST_TYPE_GROUP),
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
  ) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  select(CN, LAT, LON, FOREST_TYPE_GROUP) |>
  rename(
    group = CN,
    lat = LAT,
    long = LON
  ) |>
  group_by(FOREST_TYPE_GROUP) |>
  mutate(
    n = n(),
    group_name = paste0(FOREST_TYPE_GROUP, ", n=", n())
  ) |>
  ungroup()

ggplot(fvsne_states_map, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(
    plot_location_tmp,
    mapping = aes(long, lat, group = group, color = fct_reorder(group_name, desc(n)))
  ) +
  coord_sf(crs = 4326) +
  annotation_scale(location = "br") +
  annotation_north_arrow(location = "tl",
    width = unit(1, "cm"),
    pad_x = unit(0.75, "cm"),
    pad_y = unit(0.5, "cm")
  ) +
  theme_bw() +
  theme(legend.position = "bottom") +
  scale_color_discrete(name = NULL) +
  ggtitle("FIA Grow-Only Plots in the Northeast Region")

remove(plot_location_tmp)
```

Look at BA over time; first, by stand age, then as change over calendar time.

```{r balive_vs_stdage, eval = FALSE}
ggplot(
    data = nrs_plots_stats |>
      filter(!is.na(STDAGE)),
    mapping = aes(x = STDAGE, y = BALIVE_METRIC)
  ) +
  geom_bin2d() +
#  facet_wrap(~FOREST_TYPE_GROUP) +
  theme_bw() +
  ylab(bquote("Measured BA " ~ (m^2 %.% ha^-1))) +
  xlab(bquote("Stand Age (years)")) +
  ggtitle("Grow-Only Stands Measured BA vs Stand Age")
```

Look at change in BA (BAI) by stand age

```{r balive_delta_vs_years, eval = FALSE}
ggplot(
    nrs_plots_stats |>
      group_by(STATECD, COUNTYCD, PLOT) |>
      filter(MEASYEAR == max(MEASYEAR)) |>
      ungroup(),
    aes(x = YEARS, y = BALIVE_DELTA)
  ) +
  geom_bin2d() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  #scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20, 22)) +
  #facet_wrap(~FOREST_TYPE_GROUP) +
  ylab(bquote("Measured BA Delta " ~(m^2 %.% ha^-1))) +
  xlab("Projection Years") +
  ggtitle("Grow-Only Stands Measured BA Delta vs. Projection Years")
```

Measured Carbon by Forest Type Group

```{r seen_types, eval = FALSE}
seen_types <- nrs_plots_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(MEASYEAR == max(MEASYEAR, na.rm = TRUE)) |>
  ungroup() |>
  group_by(FOREST_TYPE_GROUP) |>
  summarize(
    CARBON_AG_METRIC = sum(conv_unit(CARBON_AG, "lbs", "Mg")),
    .groups = "keep"
  )

seen_types |>
  ggplot(
    aes(y = fct_reorder(FOREST_TYPE_GROUP, CARBON_AG_METRIC), x = CARBON_AG_METRIC)
  ) +
  scale_x_log10() +
  geom_col() +
  ggtitle("Total Carbon by Forest Type Group") +
  ylab("Forest Type") +
  xlab(bquote("Carbon " ~(`Mg C`)))
```

## Regeneration, Ingrowth, and Establishment

The Northeastern variant is a partial establishment model, so it does not
automatically perform natural regeneration. We will therefore use actual
ingrowth from the FIA data.

> TODO nik: RegRepts - keyword to generate regeneration reports
> TODO nik: DATASCRN - screen out trees below a diameter class, e.g. 3"
> TODO nik: TreeList - keyword to generate tree lists
> TODO nik: CALBSTDB - keyword to generate calibration stats table
> TODO nik: FVS Keyword Reference says of STDINFO:
>           > field 2: Stand habitat type code or plant community code
>           >          (ecological unit code in SN.)
>           > field 7: Potential Vegetation (field 2) Reference code.
>           >          For list of reference codes see FSVEG documentation.
>           Maybe we can get regen hints from FSVEG.

### Observed Ingrowth

fia.TREE_GRM_COMPONENT will mark a tree as 'INGROWTH' when
the tree is judged to be 'established', with a corresponding TREE record.
A tree marked 'INGROWTH' may have multiple TREE records if it is inventoried
after ingrowth, and if it grows on a microplot, in which case it will be
tracked from the time it is 1" DBH. If the tree grows on the microplot, then
its ingrowth is marked in MICR_COMPONENT_AL_FOREST; otherwise it is marked
in SUBP_COMPONENT_AL_FOREST. Multiple TREE_GRM_COMPONENT records for the tree
can be marked 'INGROWTH', in different inventories. It may also have other
records with other components, e.g. trees on the microplot will have a
'SURVIVOR' record in each inventory prior to ingrowth.

```{targets nrs_grm_ingrowth_all, tar_simple = TRUE}
fia_grm_ingrowth(fiadb, nrs_plots_grown)
```
Fetch the corresponding trees
```{targets nrs_trees_ingrowth_all, tar_simple = TRUE}
fia_trees_by_cn(fiadb, nrs_grm_ingrowth_all |> select(TRE_CN) |> rename(CN = TRE_CN))
```

We can use the trees to find duplicate records. There are duplicates because
some trees think they're allowed to ingrow more than once.

```{r nrs_trees_ingrowth_dupes, eval = FALSE}
nrs_trees_ingrowth_all |>
  group_by(STATECD, COUNTYCD, PLOT, SUBP, TREE) |>
  filter(n() > 1) |>
  summarize(.groups = "keep") |>
  nrow()
```

```{targets nrs_grm_ingrowth, tar_simple = TRUE}
multi_ingrowth <- nrs_trees_ingrowth_all |>
  group_by(STATECD, COUNTYCD, PLOT, SUBP, TREE) |>
  arrange(INVYR) |>
  filter(
    n() > 1,
    row_number() > 1
  ) |>
  select(CN)
nrs_grm_ingrowth_all |>
  anti_join(multi_ingrowth, by = join_by(TRE_CN == CN))
```

```{targets nrs_trees_ingrowth, tar_simple = TRUE}
multi_ingrowth <- nrs_trees_ingrowth_all |>
  group_by(STATECD, COUNTYCD, PLOT, SUBP, TREE) |>
  arrange(INVYR) |>
  filter(
    n() > 1,
    row_number() > 1
  ) |>
  select(CN)
nrs_trees_ingrowth_all |>
  anti_join(multi_ingrowth, by = join_by(CN))
```


```{r preview nrs_grm_ingrowth, eval = FALSE}
print(paste0("Ingrown trees: ", nrs_grm_ingrowth |> nrow()))
nrs_grm_ingrowth_with_measyear <- nrs_grm_ingrowth |>
  left_join(nrs_plots_grown |> select(CN, MEASYEAR), by = join_by(PLT_CN == CN))
print(paste0(
  "  ",
  nrow(nrs_grm_ingrowth) /
    nrow(nrs_plots_grown) /
    (max(nrs_grm_ingrowth_with_measyear$MEASYEAR) - min(nrs_grm_ingrowth_with_measyear$MEASYEAR)),
  " ingrown trees / plot / year"))
print(paste0("Ingrown trees over 3\" DBH: ", nrs_grm_ingrowth |> filter(DIA_END > 3) |> nrow()))
```

### FVS Restrictions on Ingrowth

FIA marks a tree as INGROWTH when it reaches 5" DBH; FVS Establishment
is restricted to trees <= 3" DBH:

Trees are injected into FVS via the Regeneration and Establishment model,
using the `Estab` keyword. This allows trees to be added to a plot during
a run. Normally these trees are seedlings, which the model will then grow;
the HTADJ keyword overrides the seedling processing and allows injection of
saplings.

The FVS guide to the Regeneration and Establishment model,
Appendix C on details for keywords, for HTADJ, says:

> Adjust regeneration tree heights before they are passed
> to the Prognosis Model. Heights after adjustment are
> bounded between the minimum establishment height
> listed in table 1 and the height of a tree 3 inches d.b.h.

```{r nrs_grm_ingrowth_histogram, eval = FALSE}
nrs_grm_ingrowth_with_measyear |>
  mutate(
    `> 3" DBH` = if_else(DIA_END > 3, MEASYEAR, NA),
    `≤ 3" DBH` = if_else(DIA_END <= 3, MEASYEAR, NA)
  ) |>
  select(TRE_CN, `> 3" DBH`, `≤ 3" DBH`) |>
  melt(
    id.vars = c('TRE_CN'),
    variable.name = 'Diameter at Ingrowth',
    value.name = 'Year'
  ) |>
  filter(!is.na(Year)) |>
  ggplot(aes(Year, fill = `Diameter at Ingrowth`)) +
  geom_histogram(binwidth = 1) +
  scale_fill_manual(values = c("red", "blue")) +
  theme_bw() +
  ggtitle('Ingrown trees on NRS grow-only plots') +
  xlab('Year') +
  ylab('Count')
```

```{r nrs_grm_ingrowth_boxplot, eval = FALSE}
nrs_grm_ingrowth_with_measyear |>
  select(DIA_END) |>
  ggplot(aes(DIA_END)) +
  geom_histogram(binwidth = 1) +
  scale_y_continuous(transform = "log10") +
  theme_bw() +
  xlab('Diameter at Ingrowth (inches)') +
  geom_vline(xintercept = 3, color = 'red')
```

There are ~50,000 trees that ingrow over the 25 years, so about 2 trees per
plot per 3 years.
Most of these trees are over the 3"DBH diameter limit on ingrowth set by FVS.

### Tree History

Trees >=1" DBH that grow on the microplot are in the TREE table in FIA,
so in some cases we should be able to follow a tree back to the point when it
was <=3" DBH. The microplot is ~8% of the plot, so we would expect ~8% of
ingrown trees to have observations prior to ingrowth, assuming that it
normally takes more than the average inter-inventory timespan (5 years) for
a tree to reach ingrowth size.

For this section, we'll use the following terminology, aligned with the FIA
database:

- Tree - an individual observation of a tree; a single record in the TREE table
- Tree History - a sequence of Trees linked by CN / PREV_TRE_CN in the TREE table
- First Tree - the Tree in a Tree History with the earliest INVYEAR
- Last Tree - the Tree in a Tree History with the latest INVYEAR

We identify a Tree History by the CN of the earliest tree in the history.

Fetch all the live trees for all the grown plots. Takes a while, but makes
everything else much faster.
```{targets nrs_trees_grown, tar_simple = TRUE}
nrs_trees_grown <- fia_trees(fiadb, nrs_plots_grown) |>
    filter(CONDID == 1) # only live trees
```

```{targets nrs_trees_history, tar_simple = TRUE}
# Get trees with CN, PREV_TRE_CN and  NEXT_TRE_CN to make it easy to traverse
# tree lineage in either direction
tree_prev_next <- nrs_trees_grown |>
  select(CN, PREV_TRE_CN) |>
  left_join(
    nrs_trees_grown |>
      select(CN, PREV_TRE_CN) |>
      rename(NEXT_TRE_CN = CN, CN = PREV_TRE_CN),
    by = join_by(CN)
  ) |>
  # Null out PREV_TRE_CN if it points to a tree we don't have access to.
  left_join(
    nrs_trees_grown |> select(CN) |> mutate(PREV_TRE_EXISTS = TRUE),
    by = join_by(PREV_TRE_CN == CN)
  ) |>
  mutate(
    PREV_TRE_CN = if_else(!is.na(PREV_TRE_EXISTS), PREV_TRE_CN, NA)
  ) |>
  select(!PREV_TRE_EXISTS)
  # Don't need to worry about NEXT_TRE_CN, since that join won't have
  # lined up and left dangling references.

# We've limited how far back we look in tree history, but have history
# all the way to the present. So we'll start with the most recent trees
# and stitch together history into the past.

# current trees is the set of trees currently being examined,
# one for each history of a tree
current_trees <- tree_prev_next |>
  filter(is.na(NEXT_TRE_CN))
  
# head trees are the first trees in each history
# We identify tree history by the earliest tree in that line,
# since that will never change.
head_trees <- current_trees |> filter(is.na(PREV_TRE_CN))
  
# Function to fetch trees matching PREV_TRE_CN
# This is used to walk earlier in time
earlier_trees <- function(.data) {
  tree_prev_next |> semi_join(.data, by = join_by(CN == PREV_TRE_CN))
}

# Function to fetch trees matching NEXT_TRE_CN
# This is used to walk later in time
later_trees <- function(.data) {
  tree_prev_next |> semi_join(.data, by = join_by(CN == NEXT_TRE_CN))
}

# Walk back to the beginning of time to find all the head trees
while ((current_trees <- earlier_trees(current_trees)) |> nrow() > 0) {
  head_trees <- bind_rows(
    head_trees,
    current_trees |> filter(is.na(PREV_TRE_CN))
  )
}

# Head trees now contains the earliest trees for all tree histories.
# Create a table of the entire history of each tree, of the form
# CN, FIRST_TRE_CN, LAST_TRE_CN
# We do this in three steps:
# 1. CN, FIRST_TRE_CN for the head trees (CN == FIRST_TRE_CN)
# 2. CN, FIRST_TRE_CN for trees where PREV_TRE_CN in CN
# Repeat step 2 until nothing more matches
# 3. Fill in LAST_TRE_CN for everything
  
current_trees <- head_trees |> filter(!is.na(NEXT_TRE_CN))
tree_history <- head_trees |> select(CN) |> mutate(FIRST_TRE_CN = CN, LAST_TRE_CN = CN)

while ((current_trees <- later_trees(current_trees)) |> nrow() > 0) {
  current_cns <- current_trees |> select(CN, PREV_TRE_CN) |> rename(LAST_TRE_CN = CN)
  updated_history_rows <- tree_history |>
    left_join(current_cns, by = join_by(LAST_TRE_CN == PREV_TRE_CN)) |>
    mutate(LAST_TRE_CN = coalesce(LAST_TRE_CN.y, LAST_TRE_CN)) |>
    select(CN, FIRST_TRE_CN, LAST_TRE_CN)
  new_history_rows <- current_trees |>
    select(CN, PREV_TRE_CN) |>
    mutate(LAST_TRE_CN = CN) |>
    left_join(tree_history |> select(CN, FIRST_TRE_CN), by = join_by(PREV_TRE_CN == CN)) |>
    select(CN, FIRST_TRE_CN, LAST_TRE_CN)
  tree_history <- bind_rows(
    updated_history_rows,
    new_history_rows
  )
}

# tree_history should have a record for every live tree.
stopifnot(nrs_trees_grown |> anti_join(tree_history, by = join_by(CN)) |> nrow() == 0)

# Paste metadata on to history records to be friendly
nrs_trees_history <- tree_history |>
  left_join(
    tree_prev_next, by = join_by(CN)
  ) |>
  left_join(
    nrs_trees_grown |>
      select(CN, STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR, SPCD, DIA, HT, CCLCD),
    by = join_by(CN)
  ) |>
  left_join(
    nrs_plots_grown |>
      select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR),
    by = join_by(STATECD, COUNTYCD, PLOT, INVYR)
  ) |>
  # Add a flag to indicate that a particular tree is marked as ingrowth in a
  # particular year
  left_join(
    nrs_grm_ingrowth |> select(TRE_CN) |> rename(CN = TRE_CN) |> mutate(ESTAB = TRUE),
    by = join_by(CN)
  ) |>
  mutate(
    ESTAB = if_else(!is.na(ESTAB), ESTAB, FALSE)
  )
```

Walk the tree history to see what diameter we can get to.

How many trees ingrow with DBH>3?
```{r dbh_gt_3, eval = FALSE}
nrs_trees_ingrowth |> filter(DIA > 3) |> nrow()
```

How many of those are traceable back to when they had DBH <= 3?
```{r dbh_le_3, eval = FALSE}
nrs_trees_history |>
  semi_join(
    nrs_trees_history |> filter(ESTAB == TRUE),
    by = join_by(CN == FIRST_TRE_CN)
  ) |>
  filter(DIA <= 3) |>
  nrow()
```

For the remaining trees we will need to back-project.

### Back-Projecting Trees

> TODO nik: use lm for all linear models!

#### GRM Estimated Growth Rate

fia.TREE_GRM_COMPONENT.ANN_DIA_GROWTH specifies annual diameter growth rate.
Looking at the values in this column, they seem small. We can check the
growth rate for trees where we have a previous observation by projecting
diameter growth backwards to the first MEASYEAR and seeing how close we
get to the first observed diameter.

```{r tree_growth_fia, eval = FALSE}
tree_growth_fia <- nrs_trees_history |>
  left_join(
    nrs_grm_ingrowth |> select(TRE_CN, ANN_DIA_GROWTH),
    by = join_by(CN == TRE_CN)
  ) |>
  filter(!is.na(DIA)) |>
  group_by(FIRST_TRE_CN) |>
  mutate(
    FIRST_DIA = min(DIA, na.rm = TRUE),
    FIRST_MEASYEAR = min(MEASYEAR, na.rm = TRUE)
  ) |>
  ungroup() |>
  filter(!is.na(ANN_DIA_GROWTH)) |>
  filter(FIRST_DIA < DIA) |>
  mutate(DIA_EST = DIA - (MEASYEAR - FIRST_MEASYEAR) * ANN_DIA_GROWTH) |>
  mutate(DIA_ERR = abs(100 * (DIA_EST - FIRST_DIA) / FIRST_DIA)) |>
  filter(!is.na(DIA_ERR)) |>
  arrange(DIA_ERR)

ggplot(tree_growth_fia, aes(DIA_ERR, after_stat(100 * count / sum(count)))) +
  geom_histogram(binwidth = 10, position = position_nudge(5)) +
  theme_bw() +
  ggtitle("Diameter Projection Error using GRM Growth Rate") +
  ylab("Frequency (%)") +
  xlab("Error (%) (binwidth = 10%)")
```

This shows that using the FIA growth rate, only 25% of trees back-project
to within 10% of their first surveyed diameter, so we can't rely on the FIA
growth rate when we don't have previous tree records for an ingrown tree.

Notes:

* Regeneration is heavily influenced by many things, from canopy structure
  to seed availability to predation to timing of canopy opening
* See competing articles on "Oh no! We get only sugar maple and no beech!"
  vs. "Oh no! We get only beech and no sugar maple!"
* "composition is stabilized by local landforms and [...] diversity increases
  with hydrologic catchment area"
* The best indicator of regeneration will unquestionably be actual regeneration

#### Observed Growth Rates

To estimate the time at which an ingrown tree was 3" DBH, we can project
growth backward in time based on the growth rates of similar trees. Defining
"similar" needs to be done with care. We can validate a model using the 8% of
ingrown trees for which we have measurements prior to ingrowth. We can use
our method to project these trees back in time to the earliest measurement,
and see how close we get to the measured value.

To do this, we need to capture how much each tree grew in each inventory.

tree_growth - adds to each tree:

 - *_DELTA - diameter/height/age change since previous inventory
 - ANN_*_DELTA - annualize rate of diameter change since previous inventory
  
This also fetches trees with only a single observation; these are useful
for calculating ingrowth.

```{targets nrs_trees_growth, tar_simple = TRUE}
# FIA.TREE.CN - sequence number
# FIA.TREE.TREE - TREE number
# FIA.TREE.CONDID - condition class; 1 = live tree
# FIA.TREE.SPCD - species code
# FIA.TREE.DIA - current diameter
# FIA.TREE.DIAHTCD - where diameter was taken, 1 = DBH
# FIA.TREE.HT - height
# FIA.TREE.SPGRPCD is broader than SPCD, group by that instead
# FIA.TREE.CCLCD - Crown Class code
# FIA.TREE.TPA_UNADJ - Trees Per Acre (Unadjusted)
# We want ingrowth for all the plots in plot_grow_only

prev_tre_mixin <- nrs_trees_history |>
  select(CN, MEASYEAR, DIA, HT) |>
  rename(
    PREV_TRE_CN = CN,
    PREV_MEASYEAR = MEASYEAR,
    PREV_DIA = DIA,
    PREV_HT = HT
  )

nrs_trees_history |>
  # Self-join to previous tree to get growth increment
  left_join(prev_tre_mixin, by = join_by(PREV_TRE_CN)) |>
  mutate(
    DIA_DELTA = DIA - PREV_DIA,
    AGE_DELTA = MEASYEAR - PREV_MEASYEAR,
    ANN_DIA_DELTA = DIA_DELTA / AGE_DELTA,
    HT_DELTA = HT - PREV_HT,
    ANN_HT_DELTA = HT_DELTA / AGE_DELTA
  ) |>
  select(
    CN, PREV_TRE_CN,
    STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR, SPCD, CCLCD,
    MEASYEAR, PREV_MEASYEAR, DIA, PREV_DIA, HT, PREV_HT,
    AGE_DELTA, DIA_DELTA, ANN_DIA_DELTA, HT_DELTA, ANN_HT_DELTA
  ) |>
  arrange(STATECD, COUNTYCD, PLOT, SUBP, TREE, MEASYEAR)
```

Measurement is imperfect, leading to some outliers in the growth table. We
can look at different outlier removal strategies and the resulting distribution
of observations:

```{r plot_tree_growth, eval = FALSE}
nrs_trees_growth |>
  left_join(species_crosswalk, by = join_by(SPCD)) |>
  select(CN, SPGRPCD, JENKINS_SPGRP_NAME, ANN_DIA_DELTA) |>
  filter(!is.na(ANN_DIA_DELTA)) |>
  group_by(SPGRPCD) |>
  arrange(ANN_DIA_DELTA) |>
  mutate(
    ONE_OUTLIER = (row_number() < (n() * 0.01)) | (row_number() > (n() - n() * 0.01)),
    TWO_OUTLIER = (row_number() < (n() * 0.025)) | (row_number() > (n() - n() * 0.025))
  ) |>
  ungroup() |>
  group_by(JENKINS_SPGRP_NAME) |>
  mutate(
    GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())
  ) |>
  ungroup() |>
  mutate(
    `1%` = if_else(!ONE_OUTLIER, ANN_DIA_DELTA, NA),
    `2.5%` = if_else(!TWO_OUTLIER, ANN_DIA_DELTA, NA),
    `0%` = ANN_DIA_DELTA
  ) |>
  select(CN, GROUP_NAME, `1%`, `2.5%`, `0%`) |>
  melt(
    id.vars = c("CN", "GROUP_NAME"),
    variable.name = "Outliers Removed",
    value.name = "Growth Rate"
  ) |>
  filter(!is.na(`Growth Rate`)) |>
  mutate(`Outliers Removed` = factor(`Outliers Removed`, levels = c("0%", "1%", "2.5%"))) |>
  ggplot(
    aes(`Growth Rate`, fct_rev(fct_infreq(GROUP_NAME)), fill = `Outliers Removed`)
  ) +
  geom_boxplot(outlier.size = 1) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  scale_fill_discrete(breaks = c("2.5%", "1%", "0%")) +
  ggtitle("Measured Annual Growth by Species Group") +
  xlab(bquote("Annual Growth " ~(inch %.% yr^-1))) +
  ylab("Species Group")

```

#### Estimated Growth Rate

From the observed growth with outliers removed, we can compute per-species,
per-plot, per-inventory growth rates. We can then apply these growth rates
to ingrown trees to back-project them to their starting diameter.

For each plot/species/inventory, we compute the growth rate of that species
on that plot in that inventory, based on the trees of that species on that plot
during that inventory. Some variations filter out growth outliers.

For growth rate, we prioritize:

1. The mean growth rate of at least 3 dominant trees of the species during the inventory;
2. The mean growth rate of at least 3 trees of any dominance of the species during the inventory;
3. The mean growth rate of at least 3 trees of any dominance of the species group during the inventory;
4. The mean growth rate of at least 3 trees of any dominance of the species group on the plot during any inventory.

tree_growth_rate - all computable growth rates for all plot/species/inventory

```{r tree_growth_rate, eval = FALSE}
tree_growth_with_outliers <- nrs_trees_growth |>
  filter(!is.na(ANN_DIA_DELTA)) |>
  group_by(SPCD) |>
  arrange(ANN_DIA_DELTA) |>
  mutate(
    OUTLIER_ONE = (row_number() > (n() * 0.01)) & (row_number() < (n() - n() * 0.01)),
    DIA_DELTA_ONE = if_else(OUTLIER_ONE, DIA_DELTA, NA),
    OUTLIER_TWO = (row_number() > (n() * 0.025)) & (row_number() < (n() - n() * 0.025)),
    DIA_DELTA_TWO = if_else(OUTLIER_TWO, DIA_DELTA, NA)
  ) |>
  left_join(species_crosswalk, by = join_by(SPCD)) |>
  ungroup()

tree_growth_dom <- tree_growth_with_outliers |>
  filter(CCLCD <= 3) |>
  group_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD) |>
  summarize(
    DIA_DELTA = mean(DIA_DELTA, na.rm = TRUE),
    COUNT = n(),
    COUNT_ONE = sum(OUTLIER_ONE, na.rm = TRUE),
    COUNT_TWO = sum(OUTLIER_TWO, na.rm = TRUE),
    DIA_DELTA_DOM = mean(DIA_DELTA, na.rm = TRUE),
    DIA_DELTA_DOM_ONE = mean(DIA_DELTA_ONE, na.rm = TRUE),
    DIA_DELTA_DOM_TWO = mean(DIA_DELTA_TWO, na.rm = TRUE),
    .groups = 'keep'
  ) |>
  ungroup() |>
  mutate(
    DIA_DELTA_DOM = if_else(COUNT >= 3, DIA_DELTA_DOM, NA),
    DIA_DELTA_DOM_ONE = if_else(COUNT_ONE >= 3, DIA_DELTA_DOM_ONE, NA),
    DIA_DELTA_DOM_TWO = if_else(COUNT_TWO >= 3, DIA_DELTA_DOM_TWO, NA)
  ) |>
  select(
    STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
    DIA_DELTA_DOM, DIA_DELTA_DOM_ONE, DIA_DELTA_DOM_TWO
    )

tree_growth_spcd <- tree_growth_with_outliers |>
  group_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD) |>
  summarize(
    DIA_DELTA = mean(DIA_DELTA, na.rm = TRUE),
    COUNT = n(),
    COUNT_ONE = sum(OUTLIER_ONE, na.rm = TRUE),
    COUNT_TWO = sum(OUTLIER_TWO, na.rm = TRUE),
    DIA_DELTA_SPCD = mean(DIA_DELTA, na.rm = TRUE),
    DIA_DELTA_SPCD_ONE = mean(DIA_DELTA_ONE, na.rm = TRUE),
    DIA_DELTA_SPCD_TWO = mean(DIA_DELTA_TWO, na.rm = TRUE),
    .groups = 'keep'
  ) |>
  ungroup() |>
  mutate(
    DIA_DELTA_SPCD = if_else(COUNT >= 3, DIA_DELTA_SPCD, NA),
    DIA_DELTA_SPCD_ONE = if_else(COUNT_ONE >= 3, DIA_DELTA_SPCD_ONE, NA),
    DIA_DELTA_SPCD_TWO = if_else(COUNT_TWO >= 3, DIA_DELTA_SPCD_TWO, NA)
  ) |>
  select(
    STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
    DIA_DELTA_SPCD, DIA_DELTA_SPCD_ONE, DIA_DELTA_SPCD_TWO
  )

tree_growth_spgrpcd <- tree_growth_with_outliers |>
  group_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPGRPCD) |>
  summarize(
    DIA_DELTA = mean(DIA_DELTA, na.rm = TRUE),
    COUNT = n(),
    COUNT_ONE = sum(OUTLIER_ONE, na.rm = TRUE),
    COUNT_TWO = sum(OUTLIER_TWO, na.rm = TRUE),
    DIA_DELTA_SPGRPCD = mean(DIA_DELTA, na.rm = TRUE),
    DIA_DELTA_SPGRPCD_ONE = mean(DIA_DELTA_ONE, na.rm = TRUE),
    DIA_DELTA_SPGRPCD_TWO = mean(DIA_DELTA_TWO, na.rm = TRUE),
    .groups = 'keep'
  ) |>
  ungroup() |>
  mutate(
    DIA_DELTA_SPGRPCD = if_else(COUNT >= 3, DIA_DELTA_SPGRPCD, NA),
    DIA_DELTA_SPGRPCD_ONE = if_else(COUNT_ONE >= 3, DIA_DELTA_SPGRPCD_ONE, NA),
    DIA_DELTA_SPGRPCD_TWO = if_else(COUNT_TWO >= 3, DIA_DELTA_SPGRPCD_TWO, NA)
  ) |>
  select(
    STATECD, COUNTYCD, PLOT, MEASYEAR, SPGRPCD,
    DIA_DELTA_SPGRPCD, DIA_DELTA_SPGRPCD_ONE, DIA_DELTA_SPGRPCD_TWO
  )

tree_growth_multiyear <- tree_growth_with_outliers |>
  mutate(
    ANN_DIA_DELTA = DIA_DELTA / (MEASYEAR - PREV_MEASYEAR),
    ANN_DIA_DELTA_ONE = DIA_DELTA_ONE / (MEASYEAR - PREV_MEASYEAR),
    ANN_DIA_DELTA_TWO = DIA_DELTA_TWO / (MEASYEAR - PREV_MEASYEAR)
  ) |>
  group_by(STATECD, COUNTYCD, PLOT, SPGRPCD) |>
  summarize(
    COUNT = n(),
    COUNT_ONE = sum(OUTLIER_ONE, na.rm = TRUE),
    COUNT_TWO = sum(OUTLIER_TWO, na.rm = TRUE),
    ANN_DIA_DELTA_MULTIYEAR = mean(ANN_DIA_DELTA, na.rm = TRUE),
    ANN_DIA_DELTA_MULTIYEAR_ONE = mean(ANN_DIA_DELTA_ONE, na.rm = TRUE),
    ANN_DIA_DELTA_MULTIYEAR_TWO = mean(ANN_DIA_DELTA_TWO, na.rm = TRUE),
    .groups = 'keep'
  ) |>
  ungroup() |>
  mutate(
    ANN_DIA_DELTA_MULTIYEAR = if_else(COUNT >= 3, ANN_DIA_DELTA_MULTIYEAR, NA),
    ANN_DIA_DELTA_MULTIYEAR_ONE = if_else(COUNT_ONE >= 3, ANN_DIA_DELTA_MULTIYEAR_ONE, NA),
    ANN_DIA_DELTA_MULTIYEAR_TWO = if_else(COUNT_TWO >= 3, ANN_DIA_DELTA_MULTIYEAR_TWO, NA)
  ) |>
  select(
    STATECD, COUNTYCD, PLOT, SPGRPCD,
    ANN_DIA_DELTA_MULTIYEAR, ANN_DIA_DELTA_MULTIYEAR_ONE, ANN_DIA_DELTA_MULTIYEAR_TWO
  )

tree_growth_rate <- tree_growth_with_outliers |>
  distinct(STATECD, COUNTYCD, PLOT, MEASYEAR, PREV_MEASYEAR, SPCD) |>
  left_join(species_crosswalk, by = join_by(SPCD)) |>
  left_join(tree_growth_dom, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)) |>
  left_join(tree_growth_spcd, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)) |>
  left_join(tree_growth_spgrpcd, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPGRPCD)) |>
  left_join(tree_growth_multiyear, by = join_by(STATECD, COUNTYCD, PLOT, SPGRPCD)) |>
  mutate(
    DIA_DELTA = coalesce(
      DIA_DELTA_DOM,
      DIA_DELTA_SPCD,
      DIA_DELTA_SPGRPCD
    ),
    ANN_DIA_DELTA = coalesce(
      DIA_DELTA / (MEASYEAR - PREV_MEASYEAR),
      ANN_DIA_DELTA_MULTIYEAR
    ),
    DIA_DELTA_ONE = coalesce(
      DIA_DELTA_DOM_ONE,
      DIA_DELTA_SPCD_ONE,
      DIA_DELTA_SPGRPCD_ONE
    ),
    ANN_DIA_DELTA_ONE = coalesce(
      DIA_DELTA_ONE / (MEASYEAR - PREV_MEASYEAR),
      ANN_DIA_DELTA_MULTIYEAR_ONE
    ),
    DIA_DELTA_TWO = coalesce(
      DIA_DELTA_DOM_TWO,
      DIA_DELTA_SPCD_TWO,
      DIA_DELTA_SPGRPCD_TWO
    ),
    ANN_DIA_DELTA_TWO = coalesce(
      DIA_DELTA_TWO / (MEASYEAR - PREV_MEASYEAR),
      ANN_DIA_DELTA_MULTIYEAR_TWO
    )
  )
```

```{r tree_growth_rate_boxplot, eval = FALSE}
tree_growth_rate |>
  group_by(JENKINS_SPGRP_NAME) |>
  mutate(
    GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())
  ) |>
  ungroup() |>
  select(GROUP_NAME, ANN_DIA_DELTA, ANN_DIA_DELTA_ONE, ANN_DIA_DELTA_TWO) |>
  rename(`0%` = ANN_DIA_DELTA, `1%` = ANN_DIA_DELTA_ONE, `2.5%` = ANN_DIA_DELTA_TWO) |>
  melt(id.vars = c("GROUP_NAME"), value.name = "ANN_DIA_DELTA", variable.name = "Outliers Removed") |>
  filter(!is.na(ANN_DIA_DELTA)) |>
  ggplot(
      aes(ANN_DIA_DELTA, fct_rev(fct_infreq(GROUP_NAME)), fill = `Outliers Removed`)
    ) +
    geom_boxplot() +
    geom_vline(xintercept = 0, linetype = "dashed") +
    scale_fill_discrete(breaks = c("2.5%", "1%", "0%")) +
    coord_cartesian(xlim = c(-1, 1)) +
    theme_bw() +
    ggtitle("Measured Annual Diameter Growth of Ingrown Trees") +
    xlab(bquote("Annual Diameter Growth " ~(inch %.% yr^-1))) +
    ylab("Species Group")

```

```{r tree_growth_rate_boxplot_metric, eval = FALSE}
tree_growth_rate |>
  group_by(JENKINS_SPGRP_NAME) |>
  mutate(
    GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())
  ) |>
  ungroup() |>
  select(GROUP_NAME, ANN_DIA_DELTA, ANN_DIA_DELTA_ONE, ANN_DIA_DELTA_TWO) |>
  rename(`0%` = ANN_DIA_DELTA, `1%` = ANN_DIA_DELTA_ONE, `2.5%` = ANN_DIA_DELTA_TWO) |>
  melt(id.vars = c("GROUP_NAME"), value.name = "ANN_DIA_DELTA", variable.name = "Outliers Removed") |>
  filter(!is.na(ANN_DIA_DELTA)) |>
  mutate(ANN_DIA_DELTA = conv_unit(ANN_DIA_DELTA, "inch", "meter") * pi * 2) |>
  ggplot(
      aes(ANN_DIA_DELTA, fct_rev(fct_infreq(GROUP_NAME)), fill = `Outliers Removed`)
    ) +
    geom_boxplot() +
    geom_vline(xintercept = 0, linetype = "dashed") +
    scale_fill_discrete(breaks = c("2.5%", "1%", "0%")) +
    coord_cartesian(xlim = c(-0.2, 0.2)) +
    theme_bw() +
    ggtitle("Measured Basal Area Increment of Ingrown Trees") +
    xlab(bquote("Basal Area Increment " ~(m^2 %.% yr^-1))) +
    ylab("Species Group")

```

#### One-Shot Back-Projection

Can we use that to back-project ingrown trees?

```{r manual_back_projection, eval = FALSE}
nrs_trees_growth |>
  left_join(nrs_trees_history |> select(CN, FIRST_TRE_CN, ESTAB), by = join_by(CN)) |>
  group_by(FIRST_TRE_CN) |>
  arrange(MEASYEAR) |>
  mutate(
    FIRST_DIA = if_else(row_number() == 1, DIA, NA),
    FIRST_MEASYEAR = if_else(row_number() == 1, MEASYEAR, NA)
  ) |>
  fill(FIRST_DIA, FIRST_MEASYEAR, .direction = "down") |>
  ungroup() |>
  filter(ESTAB) |> # trees that ingrow
  filter(FIRST_DIA < DIA) |> # Trees that grow
  left_join(tree_growth_rate, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)) |>
  mutate(
    DIA_EST = DIA - (MEASYEAR - FIRST_MEASYEAR) * ANN_DIA_DELTA_MULTIYEAR,
    DIA_ERR = (DIA_EST - FIRST_DIA) / FIRST_DIA,
    DIA_EST_ONE = DIA - (MEASYEAR - FIRST_MEASYEAR) * ANN_DIA_DELTA_MULTIYEAR_ONE,
    DIA_ERR_ONE = (DIA_EST_ONE - FIRST_DIA) / FIRST_DIA,
    DIA_EST_TWO = DIA - (MEASYEAR - FIRST_MEASYEAR) * ANN_DIA_DELTA_MULTIYEAR_TWO,
    DIA_ERR_TWO = (DIA_EST_TWO - FIRST_DIA) / FIRST_DIA
  ) |>
  arrange(DIA_ERR) |>
  group_by() |>
  summarize(
    COUNT = n(),
    MISSING = sum(is.na(DIA_EST), na.rm = TRUE) / COUNT,
    MISSING_ONE = sum(is.na(DIA_EST_ONE), na.rm = TRUE) / COUNT,
    MISSING_TWO = sum(is.na(DIA_EST_TWO), na.rm = TRUE) / COUNT,
    HIT = sum(abs(DIA_ERR) < 0.1, na.rm = TRUE) / COUNT,
    HIT_ONE = sum(abs(DIA_ERR_ONE) < 0.1, na.rm = TRUE) / COUNT,
    HIT_TWO = sum(abs(DIA_ERR_TWO) < 0.1, na.rm = TRUE) / COUNT,
    .groups = 'keep'
  ) |>
  ungroup() |>
  pivot_longer(everything()) |>
  knitr::kable()
```

Still less than half the trees back-project to within 10% of their first
measured diameter.

#### Stepwise Back-Projection

Rather than try to project back to starting diameter in one step, we can
project the diameter back to the estimated diameter at the previous measurement,
and repeat back in time until we get to the starting diameter. This will
better use per-inventory diameters.

tree_ingrown has one tree record for each year an ingrown tree was inventoried.
We can fill in a DIA_EST using the growth interval, and iterate until
they're all filled in.

```{r init_stepwise_manual_back_projection, eval = FALSE}
manual_back_projection <- nrs_trees_growth |>
  # Start with actually ingrown trees
  semi_join(nrs_trees_history |> filter(ESTAB), by = join_by(CN)) |>
  select(CN, STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD, PREV_TRE_CN, DIA) |>
  left_join(
    tree_growth_rate |>
      select(
        STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
        DIA_DELTA, DIA_DELTA_ONE, DIA_DELTA_TWO
      ),
    by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)
  ) |>
  # We can get a perfect estimate if we know the actual value :-D
  mutate(
    DIA_EST = DIA,
    DIA_EST_ONE = DIA,
    DIA_EST_TWO = DIA
  ) |>
  mutate(
    PREV_DIA_EST = DIA - DIA_DELTA,
    PREV_DIA_EST_ONE = DIA - DIA_DELTA_ONE,
    PREV_DIA_EST_TWO = DIA - DIA_DELTA_TWO
  ) |>
  mutate(
    DIA_ERR = abs((DIA - DIA_EST) / DIA),
    DIA_ERR_ONE = abs((DIA - DIA_EST_ONE) / DIA),
    DIA_ERR_TWO = abs((DIA - DIA_EST_TWO) / DIA),
  )

# Back-projectable trees:
manual_back_projection |> nrow()
```

```{r stepwise_manual_back_projection, eval = FALSE}
prev_tre_cns <- manual_back_projection |>
  select(PREV_TRE_CN) |>
  filter(!is.na(PREV_TRE_CN))

iterations <- 0
while (nrow(prev_tre_cns) > 0) {
  print(paste0(
    "Iteration: ",
    iterations <- iterations + 1,
    ", CNs: ",
    nrow(prev_tre_cns)
  ))
  tmp_trees <- nrs_trees_growth |>
    semi_join(prev_tre_cns, by = join_by(CN == PREV_TRE_CN)) |>
    select(CN, STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD, PREV_TRE_CN, DIA) |>
        # Join on growth rates
    left_join(
      tree_growth_rate |>
        select(
          STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
          DIA_DELTA, DIA_DELTA_ONE, DIA_DELTA_TWO
        ),
      by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)
    ) |>
    # Join on previously estimated diameter
    left_join(
      manual_back_projection |>
        select(PREV_TRE_CN, PREV_DIA_EST, PREV_DIA_EST_ONE, PREV_DIA_EST_TWO) |>
        rename(
          CN = PREV_TRE_CN,
          DIA_EST = PREV_DIA_EST,
          DIA_EST_ONE = PREV_DIA_EST_ONE,
          DIA_EST_TWO = PREV_DIA_EST_TWO
        ),
      by = join_by(CN)
    ) |>
    mutate(
      DIA_ERR = abs(DIA - DIA_EST) / DIA,
      DIA_ERR_ONE = abs(DIA - DIA_EST_ONE) / DIA,
      DIA_ERR_TWO = abs(DIA - DIA_EST_TWO) / DIA
    ) |>
    # Estimate the next previous tree diameter
    mutate(
      PREV_DIA_EST = DIA_EST - DIA_DELTA,
      PREV_DIA_EST_ONE = DIA_EST_ONE - DIA_DELTA_ONE,
      PREV_DIA_EST_TWO = DIA_EST_TWO - DIA_DELTA_TWO
    )
  # Apparently, some trees can be tracked back before the beginning of time
  # or something, so we can end up with some PREV_TRE_CNs that are
  # dangling refrences.
  if (nrow(tmp_trees) == 0) {
    break
  }
  manual_back_projection <- bind_rows(manual_back_projection, tmp_trees)
  num_duplicate_cns <- manual_back_projection |>
    group_by(CN) |>
    filter(n() > 1) |>
    ungroup() |> nrow()
  stopifnot(num_duplicate_cns == 0)
  # The next set of prev_tre_cns is:
  prev_tre_cns <- manual_back_projection |>
    # All PREV_TRE_CN mentioned
    select(PREV_TRE_CN) |>
    filter(!is.na(PREV_TRE_CN)) |>
    distinct() |>
    # that have not already been processed
    anti_join(
      manual_back_projection |>
        select(CN) |>
        filter(!is.na(CN)) |>
        distinct(),
      by = join_by(PREV_TRE_CN == CN)
    )
}
manual_back_projection |>
  group_by() |>
  summarize(
    COUNT = n(),
    MISSING = sum(is.na(DIA_EST), na.rm = TRUE) / COUNT,
    MISSING_ONE = sum(is.na(DIA_EST_ONE), na.rm = TRUE) / COUNT,
    MISSING_TWO = sum(is.na(DIA_EST_TWO), na.rm = TRUE) / COUNT,
    HIT = sum(abs(DIA_ERR) < 0.1, na.rm = TRUE) / COUNT,
    HIT_ONE = sum(abs(DIA_ERR_ONE) < 0.1, na.rm = TRUE) / COUNT,
    HIT_TWO = sum(abs(DIA_ERR_TWO) < 0.1, na.rm = TRUE) / COUNT,
    .groups = 'keep'
  ) |>
  ungroup() |>
  pivot_longer(everything()) |>
  knitr::kable()

```

Apply Back-Projection

```{r projected_vs_measured_annual_growth, eval = FALSE}
projected_annual_growth <- nrs_trees_growth |>
  left_join(nrs_trees_history |> select(CN, FIRST_TRE_CN, ESTAB), by = join_by(CN)) |>
  group_by(FIRST_TRE_CN) |>
  arrange(MEASYEAR) |>
  mutate(
    FIRST_DIA = if_else(row_number() == 1, DIA, NA),
    FIRST_MEASYEAR = if_else(row_number() == 1, MEASYEAR, NA)
  ) |>
  fill(FIRST_DIA, FIRST_MEASYEAR, .direction = "down") |>
  ungroup() |>
  filter(ESTAB) |> # trees that ingrow
  left_join(
    manual_back_projection |>
      select(CN, DIA_EST, DIA_EST_ONE, DIA_EST_TWO),
    by = join_by(FIRST_TRE_CN == CN)
  ) |>

  # Be metric
  mutate(
    DIA = conv_unit(DIA, "in", "cm"),
    FIRST_DIA = conv_unit(FIRST_DIA, "in", "cm"),
    DIA_EST = conv_unit(DIA_EST, "in", "cm"),
    DIA_EST_ONE = conv_unit(DIA_EST_ONE, "in", "cm"),
    DIA_EST_TWO = conv_unit(DIA_EST_TWO, "in", "cm"),
  ) |>

  mutate(
    ANN_DIA = (DIA - FIRST_DIA) / (MEASYEAR - FIRST_MEASYEAR),
    DIA_ERR = (FIRST_DIA - DIA_EST),
    ANN_DIA_EST = (DIA - DIA_EST) / (MEASYEAR - FIRST_MEASYEAR),
    ANN_DIA_ERR = DIA_ERR / (MEASYEAR - FIRST_MEASYEAR),
    DIA_ERR_ONE = (FIRST_DIA - DIA_EST_ONE),
    ANN_DIA_EST_ONE = (DIA - DIA_EST_ONE) / (MEASYEAR - FIRST_MEASYEAR),
    ANN_DIA_ERR_ONE = DIA_ERR_ONE / (MEASYEAR - FIRST_MEASYEAR),
    DIA_ERR_TWO = (FIRST_DIA - DIA_EST_TWO),
    ANN_DIA_EST_TWO = (DIA - DIA_EST_TWO) / (MEASYEAR - FIRST_MEASYEAR),
    ANN_DIA_ERR_TWO = DIA_ERR_TWO / (MEASYEAR - FIRST_MEASYEAR),
  ) |>
  filter(!is.na(DIA_ERR)) |>
  left_join(species_crosswalk, by = join_by(SPCD)) |>
  group_by(JENKINS_SPGRP_NAME) |>
  mutate(GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())) |>
  ungroup() |>
  select(CN, GROUP_NAME, ANN_DIA, ANN_DIA_EST, ANN_DIA_EST_ONE, ANN_DIA_EST_TWO) |>
  rename(
    `Measured` = ANN_DIA,
    `Estimated` = ANN_DIA_EST,
    `Est - 1%` = ANN_DIA_EST_ONE,
    `Est - 2.5%` = ANN_DIA_EST_TWO
  ) |>
  melt(
    id.vars = c("CN", "GROUP_NAME"),
    variable.name = "Series",
    value.name = "Growth"
  ) |>
  filter(!is.na(Growth)) |>
  mutate(Growth = conv_unit(Growth, "in", "m") * pi * 2)
ggplot(
  projected_annual_growth,
  aes(Growth, fct_rev(fct_infreq(GROUP_NAME)), fill = `Series`)
) +
  geom_boxplot(outlier.size = 0.1) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_fill_discrete(breaks = rev(levels(projected_annual_growth$Series))) +
  #coord_cartesian(xlim = c(-0.2, 0.2)) +
  theme_bw() +
  ggtitle("Projected vs. Measured BAI of Ingrown Trees") +
  xlab(bquote("Basal Area Increment " ~(m^2 %.% yr^-1))) +
  ylab("Species Group")
```

This looks usable.

#### Back-Project to <= 3" DBH

Using estimated diameter, what portion of ingrown trees
can we project back to 3" DBH before the first MEASYEAR?

```{r init_tree_ingrown_three, eval = FALSE}
tree_ingrown_three <- nrs_trees_growth |>
  # Start with actually ingrown trees
  semi_join(nrs_grm_ingrowth, by = join_by(CN == TRE_CN)) |>
  select(CN, STATECD, COUNTYCD, PLOT, SUBP, TREE, MEASYEAR, SPCD, DIA) |>
  left_join(
    tree_growth_rate |>
      select(
        STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
        PREV_MEASYEAR,
        DIA_DELTA, DIA_DELTA_ONE, DIA_DELTA_TWO
      ),
    by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD)
  ) |>
  # Fill in estimated diameters
  mutate(
    FIRST_MEASYEAR = if_else(DIA > 3, PREV_MEASYEAR, MEASYEAR),
    FIRST_DIA_EST = if_else(DIA > 3, DIA - DIA_DELTA, DIA),
    FIRST_DIA_EST_ONE = if_else(DIA > 3, DIA - DIA_DELTA_ONE, DIA),
    FIRST_DIA_EST_TWO = if_else(DIA > 3, DIA - DIA_DELTA_TWO, DIA)
  ) |>
  mutate(
    PREV_MEASYEAR = if_else(FIRST_DIA_EST > 3, PREV_MEASYEAR, NA)
  )
```

```{r tree_ingrown_three, eval = FALSE}
# Graft on the growth for the previous inventory
# project back that growth
# calculate the estimated diameter
# anything that's at 3", or that doesn't have a prev_measyear, gets filtered out
# (set to NULL?)
# move prev_measyear back a notch
# repeat
prev_measyears <- tree_ingrown_three |>
  filter(!is.na(PREV_MEASYEAR)) |>
  select(CN, PREV_MEASYEAR)

# Less efficient, but amusing and probably worth it:
# run prev_measyear back by max(prev_measyears), so
# we can print the year we're projecting. Then
# do the join on tree_ingrown_three and tree_growth_rate
# with appropriate measyears.
iterations <- 0
while (nrow(prev_measyears) > 0) {
  print(paste0(
    "Iteration: ",
    iterations <- iterations + 1,
    ", Trees: ",
    nrow(prev_measyears),
    ", Years: ",
    min(prev_measyears$PREV_MEASYEAR),
    " - ",
    max(prev_measyears$PREV_MEASYEAR)
  ))

  tree_ingrown_three <- tree_ingrown_three |>
    select(!starts_with("DIA_DELTA")) |>
    left_join(
      tree_growth_rate |>
        select(
          STATECD, COUNTYCD, PLOT, MEASYEAR, SPCD,
          PREV_MEASYEAR,
          DIA_DELTA, DIA_DELTA_ONE, DIA_DELTA_TWO
        ),
      by = join_by(STATECD, COUNTYCD, PLOT, PREV_MEASYEAR == MEASYEAR, SPCD)
    ) |>
    select(!"PREV_MEASYEAR") |>
    rename(PREV_MEASYEAR = PREV_MEASYEAR.y) |>
    # Update estimated diameters, but only if growth joined on
    mutate(
      FIRST_MEASYEAR = if_else(!is.na(DIA_DELTA), PREV_MEASYEAR, FIRST_MEASYEAR),
      FIRST_DIA_EST =
        if_else(!is.na(DIA_DELTA), FIRST_DIA_EST - DIA_DELTA, FIRST_DIA_EST),
      FIRST_DIA_EST_ONE =
        if_else(!is.na(DIA_DELTA), FIRST_DIA_EST_ONE - DIA_DELTA_ONE, FIRST_DIA_EST_ONE),
      FIRST_DIA_EST_TWO =
        if_else(!is.na(DIA_DELTA), FIRST_DIA_EST_TWO - DIA_DELTA_TWO, FIRST_DIA_EST_TWO)
    ) |>
    mutate(
      PREV_MEASYEAR = if_else(!is.na(DIA_DELTA) & FIRST_DIA_EST > 3, PREV_MEASYEAR, NA)
    )

  # This generally completes in 4 iterations; if we hit 10 something's wrong.
  if (iterations > 10) {
    print("Too many iterations")
    break
  }

  prev_measyears <- tree_ingrown_three |>
    filter(!is.na(PREV_MEASYEAR)) |>
    select(CN, PREV_MEASYEAR)
}

tree_ingrown_three |>
  group_by() |>
  summarize(
    COUNT = n(),
    MISSING = sum(is.na(FIRST_DIA_EST), na.rm = TRUE) / COUNT,
    MISSING_ONE = sum(is.na(FIRST_DIA_EST_ONE), na.rm = TRUE) / COUNT,
    MISSING_TWO = sum(is.na(FIRST_DIA_EST_TWO), na.rm = TRUE) / COUNT,
    HIT = sum(FIRST_DIA_EST <= 3, na.rm = TRUE) / COUNT,
    HIT_ONE = sum(FIRST_DIA_EST_ONE <= 3, na.rm = TRUE) / COUNT,
    HIT_TWO = sum(FIRST_DIA_EST_TWO <= 3, na.rm = TRUE) / COUNT,
    .groups = 'keep'
  ) |>
  ungroup() |>
  pivot_longer(everything()) |>
  knitr::kable()
```

How'd we do?

```{r plot_tree_ingrown_three, eval = FALSE}
tree_ingrown_three_validation <- tree_ingrown_three |>
  select(CN, MEASYEAR, SPCD, # STATECD, COUNTYCD, PLOT, SUBP, TREE, MEASYEAR, SPCD,
         FIRST_MEASYEAR, FIRST_DIA_EST, FIRST_DIA_EST_ONE, FIRST_DIA_EST_TWO) |>
  filter(FIRST_MEASYEAR != MEASYEAR) |>
  #head(1000) |>
#  left_join(
#    tree_ingrown |> select(STATECD, COUNTYCD, PLOT, SUBP, TREE, MEASYEAR, DIA),
#    by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE, FIRST_MEASYEAR == MEASYEAR)
#  ) |>
  left_join(species_crosswalk, by = join_by(SPCD)) |>
  group_by(JENKINS_SPGRP_NAME) |>
  mutate(GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())) |>
  ungroup() |>
  select(CN, GROUP_NAME, FIRST_DIA_EST, FIRST_DIA_EST_ONE, FIRST_DIA_EST_TWO) |>
  rename(
#    `Measured` = DIA,
    `Estimated` = FIRST_DIA_EST,
    `Est - 1%` = FIRST_DIA_EST_ONE,
    `Est - 2.5%` = FIRST_DIA_EST_TWO
  ) |>
  melt(
    id.vars = c("CN", "GROUP_NAME"),
    variable.name = "Series",
    value.name = "Growth"
  ) |>
  filter(!is.na(Growth))
ggplot(
  tree_ingrown_three_validation,
  aes(Growth, fct_rev(fct_infreq(GROUP_NAME)), fill = `Series`)
) +
  geom_vline(xintercept = 3, linetype = "dashed") +
  geom_vline(xintercept = 5, linetype = "dotted") +
  geom_boxplot(outlier.size = 0.1) +
  scale_fill_discrete(breaks = rev(levels(tree_ingrown_three_validation$Series))) +
  theme_bw() +
  ggtitle("Smallest Projected Diameter in Simulation Window") +
  xlab(bquote("Diameter " ~(inch))) +
  ylab("Species Group")
```

So the majority of trees that establish are projected to be over 3" diameter
at all times within the simulation window.

We will need to use a different method of calculating ingrowth.

### Ingrowth Rate

Possible ways of doing ingrowth by rate:

* Ingrowth by Stem Rate
* Ingrowth by BAI

_Ingrowth by Stem Rate_

Compute a per-species, per-plot "trees-per-year" rate of ingrowth. Then, for each timestep, I can compute the number of trees that should ingrow during that timestep. They would be added as maximum size trees: 3" DBH.

Advantages:

- Tree-level simulation plays well with FVS
- In the long term, this will converge on a population of trees indistinguishable from the "inject specific trees" approach.

Disadvantages:

- At the start of simulation there may be a dip in stand-level biomass since pre-simulation trees ingrow at 5" DBH, and once the simulation starts they ingrow at 3" DBH. Essentially, all the trees between 3" and 5" DBH at the start of the simulation are "forgotten", unless we do something to try to make up for that. But see below for the caveat re: crowding.

_Ingrowth by BAI_

Compute a per-species, per-plot "basal area per year" rate of ingrowth. Then, for each timestep, I can compute the number of 3" DBH trees that should ingrow during that timestep to provide the target BA.

BAI - Basal Area Increment - m^2 x ha^-1 x yr^-1

Advantages:

- No dip in biomass at the start of simulation, since we're adding the right amount of biomass.

Disadvantages:

- Adds more trees. FVS is pretty assertive about killing trees due to crowding, so this is likely to result in more trees dying than would be observed on the plot. This could result in net lower biomass in the long term, especially since FVS will kill larger trees as well as smaller trees.

#### Stem Ingrowth Rate

We want:

* stems
* of each species
* per acre
* per year (or does this vary over time?)
* on each plot

Complications:

* Some saplings have unidentified species, flagged as SPECIES == "spp."
  In theory we could walk forward in time for some of these trees and
  find a later record for the tree that identifies the specific species.
  This will not work for trees that ingrow in the latest inventory.
  For now, we impute the most common non-spp. species of the genus on the plot.

* Some species that ingrow are not supported by FVSne.
  When finding the most common species on a plot, restrict to those
  species supported by FVSne.
  
* Some genuses (Amelanchier, Crataegus, Malus) are handled only at the genus
  level by FVSne. There are many more that have both genus and species level
  handling. For things that are handled at the genus level, we have the option
  of invoking that.

We find the most common thing that is both inventoried on the plot AND
supported by FVSne, and move things that are not supported into the most
common.

```{targets nrs_trees_spcd, tar_simple = TRUE}
# mcs == Most Common Species
mcs_plot <- nrs_trees_growth |>
  left_join(species_crosswalk, by = join_by(SPCD)) |>
  filter(!is.na(FVS_SPCD)) |>
  group_by(STATECD, COUNTYCD, PLOT, GENUS, SPCD) |>
  summarize(COUNT = n(), .groups = "keep") |>
  ungroup() |>
  group_by(STATECD, COUNTYCD, PLOT, GENUS) |>
  filter(COUNT == max(COUNT)) |>
  filter(SPCD == min(SPCD)) |> # break ties by SPCD
  ungroup() |>
  select(!COUNT) |>
  rename(SPCD_PLOT = SPCD)

mcs_county <- nrs_trees_growth |>
  left_join(species_crosswalk, by = join_by(SPCD)) |>
  filter(!is.na(FVS_SPCD)) |>
  group_by(STATECD, COUNTYCD, GENUS, SPCD) |>
  summarize(COUNT = n(), .groups = "keep") |>
  ungroup() |>
  group_by(STATECD, COUNTYCD, GENUS) |>
  filter(COUNT == max(COUNT)) |>
  filter(SPCD == min(SPCD)) |> # break ties by SPCD
  ungroup() |>
  select(!COUNT) |>
  rename(SPCD_COUNTY = SPCD)

mcs_state <- nrs_trees_growth |>
  left_join(species_crosswalk, by = join_by(SPCD)) |>
  filter(!is.na(FVS_SPCD)) |>
  group_by(STATECD, GENUS, SPCD) |>
  summarize(COUNT = n(), .groups = "keep") |>
  ungroup() |>
  group_by(STATECD, GENUS) |>
  filter(COUNT == max(COUNT)) |>
  filter(SPCD == min(SPCD)) |> # break ties by SPCD
  ungroup() |>
  select(!COUNT) |>
  rename(SPCD_STATE = SPCD)

mcs_overall <- nrs_trees_growth |>
  left_join(species_crosswalk, by = join_by(SPCD)) |>
  filter(!is.na(FVS_SPCD)) |>
  group_by(GENUS, SPCD) |>
  summarize(COUNT = n(), .groups = "keep") |>
  ungroup() |>
  group_by(GENUS) |>
  filter(COUNT == max(COUNT)) |>
  filter(SPCD == min(SPCD)) |> # break ties by SPCD
  ungroup() |>
  select(!COUNT) |>
  rename(SPCD_OVERALL = SPCD)

# Note that this leaves Crataegus (Hawthorn) as spp. - apparently FIA has
# passed on trying to identify species in Crataegus.
nrs_trees_growth |>
  left_join(species_crosswalk |> select(SPCD, GENUS), by = join_by(SPCD)) |>
  left_join(mcs_plot, by = join_by(STATECD, COUNTYCD, PLOT, GENUS)) |>
  left_join(mcs_county, by = join_by(STATECD, COUNTYCD, GENUS)) |>
  left_join(mcs_state, by = join_by(STATECD, GENUS)) |>
  left_join(mcs_overall, by = join_by(GENUS)) |>
  rename(SPCD_ORIG = SPCD) |>
  mutate(SPCD = coalesce(SPCD_PLOT, SPCD_COUNTY, SPCD_STATE, SPCD_OVERALL, SPCD_ORIG)) |>
  select(SPCD | !any_of(names(species_crosswalk))) |>
  left_join(species_crosswalk, by = join_by(SPCD))
```

How'd we do?

```{r check fix to spcd, eval = FALSE}
rbind(
  nrs_trees_growth |>
    left_join(species_crosswalk, by = join_by(SPCD)) |>
    filter(is.na(FVS_SPCD)) |>
    group_by(GENUS) |>
    summarize(TREE_COUNT = n()) |>
    ungroup() |>
    mutate(SERIES = "Uncorrected"),
  nrs_trees_spcd |>
    filter(is.na(FVS_SPCD)) |>
    group_by(GENUS) |>
    summarize(TREE_COUNT = n()) |>
    ungroup() |>
    mutate(SERIES = "Corrected")
) |>
  group_by(SERIES) |>
  summarise(SPECIES_COUNT = n(), TREE_COUNT = sum(TREE_COUNT))
```

Uncorrected, there were almost 4,000 unhandled trees in 33 species (many of
which were just not identified at the species level); corrected, we're down
to about 1500 unhandled trees in 13 species (or things that are only identified
at the genus level).

These are the cases where we're unable to find a species code for FVSne:
```{r fvsne_unhandled_trees, eval = FALSE}
plot_count_mixin <- nrs_trees_spcd |>
  filter(is.na(FVS_SPCD)) |>
  distinct(STATECD, COUNTYCD, PLOT, SPCD) |>
  group_by(SPCD) |>
  summarize(PLOT_COUNT = n()) |>
  ungroup()

fvsne_unhandled_trees <- nrs_trees_spcd |>
  # Filter to the most recent record for each tree
  group_by(STATECD, COUNTYCD, PLOT, SUBP, TREE) |>
  arrange(desc(MEASYEAR)) |>
  filter(row_number() == 1) |>
  ungroup() |>
  mutate(BA = conv_multiunit(6 * pi * DIA ^ 2, "ft2 / acre", "m2 / hectare")) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  mutate(TOTAL_STAND_BA = sum(BA, na.rm = TRUE)) |>
  ungroup() |>
  filter(is.na(FVS_SPCD)) |>
  mutate(BA_FRAC = BA / TOTAL_STAND_BA) |>
  group_by(STATECD, COUNTYCD, PLOT, SPCD) |>
  summarize(
    BA = sum(BA, na.rm = TRUE),
    TOTAL_STAND_BA = max(TOTAL_STAND_BA, na.rm = TRUE),
    BA_FRAC = sum(BA_FRAC, na.rm = TRUE),
    .groups = 'keep'
  ) |>
  ungroup() |>
#  group_by(SPCD) |>
#  summarize(
#    TREE_COUNT = n(),
#    BA_FRAC = max(BA_FRAC, na.rm = TRUE)
#  ) |>
#  ungroup() |>
  filter(BA_FRAC > 0) |>
  left_join(plot_count_mixin, by = join_by(SPCD)) |>
  left_join(species_crosswalk, by = join_by(SPCD)) |>
  mutate(SCIENTIFIC_NAME = factor(SCIENTIFIC_NAME)) |>
  select(SCIENTIFIC_NAME, BA, BA_FRAC, TOTAL_STAND_BA)
```


> TODO nik: the following is by tree; should be by species+plot, so aggregate
>           all trees of the same species on a plot. Numbers should look about
>           the same.

```{r plot fvsne_unhandled_trees, eval = FALSE}
fvsne_unhandled_trees |>
  group_by(SCIENTIFIC_NAME) |>
  mutate(
    Species = paste0(SCIENTIFIC_NAME, ", n=", n()),
    NUM_PLOTS = n()
  ) |>
  ungroup() |>
  ggplot(aes(y = BA_FRAC, fill = reorder(Species, desc(NUM_PLOTS)))) +
  geom_boxplot() +
  scale_x_continuous(breaks = NULL) +
  scale_y_log10() +
  scale_fill_discrete(name = "Species") +
  theme_bw() +
  ggtitle("Fraction of plot BA in species not handled by FVSne") +
  xlab("Species") +
  ylab("Fraction of plot BA")
  
  
```

Let's find out how many stems of each (corrected) species ingrow per year.

```{targets nrs_estab_rate, tar_simple = TRUE}
time_mixin <- nrs_plots_stats |>
  distinct(STATECD, COUNTYCD, PLOT, MEASYEAR) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    FIRST_YEAR = min(MEASYEAR),
    LAST_YEAR = max(MEASYEAR),
    .groups = "keep"
  ) |>
  ungroup()

nrs_trees_spcd |>
  semi_join(nrs_trees_ingrowth, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR)) |>
  left_join(time_mixin, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  group_by(STATECD, COUNTYCD, PLOT, SPCD, FIRST_YEAR, LAST_YEAR) |>
  summarize(
    COUNT = n(),
    # Don't use TPA_UNADJ; microplot multipliers are inaccurate here.
    # Reason: once a tree reaches 5" DBH, its peers on the rest of the subplot
    # are inventoried in the TREE table, so multiplying by the microplot
    # multiplier would replicate microplot trees across the subplots AND
    # count the trees on subplots, which is double-counting, which is wrong.
    COUNT_PER_ACRE = COUNT * 6,
    .groups = "keep"
  ) |>
  ungroup() |>
  left_join(species_crosswalk, by = join_by(SPCD)) |>
  group_by(JENKINS_SPGRPCD) |>
  mutate(
    NUM_PLOTS = n(),
    GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", NUM_PLOTS)
  ) |>
  ungroup() |>
  mutate(
    COUNT_PER_HECTARE = conv_unit(COUNT_PER_ACRE, "hectare", "acre"),
    RATE = COUNT / (LAST_YEAR - FIRST_YEAR),
    RATE_PER_ACRE = COUNT_PER_ACRE / (LAST_YEAR - FIRST_YEAR),
    RATE_PER_HECTARE = COUNT_PER_HECTARE / (LAST_YEAR - FIRST_YEAR)
  )
```

```{r plot-nrs_estab_rate, eval = FALSE}
stand_stats_mixin <- nrs_plots_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  arrange(MEASYEAR) |>
  filter(row_number() == 1) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, STDAGE, BALIVE_METRIC, QMD)

nrs_estab_rate |>
  left_join(stand_stats_mixin, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  ggplot(aes(x = QMD, y = RATE_PER_HECTARE)) +
  geom_bin2d(bins = 50) +
  scale_fill_continuous(name = "Number of Plots", transform = "log10", limits = c(1, 1000)) +
  #facet_wrap(~GROUP_NAME) +
  theme_bw() +
  #xlab(bquote("Basal Area" ~(m^2 %.% ha^-1))) +
  xlab(bquote("QMD (cm)")) +
  ylab(bquote("Ingrowth Rate" ~(stems %.% ha^-1 %.% yr^-1))) +
  ggtitle("Per-Plot Ingrowth Stem Rate")
```

By species group:
```{r plot nrs_estab_rate by sp grp, eval = FALSE}
nrs_estab_rate |>
  left_join(stand_stats_mixin, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  ggplot(aes(x = QMD, y = RATE_PER_HECTARE)) +
  geom_bin2d(bins = 50) +
  scale_fill_continuous(name = "Number of Plots", transform = "log10", limits = c(1, 1000)) +
  facet_wrap(~GROUP_NAME) +
  theme_bw() +
  #xlab(bquote("Basal Area" ~(m^2 %.% ha^-1))) +
  xlab(bquote("QMD (cm)")) +
  ylab(bquote("Ingrowth Rate" ~(stems %.% ha^-1 %.% yr^-1))) +
  ggtitle("Per-Plot Ingrowth Stem Rate")

```

Ok, who are these outliers?
```{r stem rate outliers, eval = FALSE}
knitr::kable(
  nrs_estab_rate |>
  arrange(desc(RATE)) |>
  head(10) |>
  left_join(stand_stats_mixin, by = join_by(STATECD, COUNTYCD, PLOT)) 
)
```

Looking, for example, at ALSTKCD we find that these plots are fully stocked
or overstocked, indicating that they have large cohorts of young trees all
coming of age at the same time, so maybe these are Christmas tree farms or
similar.


```{r stem rate summary, eval = FALSE}
summary(nrs_estab_rate)
```

Looks good, but what we actually needed was height, not diameter.

#### Ingrowth Height

For FVS ingrowth, we need height when the tree is 3" DBH. FVS will 
adjust this, so it only needs to be close.

We pick from 3 to 9 trees closest to 3" DBH, do a linear interpolation of their
height to what it might be at 3" DBH, and average them.

We do not look at trees below 2.5" DBH, because growth allocation to HT vs DIA
is very different for small vs. medium trees. Limiting to 2.5" gives us a
reasonable chance of finding suitable trees on the microplot (min 1"), while
limiting how often we fall back to using trees in the ecosubregion, and
limiting the error introduced by sampling across growth regimes.

We do not look at trees above 6" DBH, because growth allocation to HT vs DIA
is very different for medium vs. large trees. Limiting to 6" gives us a
reasonable chance of finding suitable trees on the plot (min 5"), while
limiting how often we fall back to using trees in the ecosubregion, and
limiting the error introduced by sampling across growth regimes.

- HT_PLOT - per-species height at 3" DBH modeled only from trees on the plot
- HT_ECOSUBCD - per-species height at 3" DBH modeled from trees in the ecosubregion
- HT_ECOCD - per-species height at 3" DBH modeled from trees in the ecoregion
- HT_NE - per-species height at 3" DBH for the entire northeast
- HT_MIN - same as HT_NE, but populated even if fewer than 3 trees can be found

```{targets nrs_estab_height, tar_simple = TRUE}
min_tree_count <- 3
max_tree_count <- 9

ecosubcd_mixin <- nrs_plots_grown |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  arrange(MEASYEAR) |>
  filter(row_number() == 1) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, ECOSUBCD) |>
  mutate(ECOCD = substr(ECOSUBCD, 1, nchar(ECOSUBCD) - 1))

trees_for_ht_estimation <- nrs_trees_spcd |>
  filter(2.5 < DIA & DIA < 6) |>
  group_by(STATECD, COUNTYCD, PLOT, SUBP, TREE) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() == 1) |>
  ungroup() |>
  # Overcome a data issue: some trees have no HT, but have PREV_HT
  mutate(HT = coalesce(HT, PREV_HT), DIA = coalesce(DIA, PREV_DIA)) |>
  filter(!is.na(HT) & !is.na(DIA)) |>
  left_join(ecosubcd_mixin, by = join_by(STATECD, COUNTYCD, PLOT))

nrs_estab_height_plot <- trees_for_ht_estimation |>
  group_by(STATECD, COUNTYCD, PLOT, SPCD) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() <= max_tree_count) |>
  mutate(HT_PLOT = HT * 3 / DIA) |>
  filter(n() >= min_tree_count) |>
  summarize(HT_PLOT = mean(HT_PLOT), .groups = "keep") |>
  ungroup()

nrs_estab_height_ecosubcd <- trees_for_ht_estimation |>
  group_by(ECOSUBCD, SPCD) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() <= max_tree_count) |>
  mutate(HT_ECOSUBCD = HT * 3 / DIA) |>
  filter(n() >= min_tree_count) |>
  summarize(HT_ECOSUBCD = mean(HT_ECOSUBCD), .groups = "keep") |>
  ungroup()

nrs_estab_height_ecocd <- trees_for_ht_estimation |>
  group_by(ECOCD, SPCD) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() <= max_tree_count) |>
  mutate(HT_ECOCD = HT * 3 / DIA) |>
  filter(n() >= min_tree_count) |>
  summarize(HT_ECOCD = mean(HT_ECOCD), .groups = "keep") |>
  ungroup()

nrs_estab_height_ne <- trees_for_ht_estimation |>
  group_by(SPCD) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() <= max_tree_count) |>
  mutate(HT_NE = HT * 3 / DIA) |>
  filter(n() >= min_tree_count) |>
  summarize(HT_NE = mean(HT_NE), .groups = "keep") |>
  ungroup()

# height_min ignores the minimum number of trees,
# and will produce values even for a single tree
# anywhere in the region. It is a last-ditch catch-all.
nrs_estab_height_min <- trees_for_ht_estimation |>
  group_by(SPCD) |>
  arrange(abs(DIA - 3)) |> # closest to 3" first
  filter(row_number() <= max_tree_count) |> 
  mutate(HT_MIN = HT * 3 / DIA) |>
  summarize(HT_MIN = mean(HT_MIN)) |>
  ungroup()

nrs_trees_spcd |> # unfiltered tree growth
  semi_join(nrs_trees_ingrowth, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE)) |>
  distinct(STATECD, COUNTYCD, PLOT, SPCD) |>
  left_join(ecosubcd_mixin, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  left_join(nrs_estab_height_plot, by = join_by(STATECD, COUNTYCD, PLOT, SPCD)) |>
  left_join(nrs_estab_height_ecosubcd, by = join_by(ECOSUBCD, SPCD)) |>
  left_join(nrs_estab_height_ecocd, by = join_by(ECOCD, SPCD)) |>
  left_join(nrs_estab_height_ne, by = join_by(SPCD)) |>
  left_join(nrs_estab_height_min, by = join_by(SPCD)) |>
  mutate(HT = coalesce(HT_PLOT, HT_ECOSUBCD, HT_ECOCD, HT_NE, HT_MIN))
```

How specific are our heights?

```{r plot nrs_estab_height origin, eval = FALSE}
nrs_estab_height |>
  mutate(
    HT_ORIGIN = case_when(
      !is.na(HT_PLOT) ~ "Plot",
      !is.na(HT_ECOSUBCD) ~ "EcoSubRegion",
      !is.na(HT_ECOCD) ~ "EcoRegion",
      !is.na(HT_NE) ~ "Region",
      .default = "All"
    ),
    HT_ORIGIN = ordered(HT_ORIGIN, levels = c("Plot", "EcoSubRegion", "EcoRegion", "Region", "All"))
  ) |>
  left_join(species_crosswalk, by = join_by(SPCD)) |>
  group_by(JENKINS_SPGRP_NAME) |>
  mutate(N = n()) |>
  ungroup() |>
  ggplot(aes(x = reorder(JENKINS_SPGRP_NAME, desc(N)), fill = HT_ORIGIN)) +
  geom_bar(width = 1) + 
  ylab(NULL) +
  xlab(NULL) +
#  scale_x_discrete(labels = NULL) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = -15, hjust = 0, vjust = 1)) +
  scale_fill_brewer(name = "Origin", palette = "Set1") +
  ggtitle("Origin of Height estimates")
```


What diameters of trees are we selecting?

```{r ht dia selection limited dia, eval = FALSE}
ht_ecosubcd_mixin <- trees_for_ht_estimation |>
  group_by(ECOSUBCD, SPCD) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() <= 9) |>
  mutate(HT_ECOSUBCD = HT * 3 / DIA) |>
  filter(n() >= 3) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, SUBP, TREE, HT_ECOSUBCD)

ht_plot_mixin <- trees_for_ht_estimation |>
  group_by(STATECD, COUNTYCD, PLOT, SPCD) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() <= 9) |>
  mutate(HT_PLOT = HT * 3 / DIA) |>
  filter(n() >= 3) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, SUBP, TREE, HT_PLOT)

ht_ecocd_mixin <- trees_for_ht_estimation |>
  group_by(ECOCD, SPCD) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() <= 9) |>
  mutate(HT_ECOCD = HT * 3 / DIA) |>
  filter(n() >= 3) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, SUBP, TREE, HT_ECOCD)

ht_ne_mixin <- trees_for_ht_estimation |>
  group_by(SPCD) |>
  arrange(abs(DIA - 3)) |>
  filter(row_number() <= 9) |>
  mutate(HT_NE = HT * 3 / DIA) |>
  filter(n() >= 3) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, SUBP, TREE, HT_NE)

ht_min_mixin <- trees_for_ht_estimation |>
  group_by(SPCD) |>
  arrange(abs(DIA - 3)) |> # closest to 3" first
  filter(row_number() <= 9) |> 
  mutate(HT_MIN = HT * 3 / DIA) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, SUBP, TREE, HT_MIN)

nrs_estab_height_whence <- trees_for_ht_estimation |>
  select(STATECD, COUNTYCD, PLOT, SUBP, TREE, SPCD, DIA) |>
  left_join(ht_plot_mixin, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE)) |>
  left_join(ht_ecosubcd_mixin, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE)) |>
  left_join(ht_ecocd_mixin, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE)) |>
  left_join(ht_ne_mixin, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE)) |>
  left_join(ht_min_mixin, by = join_by(STATECD, COUNTYCD, PLOT, SUBP, TREE)) |>
  mutate(HT = coalesce(HT_PLOT, HT_ECOSUBCD, HT_ECOCD, HT_NE, HT_MIN)) |>
  filter(!is.na(HT)) |>
  left_join(species_crosswalk, by = join_by(SPCD))
```

```{r plot ht dia distribution, eval = FALSE}
nrs_estab_height_whence |>
  ggplot(aes(y = DIA, fill = JENKINS_SPGRP_NAME)) +
  geom_boxplot(outlier.size = 0.1) +
  scale_fill_discrete(
    name = "Species Group"
  ) +
  scale_x_continuous(labels = NULL) +
  theme_bw() +
  ylab("Measured Diameter (inches)") +
  ggtitle("Diameter of trees selected for estimation")
```

```{r plot estab ht vs dia, eval = FALSE}
bins = (max(nrs_estab_height_whence$DIA) - min(nrs_estab_height_whence$DIA)) * 10
nrs_estab_height_whence |>
  ggplot(aes(x = DIA, y = HT)) +
  geom_bin_2d(bins = bins) +
  geom_vline(xintercept = 3, color = "red", linetype = "dashed") +
  scale_fill_continuous(name = "Number of Trees", transform = "log10") +
  facet_wrap(~JENKINS_SPGRP_NAME) +
  #scale_color_discrete(
  #  name = "Species Group"
  #) +
  theme_bw() +
  xlab("Measured Diameter (inches)") +
  ylab("Estimated Height at 3\" DBH (feet)") +
  ggtitle("Estimated Height vs. Diameter of trees selected for estimation")
```

Are we missing height for any ingrowth?
```{r validate height projection, eval = FALSE}
stopifnot(
  nrs_estab_rate |>
    distinct(STATECD, COUNTYCD, PLOT, SPCD) |> 
    left_join(nrs_estab_height, by = join_by(STATECD, COUNTYCD, PLOT, SPCD)) |>
    # Remove the one shellbark hickory tree that doesn't get a height
    filter(SPCD != 405) |>
    filter(is.na(HT)) |>
    nrow() == 0
)
```

### Ingrowth Model

Combining these, we can gather per-plot the nuber of stems of each species
that establish each year, and the height at establishment.

```{r ingrowth_by_stem, eval = FALSE}
ingrowth_by_stem <- nrs_estab_rate |>
  left_join(nrs_estab_height, by = join_by(STATECD, COUNTYCD, PLOT, SPCD))

ingrowth_by_stem |>
  group_by(JENKINS_SPGRPCD) |>
  mutate(
    PLOT_COUNT = n(),
    GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())
  ) |>
  ungroup() |>
  filter(!is.na(RATE_PER_ACRE)) |> # remove that pesky shellbark hickory tree
  ggplot(aes(
    fct_rev(reorder(GROUP_NAME, PLOT_COUNT)),
    RATE_PER_ACRE,
    fill = fct_rev(reorder(GROUP_NAME, PLOT_COUNT))
  )) +
  geom_boxplot(outlier.size = 0.1) +
  scale_x_discrete(labels = NULL) +
  theme_bw() +
  xlab("Species Group") +
  ylab(bquote("Ingrowth Rate " ~ (`stems` %.% acre^-1 %.% year^-1))) +
  scale_fill_discrete(name = "Species Group") +
  ggtitle("Observed Ingrowth Rate")
```

```{r ingrowth_by_stem, eval = FALSE}
ingrowth_by_stem <- nrs_estab_rate |>
  left_join(nrs_estab_height, by = join_by(STATECD, COUNTYCD, PLOT, SPCD))

ingrowth_by_stem |>
  group_by(JENKINS_SPGRPCD) |>
  mutate(
    PLOT_COUNT = n(),
    GROUP_NAME = paste0(JENKINS_SPGRP_NAME, ", n=", n())
  ) |>
  ungroup() |>
  filter(!is.na(HT)) |> # remove that pesky shellbark hickory tree
  ggplot(aes(
    fct_rev(reorder(GROUP_NAME, PLOT_COUNT)),
    HT,
    fill = fct_rev(reorder(GROUP_NAME, PLOT_COUNT))
  )) +
  geom_boxplot(outlier.size = 0.1) +
  scale_x_discrete(labels = NULL) +
  scale_y_continuous(limits = c(0, NA)) +
  theme_bw() +
  xlab("Species Group") +
  ylab("Height at 3\" DBH (feet)") +
  scale_fill_discrete(name = "Species Group") +
  ggtitle("Estimated Tree Height at 3\" DBH")
```

```{r summary ingrowth_by_stem, eval = FALSE}
summary(ingrowth_by_stem)
```

# Run FVS

> TODO nik: use Stand replication for random seeds.

We run FVS on the same stands in many different ways. The FVS UI
has a method of replicating stands so that the same stand can be
run in different ways in the same run. To do this, it creates a copy
of the keyword file section, adding the replica number to the stand
identifier using "_N" format. So, for example, replica 2 of stand
"230202502686" becomes "230202502686_2"

## Generate Keyfile

An FVS run is scripted by a keyfile. The keyfile describes how to run the
model and extensions, including where to read input, all parameters to
control processing, and where to write output.

The keyfile is structured by stand; each stand is a separate run of the
model.

To run in parallel, a separate keyfile must be generated for each partition
to be run in parallel. Each partition must send its output to a separate
location, and these can be assembled into a single output as a post-
processing step.

### Stand Identification

For each stand, we need:

-  StdIdent: Stand Identifier, from fia.FVS_STANDINIT_PLOT.FVS_STAND_ID
-  StandCN: Stand control number, from fia.PLOT.CN
-  MgmtId: Management ID, for no treatment, this is NONE

### Time

We will run the model from first measurement year to last measurement year,
with as many 10-year timesteps as we can get. We will add an initial timestep
that is less than 10 years to get to a 10 year boundary. We choose a 10-year
timestep because FVSne is calibrated to 10 years, and running with a different
length timestep introduces bias. The bias is less with shorter timesteps than
with longer timesteps, so using a short timestep to adjust length introduces
less bias than using a long timestep.

There are two years of interest for each plot: FIRSTYEAR, which is
the minimum fia.PLOT.MEASYEAR for the modern plot design; and
LASTYEAR, which is the maximum of the same.

-  InvYear: Inventory Year, set to FIRSTYEAR
-  TimeInt: Time Interval, there may be two entries:
   -  TimeInt 0: Default time interval, 10 years
   -  TimeInt 1: First cycle time interval, (LASTYEAR - FIRSTYEAR) %% 10
-  NumCycle: Number of cycles to run, int((LASTYEAR - FIRSTYEAR) / 10) + 1,
   and +1 again if there is a TimeInt 1.

Note that the number of cycles is the number of full 10-year cycles
plus one if there is a short first cycle. Since metrics are printed at the start
of each cycle, we need LASTYEAR to be the first year of a cycle, and work
backwards from that.

### FIA Inputs

There are two inputs, Stand and Tree. Both are configured to use a database
query.

Within a Database subsection:

-  DSNIn: Data Source Name (DSN) for input; SQLite filename
-  StandSQL: SQL query to fetch a stand, given %Stand_CN%
-  TreeSQL: SQL query to fetch all trees for a stand, given %Stand_CN%

### Regeneration, Ingrowth, and Establishment

The Northeastern variant is a partial establishment model, so it does not
automatically perform natural regeneration. We will therefore use modeled
ingrowth from the FIA data.

Example from estab model docs:
```
IF
(FRAC(CYCLE/2) EQ 0 AND CYCLE GT 3)
THEN
ESTAB
NATURAL 0.0 10.0 50.0
NATURAL 0.0 3.0 20.0
MERCHPREP 0.0 0.0
TALLYONE 9.0
END
ENDIF
```

> This
> Event Monitor file will add the 70 trees per acre every 20 years after
> cycle 3. Cycle lengths are assumed to be 10 years. A MECHPREP or
> BURNPREP keyword record specifying 0.0 percent site preparation is
> needed to keep all plots untreated.

Under the NATURAL keyword:

> Heights are bounded
> between the minimum establishment height
> listed in table 1 and the height of a tree
> 3 inches d.b.h. Heights are assigned at the
> end of the cycle unless the cycle length is
> longer than 5 years. In this case, tree heights
> are assigned at 6 years, then a height incre-
> ment is predicted for years 6 through the end
> of the cycle. See figure 6 for an example of
> assigning heights.

Figure 6:
```
STDIDENT
EXAMPLE2 USING THE “NATURAL” KEYWORD
DESIGN 10.0 0.0
STDINFO 104.0 260.0 0.0 315.0 30.0 45.0
INVYEAR 2000.0
TIMEINT 1.0 5.0
TIMEINT 2.0 5.0
NUMCYCLE 10.0
NOTREES
ESTAAB 2000.0
NATURAL 2009.0 3.0 250.0 . . 5.5
NATURAL 2009.0 7.0 75.0  . . 8.0
NATURAL 2009.0 10.0 120.0 . . 6.0
END
PROCESS
STOP
```

In this example, STOCKADJ is ignored / not needed - STOCKADJ only affects
built-in regeneration. TALLYONE 9.0 ensures that all NATURAL trees are
promoted prior to the end of the cycle. From the example output, a TALLYTWO
is automatically scheduled, presumably in response to the TALLYONE.

NB: The structure of the NATURAL keyword is:
> NATURAL 1:YEAR 2:SPECIES 3:TPA 4:SURVIVAL 5:AGE 6:HEIGHT 7:SHADE_CODE

So, I think we need:

- IF ... (every cycle)
- THEN
- ESTAB
- NATURAL 0 SPECIES TPA [no survival] [no age] HEIGHT [no shade]
- MERCHPREP 0
- BURNPREP 0
- TALLYONE 9
- END
- ENDIF

...which will insert TPA trees of SPECIES at HEIGHT at year 6 of the cycle,
and establish them at year 9.

### Fire and Fuels

Carbon is calculated by the fire and fuels extension.

-  FMIn: Starts configuration of Fire and Fuels extension
-  CarbRept: Carbon Report; save to database (2)
-  CarbCut: Harvested Carbon Report; disable (0)
-  CarbCalc: Carbon calculation; metric (1)
-  FuelOut: Fuel Output, disable (0)
-  FuelRept: Fuel Report, disable (0)

Fire and Fuels also interacts with the database extension; it provides additional
Database keywords to configure Fire and Fuels output to the database.

Within a Database section:

-  CarbReDB: FVS_Carbon and FVS_Hrv_Carbon tables: database (2)
-  FuelReDB: FVS_Consumption table: database (2)
-  FuelsOut: FVS_Fuels table: database (2)


### Translating to FVS

For each timestep, we will find the trees that establish during that timestep,
and add a record describing the tree at the time of establishment.

Note that FIA establishes at 5" DBH, whereas FVS establishes at 3" DBH,
and FVS puts an upper bound on height based on expectations for 3" DBH trees.
We can follow PREV_TRE_CN backward to find when the tree was 3" DBH; note
that this might be a long time ago. As an alternative, we could multiply TPA
by DIA^2 / 3^2 and set the height to (3/DIA)*HT - this would give us the same
total basal area in trees of reduced height.

Because of the way time is set up in FVS, establishment is scheduled for the
year prior to the start of a cycle. Within the cycle, each tree that is
established gets its own Natural keyword. This specifies:

-  Year: The (actual) year in which the tree is marked as INGROWTH
-  Species: The 2-character FVS species code
-  TPA: Trees per acre; prefer the TPA from the tree record over TPAGROW_UNADJ
   from the establishment record (the two should be the same)
-  Survivorship: Always 100%
-  Age: average age at the year of establishment. Leave this blank.
-  Height: Average height.  Use fia.TREE.HT, but see above note.
-  Shade: 0 = uniform, 1 = prefer shade; 2 = prefer sun. Use 0.

FVS is semi-spatial; it is aware of subplots and microplots, and how many
trees are on each. There does not appear to be a way to designate which
subplot a tree establishes on; presumably, the TPA is distributed across
subplots.

### Output

We use database output; it is easiest to work with. Many output options take
a parameter that is 0 to disable output, 1 for file output, 2 for database
output, and 3 for both file and database output.

Within a Database section:

-  DSNOut: Data Source Name (DSN) for output; SQLite filename
-  Summary: Configure FVS_Summary; use version 2
-  Computdb: Configure FVS_Compute; disable
-  MisRpts: Configure Mistletoe reports; disable

### Processing Order

Each stand has its own section of the keyword file, including everything from
StdIdent to Process. Each stand is processed before moving to the next stand.

At the end of all stands, the Stop keyword tells FVS to exit cleanly.

### Example

```
StdIdent
230202502686        NoManagement
StandCN
52967848010538
MgmtId
NONE
InvYear         2002
TimeInt            0        10
TimeInt            1         2
NumCycle           3

FMIn
CarbRept           2
CarbCut            2
CarbCalc           0         1    0.0425         9        11
FuelOut            2
FuelRept           2
End

Database

DSNIn
SQLite_FIADB_ENTIRE.db

StandSQL
SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL

TreeSQL
SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL

DSNOut
FVS_NoManagement_NONE.db

Summary            2
Computdb           0         1
MisRpts            2
CarbReDB           2
FuelReDB           2
FuelsOut           2

END

Process

Stop
```

### Keword File Generation

Gather stand IDs and CNs for keywordfile generation.

We gather two series of stands:

-  stands_projected is a list of stands and inventory years to grow out to 2025
-  stands_surveyed is a list of stands and inventory years to grow for 0 years
   in each survey year.


Find the stands we want to project; these are the grow-only stands starting
in their first measurement year.

When generating keyword files, we create one per partition,
distributing across partitions using round-robin on STAND_ID.

```{targets nrs_plots_grow_partitions, tar_simple = TRUE}
# This is a list of partitons; we can come up with it however we want.
# For now, one partition per worker is resonable.
partitions <- 8
```

Create a list of partitions; each replica will get one of these.
```{targets nrs_plots_grow_partition, tar_simple = TRUE}
1:nrs_plots_grow_partitions
```

> TODO nik: re-introduce partitions and random seeds
> An example _targets.R that runs each partition with each seed:
> list(
>  tar_target(partition, 1:9),
>  tar_target(seed, 1:3),
>  tar_target(data, 111:999),
>  tar_target(
>    process,
>    f(partition, seed, data),
>    iteration = "vector",
>    pattern = cross(seed, map(partition))
>  )
> )
> Note that f() needs to take partition and seed as parameters, and needs
> to append them as columns to its output dataframe.

Run with multiple random seeds. In theory, we chould have `tarchetypes::tar_rep()`
manage this for us, but tar_rep doesn't support repetition in combination with
dynamic branching (which we're using for partitioning). So we manage random
seeds explicitly.

```{targets nrs_plots_grow_randseed, tar_simple = TRUE}
# We can have as many seeds as we want. We'll convert these to valid FVS
# random seeds later.
# Start with 3, so it's reasonably fast but we get some benefit from it.
# FVS requires positive, odd-numbered seeds, so multiply by 2 and subtract 1.
sample.int(500000, 3) * 2 - 1
```

keywordfile_section is a function to generate a keywordfile section from
information about a run and a stand.

It cooks a StdIdent that can be parsed later:

- The input StandID
- _Y followed by the number of years in a timestep
- _R followed by the random seed

The first set of keyword files is to project from the first measurement year to 2025.

```{targets nrs_growonly_none}
tar_target(
  nrs_growonly_none,
  {
    # fvs_run wants a table of the form:
    # STAND_ID - arbitrary identifier for a stand
    # STAND_CN - CN for the plot
    # FIRST_YEAR - start of the projection; if this doesn't align with the actual
    #   year (MEASYEAR) of first survey, the stand will be projected from the
    #   survey year to the start of the projection.
    # LAST_YEAR - end of the projection
    timestep <- 10 # years; determined by FVSne variant
    
    plots_for_fvs <- nrs_plots_grown |>
      group_by(STATECD, COUNTYCD, PLOT) |>
      arrange(INVYR) |>
      mutate(
        STAND_CN = if_else(row_number() == 1, CN, NA)
      ) |>
      summarize(
        STAND_CN = min(STAND_CN, na.rm = TRUE), # only one will not be NA
        FIRST_YEAR = min(MEASYEAR, na.rm = TRUE),
        LAST_YEAR = max(MEASYEAR, na.rm = TRUE),
        .groups = "keep"
      ) |>
      ungroup() |>
      mutate(
        # STAND_ID won't match FVS_PLOTINIT_PLOT.STAND_ID; that's OK
        STAND_ID = sprintf("%04d%03d%05d", STATECD, COUNTYCD, PLOT)
      )
    
    # fvs_run wants establishment in the form:
    # STAND_CN
    # SPECIES (FVS_SPCD)
    # DENSITY (TPA)
    # HEIGHT (FT)
    estab_for_fvs <- nrs_estab_rate |>
      mutate(
        STAND_ID = sprintf("%04d%03d%05d", STATECD, COUNTYCD, PLOT)
      ) |>
      left_join(
        plots_for_fvs |> select(STAND_ID, STAND_CN),
        by = join_by(STAND_ID)
      ) |>
      select(STAND_CN, STATECD, COUNTYCD, PLOT, SPCD, RATE_PER_ACRE) |>
      mutate(RATE_PER_ACRE = floor(RATE_PER_ACRE * timestep)) |>
      rename(DENSITY = RATE_PER_ACRE) |>
      left_join(
        nrs_estab_height |>
          select(STATECD, COUNTYCD, PLOT, SPCD, HT),
        by = join_by(STATECD, COUNTYCD, PLOT, SPCD)
      ) |>
      mutate(HT = floor(HT)) |>
      rename(HEIGHT = HT) |>
      left_join(
        species_crosswalk |>
          select(SPCD, FVS_SPCD),
        by = join_by(SPCD)
      ) |>
      rename(SPECIES = FVS_SPCD) |>
      filter(!is.na(SPECIES) & !is.na(DENSITY) & !is.na(HEIGHT)) |>
      select(STAND_CN, SPECIES, DENSITY, HEIGHT)
      
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "NRSGrowOnly"
    mgmt_id <- "NONE"
    
    # We communicate with FVS through files. FVSOnline shows a model in which
    # a "project" (the inputs and outputs of a single FVS run) live in a
    # single directory; we follow that model.
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = fiadb,
      title = title,
      mgmt_id = mgmt_id,
      stands = plots_for_fvs,
      regen = estab_for_fvs,
      num_partitions = nrs_plots_grow_partitions,
      partition = nrs_plots_grow_partition,
      random_seed = nrs_plots_grow_randseed
    )
  },
  # iteration = "vector" branches execution for each partition value (see below)
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here.
  # cross() ensures that every combination of values for its arguments is processed
  # map() distributes each value of its argument to a separate sub-target (branch)
  # so cross(randseed, map(partition)) will run each partition in a separate branch,
  # and each branch will run with each value of randseed
  pattern = cross(nrs_plots_grow_randseed, map(nrs_plots_grow_partition))
)
```

The second run is a zero-year projection to have FVS calculate the carbon
in surveyed stands in each year they are surveyed. These
are given management ID "SRVY". We also run only once, with no random seed,
since we're not actually growing anything.

```{targets nrs_growonly_srvy}
tar_target(
  nrs_growonly_srvy,
  {
    plots_for_fvs <- nrs_plots_grown |>
      rename(
        STAND_CN = CN,
        FIRST_YEAR = MEASYEAR
      ) |>
      mutate(
        LAST_YEAR = FIRST_YEAR,
        # STAND_ID matches STAND_ID for NRSGrowOnly GROW, but this isn't
        # actually necessary. We'll line things up later using CN.
        STAND_ID = sprintf("%04d%03d%05d", STATECD, COUNTYCD, PLOT)
      )
    
    # No establishment for survey runs
    
    # We're running 0-year timesteps, but FVS requires us to run at least one
    # year, so we run 0-year timesteps for 1 year.
    timestep <- 1
    
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "NRSGrowOnly"
    mgmt_id <- "SRVY"

    # We communicate with FVS through files. FVSOnline shows a model in which
    # a "project" (the inputs and outputs of a single FVS run) live in a
    # single directory; we follow that model.
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = fiadb,
      title = title,
      mgmt_id = mgmt_id,
      stands = plots_for_fvs,
      num_partitions = nrs_plots_grow_partitions,
      partition = nrs_plots_grow_partition
    )
  },
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here:
  pattern = map(nrs_plots_grow_partition)
)

```

# Results

## Fault Analysis

### Parse Problems

What errors and warnings do we get?
```{r fvs warnings, eval = FALSE}
mgmtid <- "GROW"
fvs_warnings <- NULL
for (partition in 1:num_partitions) {
  filename <- paste0("data/fvs/FVS_", title, "_", mgmtid, "_", partition, ".out")
  fvs_warnings <- bind_rows(
    fvs_warnings,
    read_lines(filename) |>
      as.data.frame(nm="text") |>
      # Filter to just initial STAND ID and WARNING lines
      filter(
        grepl("^ +STAND ID=", text) |
          grepl("WARNING:", text) |
          grepl("ERROR:", text)
      ) |>
      # Parse out the STAND ID and fill it into the following lines
      mutate(
        STAND_ID = case_when(
          grepl("^ +STAND ID=", text) ~ sub("^ +STAND ID= *([^ ]+) .*$", "\\1", text)
        )
      ) |>
      fill(STAND_ID) |>
      # Remove everything but warnings (which now have STAND_ID)
      filter(
        grepl("WARNING:", text) |
          grepl("ERROR:", text)
      )
  )
}
```

Find the distinct warnings
```{r distinct fvs warnings, eval = FALSE}
fvs_warnings_distinct <- fvs_warnings |>
  # Warnings have some leading text, the tag WARNING:,
  # then descriptive text; if there's a number in the descriptive text,
  # it's probably pulled from the data, so we chop off the descriptive
  # text starting at the first number to find the truly distinct warnings
  mutate(
    PROBLEM = case_when(
      grepl("WARNING:", text) ~ sub("^[*. ]*(.*WARNING: [^0-9]+)([0-9].*)?$", "\\1", text),
      grepl("ERROR:", text) ~ sub("^[*. ]*(.*ERROR: [^0-9]+)([0-9].*)?$", "\\1", text)
    ),
    PROBLEM = sub("\\s+$", "", PROBLEM)
  ) |>
  distinct(PROBLEM) |>
  arrange(PROBLEM)
knitr::kable(fvs_warnings_distinct)
```
### Keyword in Wrong Context

The keyword in wrong context could be a keyword file generation error; let's
track it down.
```{r keyword context, eval = FALSE}
debug_stand_id <- fvs_warnings |>
  filter(grepl(" WRONG CONTEXT ", text)) |>
  head(1) |>
  pull("STAND_ID")
fvs_warnings |>
  filter(STAND_ID == debug_stand_id)
```

RECORDS READ=4884 likely means the number of lines in the keyword file
(this is a FORTRAM program, where each line is a record).

Which partition is it in?
```{r keyword context partition, eval = FALSE}
as.numeric(sub("^([^_]+)_.*$", "\\1",debug_stand_id)) %% num_partitions
```

so the 26th partition, which is partition 27.

Here's the keyword file section:
```
StdIdent  
540003101366_Y1_R1 NRSGrowOnly
StandCN   
7554111010661
MgmtId    
GROW
InvYear         2000
TimeInt            0         1
TimeInt           19         1
NumCycle          19
RANNSEED           1
FMIn      
CarbRept  
CarbCut   
CarbCalc           1         1    0.0425         9        11
FuelOut   
FuelRept  
End       
Database  
DSNIn     
SQLite_FIADB_ENTIRE.db
StandSQL  
SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL    
TreeSQL   
SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL    
DSNOut    
FVS_NRSGrowOnly_GROW_27.db
Summary            2
Computdb           0         1
MisRpts            2
CarbReDB           2
FuelReDB           2
FuelsOut           2
End       
If                 0
mod(cycle,1) eq 0
Then      
Estab              0
MechPrep           0         0
BurnPrep           0         0
Sprout    
Natural            0        RM         6       100                  29         0
Natural            0        BG        42       100                  26         0
End       
EndIf     
Process   

```

Reading the full text of the output file gives more context:
```
********   FVS16 ERROR:  KEYWORD ENTERED IS USED IN WRONG CONTEXT AND WAS IGNORED.  RECORDS READ=4884
           DSNOUT DATA BASE CAN NOT BE REDEFINED. DSN FOR OUTPUT REMAINS: FVS_NRSGrowOnly_GROW_27.db
```

This appears after reporting the results of TreeSQL. So it looks like
there's an extra DSNOUT somewhere, but I don't see it.

This happens 6 times, only in partitions 27 and 29. All are for DSNOut, and
all report that the DSNOut is left as what I want it to be.

So we can ignore these errors.

### Keyword Ignored

Let's look at the KEYWORD IGNORED errors:
```{r keyword ignored, eval = FALSE}
debug_stand_id <- fvs_warnings |>
  filter(grepl(" KEYWORD IGNORED.", text)) |>
  head(1) |>
  pull("STAND_ID")
fvs_warnings |>
  filter(STAND_ID == debug_stand_id)
```

```{r keyword ignored partition, eval = FALSE}
as.numeric(sub("^([^_]+)_.*$", "\\1",debug_stand_id)) %% num_partitions
```

The relevant section of the output is:
```
STDIDENT
           STAND ID= 338300300218_Y1_R1                NRSGrowOnly                                                             

STANDCN    DATA BASE CONTROL NUMBER=22870841010661

MGMTID  
           MANAGEMENT ID= GROW

INVYEAR    INVENTORY YEAR= 1983

TIMEINT    ALL CYCLES;  PERIOD LENGTH=  1

 CARD NUM = 1957; KEYWORD FIELD = 'TIMEINT '
      PARAMETERS ARE:    41.0000000     1.0000000     0.0000000     0.0000000     0.0000000     0.0000000     0.0000000
      COL 11 TO 80 ='        41         1                                                  '

********   FVS04 ERROR:  A REQUIRED PARAMETER IS MISSING OR A PARAMETER IS INCORRECT; KEYWORD IGNORED.

 CARD NUM = 1958; KEYWORD FIELD = 'NUMCYCLE'
      PARAMETERS ARE:    41.0000000     0.0000000     0.0000000     0.0000000     0.0000000     0.0000000     0.0000000
      COL 11 TO 80 ='        41                                                            '

********   FVS04 ERROR:  A REQUIRED PARAMETER IS MISSING OR A PARAMETER IS INCORRECT; KEYWORD IGNORED.

RANNSEED   RANDOM SEED IS:           1.0

```

STAND ID 338300300218_Y1_R1 has STAND CN 22870841010661; it is the first
stand in the file.

SAND CN 22870841010661 is for STAND ID 338300300218_Y1_R1, which is 30 some
odd stands down.

Aha - NUMCYCLE is 41; from the FVS Keyword Reference:

> The maximum number of cycles in a projection is 40.

Are there any others?

Nope, just this one stand, only for the single-year projection, once for
each of the random seeds. Ignore.

### One Thousand Trees

The TPA fault may indicate a keyword file generation error; let's track it down.
```{r, eval = FALSE}
debug_stand_id <- fvs_warnings |>
  filter(grepl(" TPA ", text)) |>
  head(1) |>
  pull("STAND_ID")
fvs_warnings |>
  filter(STAND_ID == debug_stand_id)
```

a'ight, what's species 9?

```{r fvs species 9, eval = FALSE}
debug_species <- species_mixin |>
  filter(FVS_SPNO == 9)
debug_species
```

There's a record for this plot for eastern white pine with TPA > 1000.
Is it regen?

```{r fault analysis, eval = FALSE}
fvs_spcd <- debug_species[["FVS_SPCD"]]
regen_table |>
  filter(STAND_ID == "090400500390") |>
  filter(species == fvs_spcd)
```

Doesn't look like it.

Is it in the tree table?

```{r white pine in stand 390, eval = FALSE}
debug_stand <- stands_projected |>
  filter(STAND_ID == "090400500390")
standcn <- debug_stand[["STAND_CN"]]
statecd <- debug_stand[["STATECD"]]
countycd <- debug_stand[["COUNTYCD"]]
plot <- debug_stand[["PLOT"]]
invyr <- debug_stand[["FIRSTYEAR"]]
spcd <- debug_species[["SPCD"]]

fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
debug_trees <- tbl(fia, "FVS_TreeInit_Plot") |>
  filter(
    STAND_CN == standcn &
      SPECIES == spcd
  ) |>
  collect()
DBI::dbDisconnect(fia)
debug_trees |>
  arrange(DIAMETER, desc(TREE_COUNT))
```

Yup, there it is - TREE_COUNT = 1124.479237 and DIAMETER = 0.1

I think we note that these exist, and ignore them.

```{r, eval = FALSE}
fvs_warnings |>
  filter(grepl(" TPA ", text)) |>
  nrow()
```

4167 is a lot. What species are they?

```{r tpa warning species, eval = FALSE}
fvs_warnings |>
  filter(grepl("TREE_ID", text)) |>
  mutate(
    FVS_SPNO = as.integer(sub(".*SPECIES=[^0-9]*([0-9]+) .*", "\\1", text)),
    DIA = as.double(sub(".*DIAMETER=[^0-9]*([0-9.]+) .*", "\\1", text)),
    TREE_CLASS = case_when(
      DIA < 1 ~ "SEEDLING",
      DIA < 3 ~ "SAPLING",
      .default = "TREE"
    )
  ) |>
  group_by(FVS_SPNO, TREE_CLASS) |>
  summarize(COUNT = n(), .groups = "keep") |>
  ungroup() |>
  arrange(desc(COUNT)) |>
  left_join(species_mixin, by = join_by(FVS_SPNO))
```

All seedlings, and all read directly from FIA.
We can decide to not worry about them.

## Load Results

Load the output from all FVS partitions into a single dataframe

Consolidate outputs that use multiple random seeds;
average the multiple runs with different random seeds.

```{r FVS_Carbon_NONE, eval = FALSE}
FVS_Carbon_NONE <- fvs_read_output(nrs_growonly_none, "FVS_Carbon") |>
  group_by(StandID, Year) |> # Combine results from different random seeds
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    .groups = "keep"
  ) |>
  ungroup()

FVS_Summary2_East_NONE <- fvs_read_output(nrs_growonly_none, "FVS_Summary2_East") |>
  group_by(StandID, Year) |>
  summarize(
    BA = mean(BA),
    Tpa = mean(Tpa),
    .groups = 'keep'
  ) |>
  ungroup()

FVS_Carbon_SRVY <- fvs_read_output(nrs_growonly_srvy, "FVS_Carbon") |>
  select(StandID, Year, Aboveground_Total_Live)

FVS_Summary2_East_SRVY <- fvs_read_output(nrs_growonly_srvy, "FVS_Summary2_East") |>
  select(StandID, Year, BA, Tpa)
```
Sanity check: did we get the outputs we requested?

```{r sanity-check-expected-output, eval = FALSE}
matched_carbon_tmp <- nrs_plots_grown |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    FIRST_YEAR = min(MEASYEAR, na.rm = TRUE),
    LAST_YEAR = max(MEASYEAR, na.rm = TRUE),
    .groups = "keep"
  ) |>
  ungroup() |>
  mutate(
    # STAND_ID won't match FVS_PLOTINIT_PLOT.STAND_ID; that's OK
    STAND_ID = sprintf("%04d%03d%05d", STATECD, COUNTYCD, PLOT)
  ) |>
  left_join(
    FVS_Carbon_NONE |>
      select(StandID, Year, Aboveground_Total_Live) |> 
      rename(
        STAND_ID = StandID,
        FIRST_YEAR = Year,
        Starting_Carbon = Aboveground_Total_Live
      ),
    by = join_by(STAND_ID, FIRST_YEAR)
  ) |>
  left_join(
    FVS_Carbon_NONE |>
      select(StandID, Year, Aboveground_Total_Live) |>
      rename(
        STAND_ID = StandID,
        LAST_YEAR = Year,
        Ending_Carbon = Aboveground_Total_Live
        ),
    by = join_by(STAND_ID, LAST_YEAR)
  )
missing_start <- matched_carbon_tmp |>
  filter(is.na(Starting_Carbon)) |> 
  nrow()
print(missing_start)
missing_end <- matched_carbon_tmp |>
  filter(is.na(Ending_Carbon)) |> 
  nrow()
print(missing_end)
stopifnot(missing_start == 0)
stopifnot(missing_end == 0)
remove(
  matched_carbon_tmp,
  missing_start,
  missing_end
)
```

## Annual vs. Decadal Projections

TODO: bring back annual, it's not currently processed

```{r annual_vs_decadal, eval = FALSE}
decadal_carbon_tmp <- FVS_Carbon_NONE |>
  rename(Decadal_Carbon = Aboveground_Total_Live) |>
  mutate(STAND_ID = paste0(
     substring(StandID, 1, 2),
     substring(StandID, 5, 12)
  )) |>
  select(STAND_ID, Year, Decadal_Carbon)

annual_carbon_tmp <- FVS_Carbon_ANNL |>
  rename(Annual_Carbon = Aboveground_Total_Live) |>
  mutate(STAND_ID = paste0(
     substring(StandID, 1, 2),
     substring(StandID, 5, 12)
  )) |>
  select(STAND_ID, Year, Annual_Carbon)

annual_vs_decadal <- stand_stats |>
  filter(DESIGNCD == 1) |>
  mutate(STAND_ID = sprintf(paste0(
    '%02d',  '%03d',   '%05d'),
    STATECD, COUNTYCD, PLOT
  )) |>
  rename(Year = MEASYEAR) |>
  select(
    STAND_ID, Year,
    STDAGE, FOREST_TYPE, FOREST_TYPE_GROUP, ECOSUBCD
  ) |>
  left_join(decadal_carbon_tmp, by = join_by(STAND_ID, Year)) |>
  left_join(annual_carbon_tmp, by = join_by(STAND_ID, Year)) |>
  # There's something funny going on with plots; i've yet to figure it out.
  filter(!is.na(Decadal_Carbon) & !is.na(Annual_Carbon)) |>
  consolidate_forest_type_groups_filter() |>
  group_by(STAND_ID) |>
  mutate(
    ECOCD = substr(ECOSUBCD, 1, nchar(ECOSUBCD) - 1),
    First_Year = min(Year, na.rm = TRUE),
    Last_Year = max(Year, na.rm = TRUE),
    Decadal_Starting_Carbon = max(if_else(Year == First_Year, Decadal_Carbon, 0), na.rm = TRUE),
    Decadal_Carbon_Delta = Decadal_Carbon - Decadal_Starting_Carbon,
    Decadal_Carbon_Flux = if_else(Year == First_Year, 0, Decadal_Carbon_Delta / (Year - First_Year)),
    Annual_Starting_Carbon = max(if_else(Year == First_Year, Annual_Carbon, 0), na.rm = TRUE),
    Annual_Carbon_Delta = Annual_Carbon - Annual_Starting_Carbon,
    Annual_Carbon_Flux = if_else(Year == First_Year, 0, Annual_Carbon_Delta / (Year - First_Year))
  ) |>
  ungroup() |>
  filter(First_Year != Last_Year) |>
  filter(Year == Last_Year | Year == First_Year) |>
  mutate(Projection_Years = Year - First_Year) |>
  mutate(Carbon_Residual = Decadal_Carbon - Annual_Carbon) |>
  mutate(Carbon_Error = 2 * abs(Carbon_Residual) / (Decadal_Carbon + Annual_Carbon)) |>
  mutate(Carbon_Delta_Residual = Decadal_Carbon_Delta - Annual_Carbon_Delta) |>
  mutate(Carbon_Flux_Residual = Decadal_Carbon_Flux - Annual_Carbon_Flux)

remove(
  decadal_carbon_tmp,
  annual_carbon_tmp
)
```

```{r plot_decadal_vs_annual, eval = FALSE}
ggplot(
    annual_vs_decadal |>
      filter(Projection_Years > 0),
    aes(x = Decadal_Carbon_Flux, y = Annual_Carbon_Flux)
  ) +
  geom_bin2d(binwidth = 0.25) +
  scale_fill_continuous(name = "Number of Plots", transform = "log10") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") +
  #facet_wrap(~FOREST_TYPE_GROUP) +
  theme_bw() +
  ggtitle(bquote("Annual Carbon Flux for 1- vs. 10-year Timestep")) +
  coord_cartesian(xlim = c(-1, 8), ylim = c(-1, 8)) +
  ylab(bquote("1-Year Timestep Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1))) +
  xlab(bquote("10-Year Timestep Annual Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% yr^-1)))
```

```{r, eval = FALSE}
annual_vs_decadal |>
  filter(Decadal_Carbon_Flux > 0) |>
  mutate(Ratio = Decadal_Carbon_Flux / Annual_Carbon_Flux) |>
  ggplot(aes(x = Ratio)) +
  geom_histogram(bins = 50) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
  scale_x_continuous(transform = "log10", breaks = c(1, 2, 3, 5, 10, 20, 30, 50)) +
#  facet_wrap(~FOREST_TYPE_GROUP) +
  theme_bw() +
  ggtitle("Ratio of Projected Carbon using 10 vs. 1 year timestep") +
  ylab("Number of Plots") +
  xlab("Ratio (10-Year / 1-Year)")

```

```{r carbon_flux_stats, eval = FALSE}
summary(annual_vs_decadal[,c("Annual_Carbon_Flux", "Decadal_Carbon_Flux")])
```

## Projected vs. Measured

Filter projections to corresponding observations.

projected_vs_measured has the projection and measurement for the quantities
of interest in the first and last year, and nothing in between.

```{r projected_vs_measured, eval = FALSE}
projected_carbon_tmp <- FVS_Carbon_NONE |>
  select(StandID, Year, Aboveground_Total_Live) |>
  rename(Projected_Carbon = Aboveground_Total_Live)

projected_ba_tmp <- FVS_Summary2_East_NONE |>
  select(StandID, Year, BA, Tpa) |>
  mutate(Projected_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  rename(Projected_Tpa = Tpa)

projected_tmp <- projected_carbon_tmp |>
  full_join(projected_ba_tmp, by = join_by(StandID, Year)) |>
  select(StandID, Year, Projected_Carbon, Projected_BA, Projected_Tpa)

surveyed_carbon_tmp <- FVS_Carbon_SRVY |>
  select(StandID, Year, Aboveground_Total_Live) |>
  rename(Measured_Carbon = Aboveground_Total_Live)

surveyed_ba_tmp <- FVS_Summary2_East_SRVY |>
  select(StandID, Year, BA, Tpa) |>
  mutate(Measured_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  rename(Measured_Tpa = Tpa)

surveyed_tmp <- surveyed_carbon_tmp |>
  full_join(surveyed_ba_tmp, by = join_by(StandID, Year)) |>
  filter(!is.na(Measured_Carbon)) |> # other metrics get an extra year
  select(StandID, Year, Measured_Carbon, Measured_BA, Measured_Tpa)

projected_vs_measured <- nrs_plots_grown |>
  mutate(StandID = sprintf(paste0(
    '%04d',  '%03d',   '%05d'),
    STATECD, COUNTYCD, PLOT
  )) |>
  rename(Year = MEASYEAR) |>
  left_join(nrs_plots_stats, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
  select(
    StandID, Year,
    STDAGE, FOREST_TYPE, FOREST_TYPE_GROUP, ECOSUBCD,
    QMD, QMD_METRIC
  ) |>
  left_join(projected_tmp, by = join_by(StandID, Year)) |>
  left_join(surveyed_tmp, by = join_by(StandID, Year)) |>
  filter_decode_forest_type_group() |>
  group_by(StandID) |>
  mutate(
    ECOCD = substr(ECOSUBCD, 1, nchar(ECOSUBCD) - 1),
    First_Year = min(Year, na.rm = TRUE),
    Last_Year = max(Year, na.rm = TRUE),
    Starting_Carbon = min(if_else(Year == First_Year, Measured_Carbon, NA), na.rm = TRUE),
    Projected_Carbon_Delta = Projected_Carbon - Starting_Carbon,
    Projected_Carbon_Flux = if_else(Year == First_Year, 0, -(Projected_Carbon_Delta / (Year - First_Year))),
    Measured_Carbon_Delta = Measured_Carbon - Starting_Carbon,
    Measured_Carbon_Flux = if_else(Year == First_Year, 0, -(Measured_Carbon_Delta / (Year - First_Year))),
    Starting_BA = min(if_else(Year == First_Year, Measured_BA, NA), na.rm = TRUE),
    Projected_BA_Delta = Projected_BA - Starting_BA,
    Projected_BAI = if_else(Year == First_Year, 0, Projected_BA_Delta / (Year - First_Year)),
    Measured_BA_Delta = Measured_BA - Starting_BA,
    Measured_BAI = if_else(Year == First_Year, 0, Measured_BA_Delta / (Year - First_Year))
  ) |>
  ungroup() |>
  filter(Year == First_Year | Year == Last_Year) |>
  filter(!is.na(Projected_Carbon) & !is.na(Measured_Carbon)) |>
  mutate(Projection_Years = Year - First_Year) |>
  mutate(BA_Residual = Projected_BA - Measured_BA) |>
  mutate(BA_Error = 2 * abs(BA_Residual) / (Projected_BA + Measured_BA)) |>
  mutate(BA_Delta_Residual = Projected_BA_Delta - Measured_BA_Delta) |>
  mutate(BA_Flux_Residual = BA_Delta_Residual / Projection_Years) |>
  mutate(Carbon_Residual = Projected_Carbon - Measured_Carbon) |>
  mutate(Carbon_Error = 2 * abs(Carbon_Residual) / (Projected_Carbon + Measured_Carbon)) |>
  mutate(Carbon_Delta_Residual = Projected_Carbon_Delta - Measured_Carbon_Delta) |>
  mutate(Carbon_Flux_Residual = Projected_Carbon_Flux - Measured_Carbon_Flux)

remove(
  projected_carbon_tmp,
  projected_ba_tmp,
  projected_tmp,
  surveyed_carbon_tmp,
  surveyed_ba_tmp,
  surveyed_tmp
)
```

Run a quick check to make sure the plots grew during the projection period,
rather than shrank.

```{r sanity-check-plots-grew, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Measured_BA_Delta)
  ) +
  geom_bin2d(bins = 30) +
  geom_abline(intercept = 0, slope = 0, linetype = "dashed", color = "red") +
  scale_fill_continuous(name = "Number of Plots") +
  theme_bw() +
  #scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20, 22)) +
  #facet_wrap(~FOREST_TYPE_GROUP) +
  ggtitle("Grow-Only Stands\nChange in FVS Measured BA (m² / ha) vs. Projection Years")
```

## Carbon Projection

```{r projected_carbon_vs_measured_carbon, eval = FALSE}
projected_vs_measured |>
  filter(Projection_Years > 0) |>
  mutate(Ratio = Projected_Carbon / Measured_Carbon) |>
  ggplot(aes(x = Ratio)) +
  geom_histogram(bins = 50) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
  theme_bw() +
  ggtitle("Ratio of FVS Projected / FIA Measured Carbon") +
  ylab("Number of Plots") +
  xlab("Ratio (FVS Projected / FIA Measured)")
```

```{r summary projected_vs_measured, eval = FALSE}
projected_vs_measured |>
  filter(Projection_Years > 0) |>
  mutate(Ratio = Measured_Carbon / Projected_Carbon) |>
  summary()
```

```{r projected_carbon_vs_measured_carbon_with_trendline, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_Carbon, y = Projected_Carbon)
  ) +
  geom_bin2d(bins = 50) +
  geom_abline(intercept = 0, slope = 1, linewidth = 0.5, linetype = "dashed", color = "lightgray") +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    color = 'darkblue',
    linetype = 'dashed',
    linewidth = 0.5,
    fullrange = TRUE,
    se = FALSE
  ) +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
#  facet_wrap(~FOREST_TYPE_GROUP) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  ggtitle("FVS Projected vs. Measured Carbon") +
  xlab(bquote("Projected Stand AGL Carbon" ~(`Mg C` %.% ha^-1))) +
  ylab(bquote("Measured Stand AGL Carbon" ~(`Mg C` %.% ha^-1))) +
  coord_cartesian(xlim = c(0, 300), ylim = c(0, 300))
```

### Carbon Flux

Which is great, but for large BA plots, only a small portion will be projected,
so the error is masked by the pre-existing BA. So, instead, look at measured
vs. projected carbon change.

```{r plot_projected_annual_carbon_flux, eval = FALSE}
all_years <- tibble(Year = min(FVS_Carbon_NONE$Year):max(FVS_Carbon_NONE$Year))
num_years <- all_years |> nrow()

FVS_Carbon_NONE |>
  group_by(StandID) |>
  arrange(Year) |>
  mutate(
    # Positive flux is into atmosphere / out of forest;
    # Negative flux is out of atmosphere / into forest.
    C_Flux = -(Aboveground_Total_Live - lag(Aboveground_Total_Live)),
    Prev_Year = lag(Year)
  ) |>
  ungroup() |>
  mutate(
    Annual_C_Flux = C_Flux / (Year - Prev_Year)
  ) |>
  group_by(StandID) |>
  mutate(Min_Year = min(Year), Max_Year = max(Year)) |>
  ungroup() |>
  full_join(
    expand.grid(
      StandID = unique(FVS_Carbon_NONE$StandID),
      Year = all_years$Year
    ),
    by = join_by(StandID, Year)
  ) |>
  arrange(StandID, Year) |>
  fill(Min_Year, Max_Year, .direction = "updown") |>
  fill(StandID, Annual_C_Flux, .direction = "up") |>
  filter(Year >= Min_Year & Year <= Max_Year) |>
  ggplot(
    aes(x = Year, y = Annual_C_Flux)
  ) +
  geom_bin2d(binwidth = c(1, 1)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  theme_bw() +
  ggtitle("FVS Projected Annual Carbon Flux for Grow-Only Plots") +
  ylab(bquote("Projected Carbon Flux" ~(`Mg C` %.% ha^-1 %.% yr^-1))) #+;

```

```{r plot_surveyed_annual_carbon_flux, eval = FALSE}
all_years <- tibble(Year = min(FVS_Carbon_SRVY$Year):max(FVS_Carbon_SRVY$Year))
num_years <- all_years |> nrow()

FVS_Carbon_SRVY |>
  group_by(StandID) |>
  arrange(Year) |>
  mutate(
    C_Flux = -(Aboveground_Total_Live - lag(Aboveground_Total_Live)),
    Prev_Year = lag(Year)
  ) |>
  ungroup() |>
  mutate(
    Annual_C_Flux = C_Flux / (Year - Prev_Year)
  ) |>
  group_by(StandID) |>
  mutate(
    Min_Year = min(Year),
    Max_Year = max(Year)
  ) |>
  ungroup() |>
  full_join(
    expand.grid(
      StandID = unique(projected_vs_measured$StandID),
      Year = all_years$Year
    ),
    by = join_by(StandID, Year)
  ) |>
  arrange(StandID, Year) |>
  fill(Min_Year, Max_Year, .direction = "updown") |>
  fill(StandID, Annual_C_Flux, .direction = "up") |>
  filter(Year >= Min_Year & Year <= Max_Year) |>
  ggplot(
    aes(x = Year, y = Annual_C_Flux)
  ) +
  geom_bin2d(binwidth = c(1, 1)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  theme_bw() +
  ggtitle("Observed Annual Carbon Flux for Grow-Only Plots") +
  ylab(bquote("Observed Carbon Flux" ~(`Mg C` %.% ha^-1 %.% yr^-1))) #+;

```

```{r measured_vs_projected_carbon_change, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> arrange(Projection_Years),
    aes(x = Measured_Carbon_Delta, y = Projected_Carbon_Delta)
  ) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_vline(xintercept = 0, linewidth = 0.25, color = "black") +
  geom_abline(intercept = 0, slope = 1, linewidth = 0.5, linetype = "dashed", color = "lightgray") +
  geom_bin2d(bins = 20) +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    color = 'darkblue',
    linetype = 'dashed',
    linewidth = 0.5,
    fullrange = TRUE,
    se = FALSE
  ) +
  facet_wrap(~FOREST_TYPE_GROUP) +
  theme(aspect.ratio = 1) +
  theme_bw() +
  ggtitle(scales::label_wrap(50)("FVS Projected vs. FIA Measured AGL Carbon Change in Grow-Only Stands")) +
  ylab(bquote("Projected AGL Carbon Delta" ~(`Mg C` %.% ha^-1))) +
  xlab(bquote("Measured AGL Carbon Delta" ~(`Mg C` %.% ha^-1))) +
  coord_cartesian(xlim = c(-100, 100), ylim = c(-100, 100))
```

```{r measured_vs_projected_carbon_flux, eval = FALSE}
lr <- lm(
  Projected_Carbon_Flux ~ Measured_Carbon_Flux,
  data = projected_vs_measured |> filter(Projection_Years > 0)
)
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_Carbon_Flux, y = Projected_Carbon_Flux)
  ) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_vline(xintercept = 0, linewidth = 0.25, color = "black") +
  geom_abline(intercept = 0, slope = 1, linewidth = 0.25, linetype = "dashed", color = "lightgray") +
  geom_bin2d(bins = 50) +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  geom_abline(
    intercept = lr$coefficients[1],
    slope = lr$coefficients[2],
    linetype = "dashed",
    color = "darkblue"
  ) +
#  geom_smooth(
#    method = lm,
#    formula = 'y ~ x',
#    color = 'darkblue',
#    linetype = 'dashed',
#    linewidth = 0.5,
#    # fullrange = TRUE,
#    se = FALSE
#  ) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  ggtitle(scales::label_wrap(35)("FVS Projected vs. FIA Measured AGL Carbon Flux in Grow-Only Stands")) +
  xlab(bquote("Measured Annual Carbon Flux" ~(`Mg C` %.% ha^-1 %.% yr^-1))) +
  ylab(bquote("Projected Annual Carbon Flux" ~(`Mg C` %.% ha^-1 %.% yr^-1))) +
  coord_cartesian(xlim = c(-10, 10), ylim = c(-10, 10))
```

```{r carbon flux ratio, eval = FALSE}
projected_vs_measured |>
  filter(Projection_Years > 0) |>
  mutate(Ratio = Projected_Carbon_Flux / Measured_Carbon_Flux) |>
  filter(-10 < Ratio & Ratio < 10) |>
  ggplot(aes(x = Ratio)) +
  geom_histogram(bins = 50) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  ggtitle("Annual Carbon Flux Ratio") +
  ylab("Number of Plots") +
  xlab("Ratio (Projected / Measured)")

```



```{r summary projected vs measured carbon flux, eval = FALSE}
projected_vs_measured |>
  filter(Projection_Years > 0) |>
  mutate(Ratio = Projected_Carbon_Flux / Measured_Carbon_Flux) |>
  summary()
```

```{r projected-vs-measured-carbon-flux, eval = FALSE}
projected_vs_measured_with_n <- projected_vs_measured |>
  filter(Projection_Years > 0) |>
  group_by(FOREST_TYPE_GROUP) |>
  mutate(FOREST_TYPE_GROUP = paste0(FOREST_TYPE_GROUP, ", n=", n())) |>
  ungroup()
  
ggplot(
    projected_vs_measured_with_n,
    aes(Projected_Carbon_Flux, fct_reorder(FOREST_TYPE_GROUP, Measured_Carbon, .fun = sum))
  ) +
  geom_vline(xintercept = 0, color = 'red') +
  geom_boxplot(varwidth = TRUE) +
  # scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  geom_point(
    data = projected_vs_measured_with_n |>
      group_by(FOREST_TYPE_GROUP) |> 
      summarize(
        Measured_Carbon_Flux = mean(Measured_Carbon_Flux),
        Measured_Carbon = sum(Measured_Carbon),
        .groups = 'keep'
      ) |> 
      ungroup(),
    aes(Measured_Carbon_Flux),
    color = 'blue',
    shape = 4,
    size = 3
  ) +
  theme_bw() +
  ggtitle(bquote("Projected vs. Measured Annual Carbon Flux")) +
  xlab(bquote("Carbon Flux" ~(`Mg C` %.% ha^-1 %.% yr^-1))) +
  ylab("Forest Type Group")

```


### Residuals

Let's look at carbon flux residuals.
This is Mg of carbon per hectare per year.

```{r carbon-flux-by-forest-type, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(Carbon_Flux_Residual, fct_reorder(FOREST_TYPE_GROUP, Measured_Carbon, .fun = sum))
  ) +
  geom_vline(xintercept = 0, color = 'red') +
  geom_boxplot(varwidth = TRUE, outlier.size = 0.1) +
  # scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  geom_point(
    data = projected_vs_measured |>
      filter(Projection_Years > 0) |> 
      group_by(FOREST_TYPE_GROUP) |> 
      summarize(
        Measured_Carbon_Flux = mean(Measured_Carbon_Flux),
        Measured_Carbon = sum(Measured_Carbon),
        .groups = 'keep'
      ) |> 
      ungroup(),
    aes(Measured_Carbon_Flux),
    color = 'blue',
    shape = 4,
    size = 3
  ) +
  theme_bw() +
  ggtitle(paste0(
    "FVS Projected Carbon Flux Residual by Forest Type Group",
    "\n",
    "for Grow-Only FIA Plots in the Northeast"
  )) +
  xlab(bquote("Carbon Flux Residual " ~(`Mg C` %.% ha^-1 %.% year^-1))) +
  labs(caption = bquote("X = Mean Measured Carbon Flux " ~ (`Mg C` %.% ha^-1 %.% year^-1))) +
  ylab("Forest Type Group")

```

```{r carbon-flux-by-forest-type-detail, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(Carbon_Flux_Residual, fct_reorder(FOREST_TYPE_GROUP, Measured_Carbon, .fun = sum))
  ) +
  geom_vline(xintercept = 0, color = 'red') +
  geom_boxplot(varwidth = TRUE, outlier.size = 0.1) +
  geom_point(
    data = projected_vs_measured |>
      filter(Projection_Years > 0) |> 
      group_by(FOREST_TYPE_GROUP) |> 
      summarize(
        Measured_Carbon_Flux = mean(Measured_Carbon_Flux),
        Measured_Carbon = sum(Measured_Carbon),
        .groups = 'keep'
      ) |> 
      ungroup(),
    aes(Measured_Carbon_Flux),
    color = 'blue',
    shape = 4,
    size = 3
  ) +
#  scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  coord_cartesian(xlim = c(-5, 0)) +
  theme_bw() +
  #scale_x_continuous(breaks = c(-5, -2.5, 0, 2.5, 5)) +
  ggtitle(paste0(
    "FVS Projected Carbon Flux Residual by Forest Type Group",
    "\n",
    "for Grow-Only FIA Plots in the Northeast"
  )) +
  xlab(bquote("Carbon Flux Residual " ~(`Mg C` %.% ha^-1 %.% year^-1))) +
  labs(caption = bquote("X = Mean Measured Carbon Flux " ~ (`Mg C` %.% ha^-1 %.% year^-1))) +
  ylab("Forest Type Group")
```

```{r carbon-flux-by-ecoregion, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(Carbon_Flux_Residual, fct_reorder(ECOCD, Measured_Carbon, .fun = sum))
  ) +
  geom_vline(xintercept = 0, color = 'red') +
  geom_boxplot(varwidth = TRUE, outlier.size = 0.1) +
#  scale_y_discrete(guide = guide_axis(n.dodge = 2)) +
  coord_cartesian(xlim = c(-10, 10)) +
#  scale_x_continuous(breaks = c(-10, -2.5, 0, 2.5, 5)) +
  theme_bw() +
  ggtitle("Grow-Only Stands\nCarbon Flux Residual by Ecoregion") +
  xlab(bquote("Carbon Flux Residual" ~(`Mg C` %.% ha^-1 %.% yr^-1))) +
  ylab("Ecosubregion")
```

### Residuals vs. Years Projected

```{r carbon_residual_vs_projection_years, eval = FALSE}
ggplot(
    projected_vs_measured|> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Carbon_Residual)
  ) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_bin2d(bins = 20) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    linetype = "dashed",
    linewidth = 0.5,
    color = 'darkblue'
  ) +
  facet_wrap(~FOREST_TYPE_GROUP) +
  theme_bw() +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  ggtitle("Carbon Projection Residual vs. Projection Years\nin Grow-Only Stands") +
  xlab("Projection Years") +
  ylab(bquote("Carbon Residual" ~(`Mg C` %.% ha^-1)))
```


```{r carbon_error_vs_projection_yearsm, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Carbon_Error)
  ) +
  geom_bin2d(bins = 20) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'darkblue',
    linetype = "dashed",
    linewidth = 0.5
  ) +
  facet_wrap(~FOREST_TYPE_GROUP) +
#  coord_cartesian(xlim = c(10, 20), ylim = c(0, 1)) +
#  scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20)) +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  theme_bw() +
  ggtitle("Grow-Only Stands\nCarbon Projection Error (fraction) vs. Projection years")
  
```

```{r carbon_flux_residual_vs_projection_years, eval = FALSE}
ggplot(
    projected_vs_measured|> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = Carbon_Flux_Residual)
  ) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_bin2d(bins = 20) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'darkblue',
    linetype = "dashed",
    linewidth = 0.5
  ) +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  facet_wrap(~FOREST_TYPE_GROUP) +
  theme_bw() +
  ggtitle("Grow-Only Stands\nCarbon Projection Flux Residual vs. Projection Years") +
  xlab("Projection Years") +
  ylab(bquote("Carbon Flux Residual" ~(`Mg C` %.% ha^-1 %.% yr^-1)))
```

### Residuals vs. BA

```{r carbon_residual_vs_measured_ba, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    mapping = aes(x = Measured_BA, y = Carbon_Residual)
  ) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_bin2d(bins = 20) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'darkblue',
    linetype = 'dashed',
    linewidth = 0.5
  ) +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  facet_wrap(~FOREST_TYPE_GROUP) +
  theme_bw() +
  ggtitle("Carbon Projection Residuals vs. Measured BA\n in Grow-Only Stands") +
  xlab(bquote("Measured BA" ~ (m^2 %.% ha^-1))) +
  ylab(bquote("Carbon Residual" ~ (`Mg C` %.% ha^-1)))
  
```


```{r carbon_error_vs_measured_ba, eval = FALSE}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      filter(Carbon_Error < 1),
    aes(x = Measured_BA, y = Carbon_Error)
  ) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_bin2d(bins = 20) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'darkblue',
    linetype = 'dashed',
    linewidth = 0.5
  ) +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  facet_wrap(~FOREST_TYPE_GROUP) +
  theme_bw() +
  ggtitle("Carbon Projection Error vs. Measured BA\nin Grow-Only Stands") +
  xlab(bquote("Measured BA" ~ (m^2 %.% ha^-1))) +
  ylab(bquote("Carbon Projection Error (fraction)"))
```

This omits outliers; looking just at the outliers (error >= 2x value):

```{r carbon_error_vs_measured_ba_outliers, eval = FALSE}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      filter(Carbon_Error >= 1),
    aes(x = Measured_BA, y = Carbon_Error)
  ) +
  geom_point() +
  coord_cartesian(ylim = c(0, NA)) +
  facet_wrap(~FOREST_TYPE_GROUP) +
  theme_bw() +
  ggtitle("Grow-Only Stands\nCarbon Projection Error Outliers vs. Measured BA") +
  xlab(bquote("Measured BA" ~ (m^2 %.% ha^-1))) +
  ylab(bquote("Carbon Projection Error (fraction)"))
```

```{r carbon_flux_residual_vs_measured_ba, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    mapping = aes(x = Measured_BA, y = Carbon_Flux_Residual)
  ) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_bin2d(bins = 20) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'darkblue',
    linetype = "dashed",
    linewidth = 0.5
  ) +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  facet_wrap(~FOREST_TYPE_GROUP) +
  theme_bw() +
  ggtitle("Carbon Flux Residual vs. Measured BA\nin Grow-Only Stands") +
  xlab(bquote("Measured BA" ~ (m^2 %.% ha^-1))) +
  ylab(bquote("Carbon Flux Residual" ~(`Mg C` %.% ha^-1 %.% yr^-1)))
  
```

### Residuals vs. QMD

```{r carbon_residuals_vs_qmd, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> filter(QMD_METRIC < 100),
    aes(x = QMD_METRIC, y = Carbon_Residual)
  ) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_bin2d(bins = 20) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'darkblue',
    linetype = "dashed",
    linewidth = 0.5
  ) +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10"
    low = "lightblue",
    high = "darkblue"
  ) +
  facet_wrap(~FOREST_TYPE_GROUP) +
  theme_bw() +
  ggtitle("Carbon Projection Error vs. Measured QMD\nin Grow-Only Stands") +
  xlab(bquote("Measured QMD" ~ (cm))) +
  ylab(bquote("Carbon Residual" ~ (`Mg C` %.% ha^-1)))
  
```

```{r carbon_flux_residuals_vs_qmd, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> filter(QMD_METRIC < 100),
    aes(x = QMD_METRIC, y = Carbon_Flux_Residual)
  ) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_bin2d(bins = 20) +
  scale_x_log10() +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'darkblue',
    linetype = "dashed",
    linewidth = 0.5
  ) +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  theme_bw() +
  facet_wrap(~FOREST_TYPE_GROUP) +
  ggtitle("Grow-Only Stands\nCarbon Flux Residual vs. Measured QMD") +
  xlab(bquote("QMD" ~ (cm))) +
  ylab(bquote("Carbon Flux Residual" ~ (`Mg C` %.% ha^-1 %.% yr^-1)))
```

## Basal Area Projection

```{r projected_ba_vs_measured_ba, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_BA, y = Projected_BA)
  ) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", linewidth = 0.25, color = "lightgray") +
  geom_bin2d(binwidth = 2.5) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'darkblue',
    linetype = 'dashed',
    linewidth = 0.5
  ) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  #facet_wrap(~FOREST_TYPE_GROUP) +
  ggtitle("Projected vs. Measured Basal Area\nin Grow-Only Stands") +
  xlab(bquote("Measured Basal Area" ~(m^2 %.% ha^-1))) +
  ylab(bquote("Projected Basal Area" ~(m^2 %.% ha^-1)))
```

```{r basal_area_trend, eval = FALSE}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      mutate(
        BA_Range = cut(Measured_BA, 0:19 * 5)
      ) |>
      group_by(FOREST_TYPE_GROUP) |>
      mutate(FOREST_TYPE_GROUP = paste0(FOREST_TYPE_GROUP, ", n=", n())) |>
      ungroup()
    ,
    aes(x = BA_Range, y = BA_Flux_Residual)
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_boxplot(outlier.size = 0.1, varwidth = TRUE) +
  scale_fill_discrete(name = "Forest Type Group") +
  ggtitle("BA Residual vs. Measured BA") +
  ylab(bquote("BA Residual " (m^2 %.% ha^-1 %.% yr^-1))) +
  xlab(bquote("Measured Stand BA " (m^2 %.% ha^-1))) +
  theme_bw() +
  coord_cartesian(ylim = c(-2, 3))

```

```{r p_vs_m_bai, eval=FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_BAI, y = Projected_BAI)
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", linewidth = 0.25, color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", linewidth = 0.25, color = "black") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", linewidth = 0.25, color = "lightgray") +
  geom_bin2d(binwidth = 0.1) +
#  geom_smooth(
#    method = lm,
#    formula = 'y ~ x',
#    fullrange = TRUE,
#    se = FALSE,
#    color = 'brown'
#  ) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  ggtitle("Projected vs. Measured Basal Area Increment\nin Grow-Only Stands") +
  xlab(bquote("Measured Basal Area Increment " ~(m^2 %.% ha^-1 %.% year^-1))) +
  ylab(bquote("Projected Basal Area Increment " ~(m^2 %.% ha^-1 %.% year^-1)))
```

Can we plot plot location with size proportional to BA?

```{r plot_location_by_ecotype_with_carbon, eval = FALSE}
plot_location_tmp <- plot_location |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == min(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  select(STATECD, COUNTYCD, PLOT, long, lat, group)

plot_location_type <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  filter(INVYR == max(INVYR, na.rm = TRUE)) |>
  ungroup() |>
  consolidate_forest_type_groups_filter() |>
  select(STATECD, COUNTYCD, PLOT, INVYR, CARBON_METRIC, FOREST_TYPE_GROUP) |>
  left_join(plot_location_tmp, by = join_by(STATECD, COUNTYCD, PLOT)) |>
  rename(
    `Stand Carbon` = CARBON_METRIC,
    FOREST_TYPE = FOREST_TYPE_GROUP
  ) |>
  group_by(FOREST_TYPE) |>
  mutate(n = n()) |>
  ungroup() |>
  mutate(FOREST_TYPE = if_else(n < 144, 'Other', FOREST_TYPE))

ggplot(map_states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") + 
  geom_point(
    plot_location_type,
    mapping = aes(long, lat, group = group, color = fct_infreq(FOREST_TYPE), size = `Stand Carbon`)
  ) +
  scale_size_binned_area(max_size = 3) +
  coord_sf(crs = 4326) +
  annotation_scale(location = "br") +
  annotation_north_arrow(location = "tl",
    width = unit(1, "cm"),
    pad_x = unit(0.75, "cm"),
    pad_y = unit(0.5, "cm")
  ) +
  ggtitle("FIA Grow-Only Plots in the Northeast Region") +
  scale_color_hue(name = "Forest Type", breaks = c(
    'Maple / beech / birch',
    'Elm / ash / cottonwood',
    'Aspen / birch',
    'Oak / hickory',
    'Scarlet oak',
    'Spruce / fir',
    'White / red / jack pine',
    'Other'
  )) +
  theme_bw()

  #scale_fill_discrete(breaks = rev(levels(projected_annual_growth$Series)))

remove(plot_location_tmp)
```


### Residuals vs. Years Projected

```{r ba_residual_vs_projection_years, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Projection_Years, y = BA_Residual)
  ) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_bin2d(bins = 20) +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'darkblue',
    linetype = 'dashed',
    linewidth = 0.5
  ) +
#  scale_x_continuous(breaks = c(10, 12, 14, 16, 18, 20, 22)) +
  facet_wrap(~FOREST_TYPE_GROUP) +
  theme_bw() +
  ggtitle("BA Residual vs. Projection Years\nin Grow-Only Stands") +
  xlab(bquote("Projection Years")) +
  ylab(bquote("BA Residual" ~(m^2 %.% ha^-1)))
  
```

```{r ba_error_vs_projection_years, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(BA_Error < 1),
    aes(x = Projection_Years, y = BA_Error)
  ) +
  geom_bin2d(bins = 20) +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'darkblue',
    linetype = 'dashed',
    linewidth = 0.5
  ) +
  facet_wrap(~FOREST_TYPE_GROUP) +
  theme_bw() +
  ggtitle("BA Projection Error vs. Projection years\nin Grow-Only Stands") +
  xlab("Projection Years") +
  ylab("BA Projection Error (fraction)")
  
```

### Residuals vs. QMD

```{r ba_residual_vs_qmd, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0) |> filter(QMD_METRIC < 100),
    aes(x = QMD_METRIC, y = BA_Residual)
  ) +
  geom_hline(yintercept = 0, linewidth = 0.25, color = "black") +
  geom_bin2d(bins = 20) +
  scale_fill_gradient(
    name = "Number of Plots",
    #transform = "log10",
    low = "lightblue",
    high = "darkblue"
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'darkblue',
    linetype = "dashed",
    linewidth = 0.5
  ) +
  facet_wrap(~FOREST_TYPE_GROUP) +
  theme_bw() +
  ggtitle("BA Projection Residual vs. Measured QMD\nin Grow-Only Stands") +
  xlab(bquote("QMD" ~(cm))) +
  ylab(bquote("BA Residual" ~(m^2 %.% ha^-1)))
```

```{r qmd_trend2, eval = FALSE}
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      mutate(
        QMD_Range = cut(QMD_METRIC, 0:19 * 5)
      ) |>
      group_by(FOREST_TYPE_GROUP) |>
      mutate(FOREST_TYPE_GROUP = paste0(FOREST_TYPE_GROUP, ", n=", n())) |>
      ungroup()
    ,
    aes(x = QMD_Range, y = BA_Flux_Residual)
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_boxplot(outlier.size = 0.1, varwidth = TRUE) +
  scale_fill_discrete(name = "Forest Type Group") +
  theme_bw() +
  ggtitle("Measured QMD vs. BA Residual for Grow-Only Stands") +
  ylab(bquote("BA Residual " ~(m^2 %.% ha^-1 %.% yr^-1))) +
  xlab(bquote("Measured Stand QMD " ~(cm)))

```
### Residuals vs. TPA

```{r ba_residual_vs_qmd2, eval = FALSE}
ggplot(
    projected_vs_measured |> filter(Projection_Years > 0),
    aes(x = Measured_Tpa, y = Projected_Tpa)
  ) +
  geom_abline(intercept = c(0, 0), slope = 1, linetype = "dashed", linewidth = 0.25, color = "lightgray") +
  geom_bin_2d(
    binwidth = 500
    #alpha = 0.25
  ) +
  scale_fill_gradient(
    name = "Number of Plots",
    #trans = "log",
    low = "lightblue",
    high = "darkblue"
  ) +
  geom_smooth(
    method = lm,
    formula = 'y ~ x',
    fullrange = TRUE,
    se = FALSE,
    color = 'darkblue',
    linetype = 'dashed',
    linewidth = 0.5
  ) +
  # coord_cartesian( xlim = c(0, 40000), ylim = c(0, 25000)) +
  theme_bw() +
  #theme(aspect.ratio = 1) +
  #facet_wrap(~FOREST_TYPE_GROUP) +
  ggtitle("Projected vs. Measured TPA\nin Grow-Only Stands") +
  xlab(bquote("Measured" ~(trees %.% acre^-1))) +
  ylab(bquote("Projected" ~(trees %.% acre^-1)))
```

```{r qmd_trend, eval = FALSE}
options(scipen = 9)
ggplot(
    projected_vs_measured |>
      filter(Projection_Years > 0) |>
      mutate(
        Tpa_Range = cut(Measured_Tpa, 0:10 * 2000, labels = (1:10 * 2000))
      ) |>
      group_by(FOREST_TYPE_GROUP) |>
      mutate(FOREST_TYPE_GROUP = paste0(FOREST_TYPE_GROUP, ", n=", n())) |>
      ungroup()
    ,
    aes(x = Tpa_Range, y = BA_Flux_Residual)
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_boxplot(outlier.size = 0.1, varwidth = TRUE, position = position_nudge(x = -0.5)) +
  scale_fill_discrete(name = "Forest Type Group") +
  theme_bw() +
  ggtitle("Measured TPA vs. BA Residual for Grow-Only Stands") +
  ylab(bquote("BA Residual" (m^2 %.% ha^-1 %.% yr^-1))) +
  xlab(bquote("Measured Stand TPA" (trees %.% acre^-1)))

```


# Addenda

## Eastern Hemlock


```{r eastern_hemlock, eval = FALSE}
rds_file <- 'data/intermediate/eastern_hemlock.rds'
if (USE_CACHE & file.exists(rds_file)) {
  eastern_hemlock <- read_rds(rds_file)
} else {
  tsuga_canadensis <- species_mixin |>
    filter(GENUS == "Tsuga" & SPECIES == "canadensis") |>
    select(SPCD) |>
    pull()
  
  # FIA.TREE.CN - sequence number - 0 NA
  # FIA.TREE.TREE - TREE number
  # FIA.TREE.CONDID - condition class; 1 = live tree
  # FIA.TREE.SPCD - species code
  # FIA.TREE.SPGRPCD is broader than SPCD, group by that instead
  # FIA.TREE.DIA - current diameter - 1693 NA
  # FIA.TREE.DIAHTCD - where diameter was taken, 1 = DBH
  # FIA.TREE.HT - height, including height of missing parts - 2605 NA
  # FIA.TREE.ACTUALHT - actual height, excluding height of missing parts - 4076 NA
  # FIA.TREE.CR - Compacted Crown Ratio, relative to ACTUALHT - 3576 NA
  # FIA.TREE.UNCRCD - Uncompacted Crown Ratio - 28268 NA
  # FIA.TREE.CCLCD - Crown Class code - 3421 NA
  #     1 - Open; 2 - Dominant; 3 - Codominant; 4 - Intermediate; 5 - Overtopped
  # FIA.TREE.CPOSCD - Crown Position Code - 29717 NA
  #     1 - Superstory; 2 - Over; 3 - Under; 4 - Open
  # FIA.TREE.CLIGHTCD - Light code - 29717 NA
  #     0 - 5, # of sides and top receiving light
  # FIA.TREE.CDENCD - Crown Density Code, % - 29820 NA

  fia <- DBI::dbConnect(RSQLite::SQLite(), 'data/raw/SQLite_FIADB_ENTIRE.db')
  measyear_mixin <- tbl(fia, 'PLOT') |>
    select(CN, MEASYEAR) |>
    rename(PLT_CN = CN)
  
  canopy_height_mixin <- tbl(fia, 'TREE') |>
    semi_join(
      plot_grow_only |> arrange(STATECD, COUNTYCD, PLOT),
      by = join_by(STATECD, COUNTYCD, PLOT),
      copy = TRUE
    ) |>
    # Live trees
    filter(CONDID == 1) |>
    # Codominant
    filter(CCLCD == 3) |>
    group_by(PLT_CN) |>
    summarize(CANOPY_HT = mean(HT, na.rm = TRUE)) |>
    ungroup()
  
  eastern_hemlock <- tbl(fia, 'TREE') |>
    semi_join(
      plot_grow_only |> arrange(STATECD, COUNTYCD, PLOT),
      by = join_by(STATECD, COUNTYCD, PLOT),
      copy = TRUE
    ) |>
    # Live trees
    filter(CONDID == 1) |>
    # Eastern Hemlock
    filter(SPCD == tsuga_canadensis) |>
    left_join(measyear_mixin, by = join_by(PLT_CN)) |>
    left_join(canopy_height_mixin, by = join_by(PLT_CN)) |>
    select(
      CN,
      STATECD, COUNTYCD, PLOT, SUBP, TREE, INVYR, MEASYEAR,
      SPCD,
      DIA, DIAHTCD,
      HT, ACTUALHT, CANOPY_HT,
      CR, UNCRCD, CCLCD, CPOSCD, CLIGHTCD, CDENCD
    ) |>
    arrange(STATECD, COUNTYCD, PLOT, SUBP, TREE, MEASYEAR) |>
    collect()
  
  dbDisconnect(fia)

  eastern_hemlock <- eastern_hemlock |>
    left_join(species_mixin, by = join_by(SPCD)) |>
    large_end_diameter_class_filter() |>
    decode_cclcd_filter()

  rm(fia, measyear_mixin, tsuga_canadensis)

  write_rds(eastern_hemlock, rds_file)
}
```

Looks like we have a meaningful number of trees with CCLCD and CR, so let's
compare those.

```{r plot_ccl_vs_cr, eval = FALSE}
eastern_hemlock |>
  filter(!is.na(CCL) & !is.na(CR)) |>
  mutate(CCL = factor(CCL, levels = c("Open grown", "Dominant", "Codominant", "Intermediate", "Overtopped"))) |>
  ggplot(aes(x = CCL, y = CR)) +
  geom_boxplot(outlier.size = 0.1, varwidth = TRUE) +
  theme_bw() +
  ylab("Crown Ratio (%)") +
  xlab("Crown Class") +
  ggtitle("Eastern Hemlock Crown Ratio vs. Crown Class")
  
```

> TODO: Danelle points out that e.g. for two trees that are 40' tall, the
> Codominant one will be in a forest with a 40' canopy, whereas the Intermediate
> one will be under a higher canopy. So, instead of plotting this by tree height,
> we could plot it by canopy height.
> We could estimate canopy height for a plot by looking at the mean height of
> codominant trees.

> TODO: Danelle thinks that the missing bars are due to missing data. Can I insert
> something for missing classes?


```{r plot_cr_vs_ht_by_ccl, eval = FALSE}
plot_eastern_hemlock <- eastern_hemlock |>
  filter(!is.na(CCL) & !is.na(CANOPY_HT) & !is.na(CR)) |>
  # filter(CANOPY_HT > 30 & CANOPY_HT < 100) |>
  mutate(CCL = factor(CCL, levels = rev(c("Open grown", "Dominant", "Codominant", "Intermediate", "Overtopped")))) |>
  mutate(HT_GROUP = factor(as.integer(CANOPY_HT / 10) * 10))
missing_classes <- plot_eastern_hemlock |> distinct(CCL) |>
  cross_join(plot_eastern_hemlock |> distinct(HT_GROUP)) |>
  anti_join(plot_eastern_hemlock |> distinct(HT_GROUP, CCL), by = join_by(HT_GROUP, CCL)) |>
  mutate(CR = -10) # Give missing classes a negative crown ratio so it can be cropped out
plot_eastern_hemlock <- plot_eastern_hemlock |>
  select(HT_GROUP, CCL, CR) |>
  union_all(missing_classes)
plot_eastern_hemlock_counts <- plot_eastern_hemlock |>
  group_by(HT_GROUP, CCL) |>
  summarize(COUNT = n(), CR = mean(CR), .groups = "keep") |>
  ungroup()
```

```{r, eval = FALSE}

plot_eastern_hemlock |>
  ggplot(aes(CR, HT_GROUP, fill = CCL)) +
  theme_bw() +
  geom_boxplot(outlier.size = 0.1) +
  geom_text(
    data = plot_eastern_hemlock_counts,
    mapping = aes(label = COUNT),
    position = position_dodge(width = .75),
    color = 'white'
  ) +
  scale_fill_discrete(name = "Crown Class", breaks = rev(levels(plot_eastern_hemlock$CCL))) +
  coord_cartesian(xlim = c(0, 100)) + # crop out "trees" with a negative crown ratio
  xlab("Crown Ratio (%)") +
  ylab("Canopy Height (feet)") +
  ggtitle("Eastern Hemlock Crown Ratio vs. Canopy Height by Crown Class")
  
```

```{r, eval = FALSE}
plot_eastern_hemlock <- eastern_hemlock |>
  filter(!is.na(CCL) & !is.na(CANOPY_HT) & !is.na(CDENCD)) |>
  # filter(CANOPY_HT > 30 & CANOPY_HT < 100) |>
  mutate(HT_GROUP = factor(as.integer(CANOPY_HT / 10) * 10))
missing_classes <- eastern_hemlock |> distinct(CCL) |>
  cross_join(plot_eastern_hemlock |> distinct(HT_GROUP)) |>
  anti_join(plot_eastern_hemlock |> distinct(HT_GROUP, CCL), by = join_by(HT_GROUP, CCL)) |>
  mutate(CDENCD = -10) # Give missing classes a negative crown ratio so it can be cropped out
plot_eastern_hemlock <- plot_eastern_hemlock |>
  select(HT_GROUP, CCL, CDENCD) |>
  union_all(missing_classes) |>
  mutate(CCL = factor(CCL, levels = rev(c("Open grown", "Dominant", "Codominant", "Intermediate", "Overtopped"))))

plot_eastern_hemlock_counts <- plot_eastern_hemlock |>
  group_by(HT_GROUP, CCL) |>
  summarize(COUNT = n(), CDENCD = mean(CDENCD), .groups = "keep") |>
  ungroup()

plot_eastern_hemlock |>
  ggplot(aes(CDENCD, HT_GROUP, fill = CCL)) +
  theme_bw() +
  geom_boxplot(outlier.size = 0.1) +
  geom_text(
    data = plot_eastern_hemlock_counts,
    mapping = aes(label = COUNT),
    position = position_dodge(width = .75),
    color = 'white'
  ) +
  scale_fill_discrete(name = "Crown Density", breaks = rev(levels(plot_eastern_hemlock$CCL))) +
  coord_cartesian(xlim = c(0, 100)) + # crop out "trees" with a negative crown ratio
  xlab("Crown Density (%)") +
  ylab("Canopy Height (feet)") +
  ggtitle("Eastern Hemlock Crown Density vs. Canopy Height by Crown Class")
  
```
