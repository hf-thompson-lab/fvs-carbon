---
title: "Nunery Keeton Revisited"
author: "Nikolaus Bates-Haus"
output:
  pdf_document: default
  html_document: default
editor_options:
  markdown:
    wrap: 72
---

```{r setup, include=FALSE}
# Pre-load libraries that issue warnings on startup so these
# warnings don't corrupt the text later.
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(reshape2)) # for melt()
suppressPackageStartupMessages(library(RSQLite))
suppressPackageStartupMessages(library(htmltools))
suppressPackageStartupMessages(library(rmarkdown))
suppressPackageStartupMessages(library(dbplyr))
suppressPackageStartupMessages(library(measurements))
suppressPackageStartupMessages(library(sf))
```

Load functions
```{r source-functions}
source('../R/functions.R')
```

## What species occur where?

What species are in which ecosubregion?

```{r}

# TREE.SPCD - species code
# FIADB_REFERENCE.REF_SPECIES.SPCD - species code
# FIADB_REFERENCE.REF_SPECIES.SCIENTIFIC_NAME / GENUS / SPECIES
# TREE.PLT_CN - Plot Control Number
# PLOT.CN - Plot Control Number
# PLOT.ECOSUBCD

fia_ref <- DBI::dbConnect(RSQLite::SQLite(), '../00_rawData/FIADB_REFERENCE.db')
fia_ref_species <- tbl(fia_ref, 'REF_SPECIES') |> 
  select(
    SPCD, SCIENTIFIC_NAME, GENUS, SPECIES, COMMON_NAME
  ) |> 
  collect()
dbDisconnect(fia_ref)


fia <- DBI::dbConnect(RSQLite::SQLite(), '../00_rawData/SQLite_FIADB_ENTIRE.db')

fia_tree <- tbl(fia, 'TREE') |> 
  distinct(PLT_CN, SPCD)

fia_plot <- tbl(fia, 'PLOT') |>
  select(CN, SRV_CN, ECOSUBCD) |>
  rename(PLT_CN = CN)

fia_survey <- tbl(fia, 'SURVEY') |>
  select(CN, RSCD) |>
  rename(SRV_CN = CN)

species_by_ecosubcd <- fia_tree |>
  left_join(fia_plot, by = join_by(PLT_CN)) |>
  left_join(fia_survey, by = join_by(SRV_CN)) |>
  northeastern_plots_filter() |>
  distinct(ECOSUBCD, SPCD) |>
  collect() |> 
  left_join(fia_ref_species, by = join_by(SPCD))

dbDisconnect(fia)
remove(fia, fia_tree, fia_plot, fia_survey, fia_ref, fia_ref_species)
```

## Creating Pixels

Use sf library, st_* functions
for each plot, create a 100x100 meter polygon centered at the location of the plot.
We can start with a 100x100 meter polygon at the equator.

As an interesting alternative, see https://gis.stackexchange.com/questions/403504/create-polygon-grid-based-on-spatial-points-wgs84-with-r -
the approach is to put the points on CRS84, re-project to something locally flat,
put the polygon on using distance measurements in the projection, then back-project
to CRS84.

For CRS for the various states, see this example:
```
library(rgdal)
epsg <- make_EPSG()
i <- grep("France", epsg$note, ignore.case=TRUE)
# first three
epsg[i[1:3], ]
##       code                                note
## 1399  2192           ED50 / France EuroLambert
## 2466 27561   NTF (Paris) / Lambert Nord France
## 2467 27562 NTF (Paris) / Lambert Centre France
```

Note that winding direction of polygons matters:
> Exterior ring boundaries must be oriented counterclockwise, and interior ring boundaries must be oriented clockwise.

```{r}
degrees_per_meter <- 360 / 40007862.87
half_edge <- 50 * degrees_per_meter
plot_geometry = matrix(
  # Note: winding direction matters!
  c(
    -half_edge, -half_edge,
     half_edge, -half_edge,
     half_edge,  half_edge,
    -half_edge,  half_edge,
    -half_edge, -half_edge
  ),
  ncol = 2,
  byrow = TRUE
)
plot_polygon <- st_sfc(st_polygon(list(plot_geometry)), crs = 'EPSG:4326')
stopifnot(st_is_valid(plot_polygon))
stopifnot(st_is_simple(plot_polygon))
st_area(plot_polygon)
```

Confirm that it's messed up:
```{r}
boston_loc <- c(42.360278, -71.057778) # Note: lat/lon
polygon_in_boston <- plot_polygon + boston_loc
# ^^^ why does this lose the CRS?
st_crs(polygon_in_boston) <- st_crs(plot_polygon)
st_area(polygon_in_boston)
```

...which is very wrong.

We can use st_distance to measure the distance between two points approximately
100 meters apart at the target location, and use that distance to determine
how many degrees we should use to get 100 meters per side.

At the equator, 0.001 degrees is about 111.17 meters, so if we offset by
+/- 0.0005 degrees we should end up with points "about" 100 meters apart
centered on the point of interest.

Note that the datum is an ellipsoid not a sphere, so we need to find the right
angle to subtend to get 100 meters in each of longitude and latitude.

Also also, from the sf docs:

> Why should we use OGC:CRS84 instead of EPSG:4326?

> EPSG:4326 formally defines coordinate axes to be in the order latitude-longitude, but practically all data sources and software environments use longitude-latitude axis order. OGC:CRS84 is equivalent to EPSG:4326 except that it defines coordinate axis order longitude-latitude, removing this ambiguity so to speak. See also st_axis_order()

```{r}
a <- st_sfc(st_point(boston_loc) + c(0.0005, 0), crs = 'EPSG:4326')
b <- st_sfc(st_point(boston_loc) + c(-0.0005, 0), crs = 'EPSG:4326')
fifty_meter_angle_lat <- 0.005 / as.numeric(st_distance(a, b))

c <- st_sfc(st_point(boston_loc) + c(0, 0.0005), crs = 'EPSG:4326')
d <- st_sfc(st_point(boston_loc) + c(0, -0.0005), crs = 'EPSG:4326')
fifty_meter_angle_lon <- 0.005 / as.numeric(st_distance(c, d))

# Note: winding direction matters!
boston_plot_geometry = matrix(
  c(
    boston_loc[1] - fifty_meter_angle_lat, boston_loc[2] - fifty_meter_angle_lon,
    boston_loc[1] + fifty_meter_angle_lat, boston_loc[2] - fifty_meter_angle_lon,
    boston_loc[1] + fifty_meter_angle_lat, boston_loc[2] + fifty_meter_angle_lon,
    boston_loc[1] - fifty_meter_angle_lat, boston_loc[2] + fifty_meter_angle_lon,
    boston_loc[1] - fifty_meter_angle_lat, boston_loc[2] - fifty_meter_angle_lon
  ),
  ncol = 2,
  byrow = TRUE
)
boston_plot_polygon <- st_sfc(st_polygon(list(plot_geometry)), crs = 'OGC:CRS84')
st_area(boston_plot_polygon)
```
