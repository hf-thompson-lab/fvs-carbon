---
title: "11_CFIGrowOnly"
output: html_document
---

# Setup

```{r setup, include=FALSE}
suppressPackageStartupMessages({
  library(targets)
  library(tarchetypes)
  library(tidyverse)
  library(readxl)
  library(terra)
  library(measurements)
  library(mlr3verse) # Machine Learning in R framework, larger universe
})
tar_source()
```

## Load targets results from other documents

```{r load tar objects, eval = FALSE}
tar_load(fiadb)
tar_load(fvsne_states)
tar_load(species_crosswalk)
tar_load(nrsgro_srvy_summary)
tar_load(nrshrv_plot)
tar_load(nrshrv_plot_stats)
tar_load(fvs_num_partitions)
tar_load(fvs_partition)
tar_load(fvs_randseed)
tar_load(nrsres_model)
```

## Preload targets results from this document

When tar_make() has already built the objects defined in this document,
run this block to pre-load them. You can then skip running ```{targets} blocks.

```{r load tar objects defined here, eval = FALSE}
get_this_rmd_file() |>
  tar_objects_defined_in_rmd() |>
  tar_load()
```


# Stands

Use the raw data from Department of Conservation & Recreation (DCR) Office of Watershed Management, Division of Water Supply Protection (DWSP)'s Continuous Forest Inventory (CFI).

We need stands (plots), visits (inventories), disturbances, and the lookup
table for disturbance codes.

In addition, (A. Barker Plotkin, et al. 2025) did a thorough analysis of the CFI data,
identifying 283 plots that were consistently surveyed and not relocated
from 1970 - 2020. We follow ABP where possible for this analysis.

```{targets cfiabp_trees}
tarchetypes::tar_file_read(
  cfiabp_trees,
  "data/raw/DWSP_CFI/trees283-6-defpropasp.csv",
  read_csv(!!.x)
)
```

```{targets tblDWSPCFIPlotsComplete}
tarchetypes::tar_file_read(
  tblDWSPCFIPlotsComplete,
  "data/raw/DWSP_CFI/tblDWSPCFIPlotsComplete.xlsx",
  read_excel(!!.x)
)
```

```{targets tblSuppPlotDisturbanceCodes}
tarchetypes::tar_file_read(
  tblSuppPlotDisturbanceCodes,
  "data/raw/DWSP_CFI/tblSuppPlotDisturbanceCodes.xlsx",
  read_excel(!!.x)
)
```

```{targets tblDWSPCFIPlotVisitDisturbances}
tarchetypes::tar_file_read(
  tblDWSPCFIPlotVisitDisturbances,
  "data/raw/DWSP_CFI/tblDWSPCFIPlotVisitDisturbances.xlsx",
  read_excel(!!.x) |>
    # Fix column name
    rename(
      PlotVisitDisturbanceYearCorrected = PlotVisitDisturbandYearCorrected,
      MasterPlotVisitID = PlotVisitID
    ) |>
    left_join(
      tblSuppPlotDisturbanceCodes |>
        select(DisturbanceCode, DisturbanceDesc),
      by = join_by(PlotVisitDisturbanceCode == DisturbanceCode)
    ) |>
    mutate(
      DisturbanceDesc = as.factor(DisturbanceDesc)
    )
)
```

```{targets tblDWSPCFIPlotVisitsComplete}
tarchetypes::tar_file_read(
  tblDWSPCFIPlotVisitsComplete,
  "data/raw/DWSP_CFI/tblDWSPCFIPlotVisitsComplete.xlsx",
  read_excel(!!.x)
)
```

```{targets tblSuppPlotForestrySubBasins}
tarchetypes::tar_file_read(
  tblSuppPlotForestrySubBasins,
  "data/raw/DWSP_CFI/tblSuppPlotForestrySubBasins.xlsx",
  read_excel(!!.x)
)
```

```{targets tblSuppTreeStatusCodes}
tarchetypes::tar_file_read(
  tblSuppTreeStatusCodes,
  "data/raw/DWSP_CFI/tblSuppTreeStatusCodes.xlsx",
  read_excel(
    !!.x,
    col_types = c(
      "numeric", "text", "numeric",
      "numeric", "numeric", "numeric",
      "numeric", "numeric", "numeric",
      "numeric", "numeric", "numeric",
      "numeric", "numeric", "numeric",
      "numeric", "numeric", "numeric",
      "numeric", "numeric"
    )
  )
)

```

```{targets qryDWSPCFIPlotVisitTreeDetail}
tarchetypes::tar_file_read(
  qryDWSPCFIPlotVisitTreeDetail,
  "data/raw/DWSP_CFI/qryDWSPCFIPlotVisitTreeDetail_Partial_HF.csv",
  read_csv(!!.x, col_types = list(.default = col_double())) |>
    # Fix column names
    rename(
      MasterTreeID = VisitMasterTreeID,
      MasterPlotVisitID = VisitIDNumberDetail
    ) |>
    left_join(
      tblSuppTreeStatusCodes |>
        select(StatusCode, TreeStatusDesc) |>
        rename(VisitTreeStatusCode = StatusCode),
      by = join_by(VisitTreeStatusCode)
    )
)
```

```{targets tblDWSPCFITreesComplete}
tarchetypes::tar_file_read(
  tblDWSPCFITreesComplete,
  "data/raw/DWSP_CFI/tblDWSPCFITreesComplete.xlsx",
  read_excel(!!.x)
)
```

## Elevation

LiDAR elevation maps are available from https://www.mass.gov/info-details/massgis-data-lidar-terrain-data#overview
These are in ERDAS IMAGINE (IMG) format.

Rather than download all tiles we can fetch the 31 tile index and determine
which tiles the plots are in.

```{r MassGIS DEM Tiles, eval=FALSE}
massgis_dem_tile_index <- vect(
  "data/raw/MassGIS/LIDARINDEX_DEMMOSTILES_POLY/LIDARINDEX_DEMMOSTILES_POLY.shp"
)
tblDWSPCFIPlotsComplete |>
  # Remove rows without lat/lon
  filter(!is.na(GPSLatitude) & !is.na(GPSLongitude)) |>
  # select an arbitrary row with lat/lon for each plot
  # we assume that lat/lon is consistent over time
  group_by(MasterPlotID) |>
  filter(row_number() == 1) |>
  ungroup() |>
  # Reshape the data for terra::vect()
  select(MasterPlotID, GPSLatitude, GPSLongitude) |>
  rename(
    lat = GPSLatitude,
    lon = GPSLongitude
  ) |>
  vect(crs = "EPSG:4326") |>
  # Re-project to match the tile index
  project(massgis_dem_tile_index) |>
  intersect(massgis_dem_tile_index) |>
  as.data.frame() |>
  distinct(TILE) |>
  arrange(TILE)
```

So, we need tiles 4, 12, 13 and 14.
Download those and unpack into data/raw/MassGIS.

Use terra::extract() to extract the elevation in feet for each plot from
the appropriate tile.

```{targets cfigro_plot_elevft, tar_simple = TRUE}
# Files for tile NN are named
# MassGIS/LidarElevation_YYYYtoZZZZ_NN/Lidar_Elevation_YYYYtoZZZZ_NN.img
# We'll keep this as a list and extract() each tile separately - this is
# much, MUCH faster than merging tiles with terra::merge() or terra::m
massgis_dem_tiles <- lapply(
  list.files("data/raw/MassGIS", pattern = "Lidar_Elevation_*"),
  \(tile) { rast(file.path("data/raw/MassGIS", tile, paste0(tile, ".img"))) }
)

tmp_plot_location <- tblDWSPCFIPlotsComplete |>
  # Remove rows without lat/lon
  filter(!is.na(GPSLatitude) & !is.na(GPSLongitude)) |>
  # select an arbitrary row with lat/lon for each plot
  # we assume that lat/lon is consistent over time
  group_by(MasterPlotID) |>
  filter(row_number() == 1) |>
  ungroup() |>
  # Reshape the data for terra::vect()
  select(MasterPlotID, GPSLatitude, GPSLongitude) |>
  rename(
    lat = GPSLatitude,
    lon = GPSLongitude
  ) |>
  vect(crs = "EPSG:4326") |>
  # Match the projection of the first tile
  project(massgis_dem_tiles[[1]])

# Build a dataframe with two columns:
# MasterPlotID, ELEVFT
# with one row per MasterPlotID
as.data.frame(tmp_plot_location) |>
  mutate(
    # Call extract() on each available tile; for plots that overlap
    # with that tile, we'll get back elevation, otherwise NA.
    # Coalesce across tiles to get the non-NA elevation for
    # each plot.
    ELEVFT = do.call(
      coalesce,
      lapply(massgis_dem_tiles, \(x) extract(x, tmp_plot_location)$FEET)
    )
  )
```

## County

MA county data is available from https://www.mass.gov/info-details/massgis-data-counties

Download those and unpack into data/raw/MassGIS/counties.

Use terra::intersect() to extract the county for each plot.

```{targets cfigro_plot_county, tar_simple = TRUE}
massgis_county <- vect("data/raw/MassGIS/counties/COUNTIES_POLY.shp")

tmp_countycd <- fia_tbl(fiadb, "COUNTY", \(.data, con) {
  .data |>
    filter(STATECD == 25) # Massachusetts has STATECD == 25
}) |>
  mutate(COUNTY = toupper(COUNTYNM)) |>
  select(COUNTY, COUNTYCD, STATECD)

tblDWSPCFIPlotsComplete |>
  # Remove rows without lat/lon
  filter(!is.na(GPSLatitude) & !is.na(GPSLongitude)) |>
  # select an arbitrary row with lat/lon for each plot
  # we assume that lat/lon is consistent over time
  group_by(MasterPlotID) |>
  filter(row_number() == 1) |>
  ungroup() |>
  # Reshape the data for terra::vect()
  select(MasterPlotID, GPSLatitude, GPSLongitude) |>
  rename(
    lat = GPSLatitude,
    lon = GPSLongitude
  ) |>
  vect(crs = "EPSG:4326") |>
  # Match the projection of the first tile
  project(massgis_county) |>
  intersect(massgis_county) |>
  as.data.frame() |>
  select(MasterPlotID, COUNTY) |>
  left_join(
    tmp_countycd,
    by = join_by(COUNTY)
  )
```

### FVS_LOCATION

While we're here, FVS wants a location, which is the nearest national forest.

We do this by:
1. Finding the geographic center of the Quabbin plots;
2. Finding the FIA plot closest to that geographic center;
3. Looking up the FVS_LOC_CD from that plot.

FVS national forests are far apart, so all the Quabbin plots will have
the same national forest.

```{r fvs location, eval = FALSE}
geo_ctr <- cfigro_plot |>
  group_by() |>
  summarize(
    lat_ctr = mean(LATITUDE, na.rm = TRUE),
    lon_ctr = mean(LONGITUDE, na.rm = TRUE)
  ) |>
  ungroup()
lat_ctr <- as.numeric(geo_ctr[["lat_ctr"]])
lon_ctr <- as.numeric(geo_ctr[["lon_ctr"]])

fia_tbl(fiadb, "PLOTGEOM", \(.data, con) {
  .data |>
    # We only need the first instance of each plot
    group_by(STATECD, COUNTYCD, PLOT) |>
    filter(row_number() == 1) |>
    ungroup() |>
    mutate(
      LAT_DELTA = abs(LAT - lat_ctr),
      LON_DELTA = abs(LON - lon_ctr),
      MANHATTAN = LAT_DELTA + LON_DELTA
    ) |>
    # The point with the shortest Euclidean distance will have Manhattan
    # distance less than twice the minimum Manhattan distance. We could
    # find a tighter upper bound, but there won't be many within 2 so
    # this is fine.
    filter(MANHATTAN < 2 * min(MANHATTAN, na.rm = TRUE)) |>
    mutate(DIST = sqrt(LAT_DELTA^2 + LON_DELTA^2)) |>
    arrange(DIST) |>
    head(1) |>
    left_join(
      tbl(con, "REF_FVS_LOC_NAME") |>
        select(FVS_LOC_CD, FVS_LOC_CD_NAME),
      by = join_by(FVS_LOC_CD)
    ) |>
    select(FVS_LOC_CD, FVS_LOC_CD_NAME)
})
```

FVS location 922, White Mountain National Forest

## Watershed

The DCR Division of Water Supply Protection (DWSP) maintains CFI plots
in the various reservoir watersheds as a means to manage water quality.

The plots in the Quabbin watershed (Watershed == 1) have a particularly
long history of high-quality data collection and responsible harvest, so
we will focus on just this watershed.

ABP plots are filtered to the Quabbin watershed.

## Relocation

Many plots were relocated prior to 1970, while retaining the same
MasterPlotID. To avoid analysis across this disjunction in trees,
we restrict analysis to 1970 and after.

ABP trees are filtered to non-relocated plot visits.

## Harvest

We would like to follow the FIA definition of harvest:

> 2.5.44 TRTCD1
> ... The area affected by the treatment must be at least 1 acre in size.

Sadly, we don't have access to the area affected.

For each tree, however, we do have access to information on whether it was cut.

FIA also defines harvest as:

> Appendix H: Damage Agent Codes and Thresholds
> 71000, Harvest, Removal of 10% cubic volume.

We likewise do not have volume, but can approximate this.

### FIA Observed

Question: is "Harvest == removal of >= 10% of biomass" consistent with what
is recorded in FIA? We have noted previously that FIA may mark a plot as
harvested when no trees are cut, and may mark a plot as not harvested when
many of its trees are cut, so cutting is an imperfect predictor of fia harvest.

FIA doesn't record biomass, but does record carbon, which is a good proxy.

```{r fia havest analysis, eval=FALSE}
# Sum the carbon of trees that were live pre-harvest
pre_harvest_carbon <- fia_trees(
    fiadb,
    nrshrv_plot_stats |> filter(PRE_HARVEST == 1)
  ) |>
  filter(STATUSCD == 1) |>
  filter_add_stand_id() |>
  select(STAND_ID, CARBON_AG, DIA, TPA_UNADJ) |>
  group_by(STAND_ID) |>
  summarize(
    CARBON_AG = sum(CARBON_AG, na.rm = TRUE),
    BALIVE_AG = sum(pi * (DIA / 2)^2, na.rm = TRUE)
  ) |>
  ungroup()

# Harvested trees don't get biomass, so we need to find their
# previous selves and get the biomass from there.
harvested_carbon <- fia_trees_by_cn(
    fiadb,
    fia_trees_filtered(
      fiadb,
      nrshrv_plot_stats |> filter(HARVEST == 1),
      \(.data, con) {
        .data |>
          filter(STATUSCD == 3) |>
          select(PREV_TRE_CN) |>
          rename(CN = PREV_TRE_CN)
      }
    )
  ) |>
  filter_add_stand_id() |>
  select(STAND_ID, CARBON_AG, DIA, TPA_UNADJ) |>
  group_by(STAND_ID) |>
  summarize(
    CARBON_HRV = sum(CARBON_AG, na.rm = TRUE),
    BALIVE_HRV = sum(pi * (DIA / 2)^2, na.rm = TRUE)
  ) |>
  ungroup()

fia_harvest_intensity <- pre_harvest_carbon |>
  inner_join(harvested_carbon, by = join_by(STAND_ID)) |>
  mutate(
    CARBON_PCT = 100 * CARBON_HRV / CARBON_AG,
    BALIVE_PCT = 100 * BALIVE_HRV / BALIVE_AG
  )

fia_harvest_intensity |>
  ggplot(aes(CARBON_PCT)) +
  geom_histogram(binwidth = 5) +
  geom_vline(xintercept = 10) +
  theme_bw() +
  ggtitle("Carbon Removal % in FIA harvested plots")

fia_harvest_intensity |>
  ggplot(aes(BALIVE_PCT)) +
  geom_histogram(binwidth = 5) +
  geom_vline(xintercept = 10) +
  theme_bw() +
  ggtitle("Basal Area Removal % in FIA harvested plots")

```

So, the vast majority of harvest is >= 10% of carbon. The distribution of
removal of basal area is about the same, so we'll use %BA removed as a proxy.

### DWSP CFI Tree Status

Let's look at individual tree status to help understand plot status:

```{r plot cfi tree status code, eval = FALSE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_abp(cfiabp_trees) |>
  mutate(TreeStatusDesc = ordered(
    TreeStatusDesc,
    levels = c("Live tree >=5.6\"", "standing dead", "fallen dead", "Out of population")
  )) |>
  ggplot(aes(VisitCycle, fill = fct_rev(TreeStatusDesc))) +
  geom_bar(position = "stack") +
  scale_fill_viridis_d(name = "Tree Status") +
  theme_bw() +
  ggtitle("DWSP CFI Tree Status by Visit Cycle") +
  ylab("Number of Trees") +
  xlab("Visit Cycle")
```

So TreeStatusDesc uses codes 1-4, back-propagated to prior visit cycles.

### ABP 2025 Tree Status

```{r plot abp tree status code, eval = FALSE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_abp(cfiabp_trees) |>
  mutate(
    Status6 = if_else(is.na(Status6), "X", Status6),
    StatusDesc = case_match(
      Status6,
      "L" ~ "Live",
      "R" ~ "Recruit",
      "D" ~ "Dead",
      "C" ~ "Cut",
      "X" ~ "Out of Population"
    ),
    StatusDesc = ordered(
      StatusDesc,
      levels = c("Recruit", "Live", "Dead", "Cut", "Out of Population")
    )
  ) |>
  ggplot(aes(VisitCycle, fill = fct_rev(StatusDesc))) +
  geom_bar(position = "stack") +
  scale_fill_viridis_d(name = "Tree Status") +
  theme_bw() +
  ggtitle("ABP 2025 Tree Status by Visit Cycle") +
  ylab("Number of Trees") +
  xlab("Visit Cycle")
```

### FIA vs. CFI Harvest

CFI defines CutAnyTime, which presumably includes pre-1970 harvest.
CutAnyTime seems to mean CutAnyTimePreviously, since individual plots
have multiple values.

We compute two harvest indicators:
- FIA Harvest - is more than 10% of the BA in "Cut" trees
- CFI Harvest - is CutSinceLastVisit ever TRUE

```{targets cfigro_plot_harvested, tar_simple = TRUE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_abp(cfiabp_trees) |>
  cfi_harvested()
```


```{r plot cfigro_plot_harvested, eval = FALSE}
cfigro_plot_harvested |>
  mutate(
    HarvestType = case_when(
      FIAHarvested & CFIHarvested ~ "Both",
      FIAHarvested ~ "FIA",
      CFIHarvested ~ "CFI",
      .default = "Neither"
    )
  ) |>
  ggplot(aes(HarvestType)) +
  geom_bar() +
  geom_text(aes(y = after_stat(count + 5), label = after_stat(count)), stat = "count") +
  theme_bw() +
  ggtitle("FIA vs CFI Plot Harvest Status") +
  ylab("Number of Plots")
```

Defined in cfi_harvested()

## Disturbance

We would like to follow the FIA definition of disturbance:

> 2.5.38 DSTRBCD1
>
> The area affected by the disturbance must be at least 1 acre in size. A
> significant level of disturbance (mortality or damage to 25 percent of the trees
> in the condition) is required.

Sadly, we don't have access to the area affected, or to damage separate from
mortality.

CFI does provide a disturbance flag, and starting in 2010 a disturbance
intensity.

Disturbance Severity code:

- 1 - Light
- 2 - Moderate
- 3 - Severe

Ignoring light disturbance seems in-line with FIA definition, so we will
flag plots with Moderate to Severe disturbance.

Notable disturbance codes:

- 0: None
- 10: Harvest Cut

It looks like disturbances > 10 are not currently used. We also wish to
distinguish between harvest and other disturbance, so we won't mark things
with distrubance code 10 as disturbed.

Note that we need PlotVisits to get from Disturbance to Plots.

### Harvest vs. Non-Harvest Disturbance Types

```{r disturbance types, eval = FALSE}
tblSuppPlotDisturbanceCodes |>
  mutate(DisturbanceCategory = case_when(
    DisturbanceCode == 0 ~ "None",
    DisturbanceCode %in% c(8, 9, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22) ~
      "Harvest Related",
    .default = "Non-Harvest"
    )
  ) |>
  select(DisturbanceCode, DisturbanceCategory, DisturbanceDesc)
```

### Disturbance History

```{r plot disturbance type, eval = FALSE}
tblDWSPCFIPlotVisitDisturbances |>
  left_join(
    tblDWSPCFIPlotVisitsComplete |>
      distinct(MasterPlotVisitID, MasterPlotID, VisitYear, VisitCycle),
    by = join_by(MasterPlotVisitID)
  ) |>
  # Remove harvest and harvest-related disturbances
  filter(!PlotVisitDisturbanceCode %in% c(0, 8, 9, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22)) |>
  filter(
    PlotVisitDisturbanceYearCorrected >= VisitYear - 10 &
      PlotVisitDisturbanceYearCorrected < 9999 &
      (is.na(PlotVisitDisturbanceSeverity) | PlotVisitDisturbanceSeverity > 1)
  ) |>
  inner_join(
    cfiabp_trees |> distinct(MasterPlotID, VisitCycle),
    by = join_by(MasterPlotID, VisitCycle)
  ) |>
  mutate(DisturbanceDesc = factor(DisturbanceDesc)) |>
  ggplot(aes(PlotVisitDisturbanceYearCorrected, fill = DisturbanceDesc)) +
  geom_bar() +
  ggtitle("CFI Plot Disturbance Type by Year") +
  xlab("Year of Disturbance") +
  ylab("Number of Plots") +
  theme_bw()
```

```{r cfi plot disturbance history, eval = FALSE}
plotNum <- cfiabp_trees |>
  distinct(MasterPlotID) |>
  arrange(MasterPlotID) |>
  mutate(plot_num = row_number())

tblDWSPCFIPlotVisitDisturbances |>
  left_join(
    tblDWSPCFIPlotVisitsComplete |>
      distinct(MasterPlotVisitID, MasterPlotID, VisitYear, VisitCycle),
    by = join_by(MasterPlotVisitID)
  ) |>
  filter(PlotVisitDisturbanceCode != 0) |>
  # Remove harvest and harvest-related disturbances
  #mutate(PlotVisitDisturbanceCode = if_else(PlotVisitDisturbanceCode %in% c(8, 9, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22), 9, PlotVisitDisturbanceCode)) |>
  filter(
    PlotVisitDisturbanceYearCorrected >= VisitYear - 10 &
      #PlotVisitDisturbanceYearCorrected >= 1970 &
      PlotVisitDisturbanceYearCorrected < 9999 &
      (is.na(PlotVisitDisturbanceSeverity) | PlotVisitDisturbanceSeverity > 1)
  ) |>
  inner_join(
    cfiabp_trees |> distinct(MasterPlotID, VisitCycle),
    by = join_by(MasterPlotID, VisitCycle)
  ) |>
  left_join(
    plotNum,
    by = join_by(MasterPlotID)
  ) |>
  mutate(DisturbanceDesc = factor(DisturbanceDesc)) |>
  full_join(
    expand_grid(plot_num = 1:283, PlotVisitDisturbanceYearCorrected = 1960:2021),
    by = join_by(plot_num, PlotVisitDisturbanceYearCorrected)
  ) |>
  group_by(plot_num) |>
  arrange(PlotVisitDisturbanceYearCorrected) |>
  fill(DisturbanceDesc, .direction = "down") |>
  ungroup() |>
  filter(!is.na(DisturbanceDesc)) |>
  ggplot(aes(PlotVisitDisturbanceYearCorrected, plot_num, color = DisturbanceDesc)) +
  geom_point() +
  scale_y_continuous(breaks = 0:6 * 50, minor_breaks = 1:30 * 10) +
  scale_color_discrete(name = "Most Recent\nDisturbance") +
  ggtitle("Quabbin Plots CFI Disturbance") +
  xlab("Year") +
  ylab("Plot") +
  theme_bw()
```

### CFI Plot Disturbance

```{targets cfigro_plot_disturbed, tar_simple = TRUE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_abp(cfiabp_trees) |>
  cfi_disturbed(tblDWSPCFIPlotVisitDisturbances)
```

```{r plot cfi plot disturbance, eval = FALSE}
cfigro_plot_disturbed |>
  ggplot(aes(CFIDisturbed)) +
  geom_bar()
```

So, how many plots are unharvested and undisturbed?

```{r plot cfi status, eval = FALSE}
cfiabp_trees |>
  distinct(MasterPlotID) |>
  left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
  left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
  mutate(
    Status = case_when(
      FIAHarvested & CFIDisturbed ~ "Harvested & Disturbed",
      FIAHarvested ~ "Harvested",
      CFIDisturbed ~ "Disturbed",
      .default = "Neither"
    )
  ) |>
  ggplot(aes(Status)) +
  geom_bar() +
  geom_text(aes(y = after_stat(count + 5), label = after_stat(count)), stat = "count") +
  theme_bw() +
  ggtitle("CFI Plots by Status") +
  ylab("Number of Plots")
```



### FIA Disturbance

FIA marks a plot as disturbed if more than an acre is impacted, and >25% of
stems in that acre show damage or mortality.

Using ">25% mortality", we get many fewer disturbed plots:

```{r plot fia disturbance, eval = FALSE}
cfigro_plot_disturbed |>
  ggplot(aes(FIADisturbed)) +
  geom_bar()
```


Using this definition, how many plots are neither harvested nor disturbed?

So, how many plots are unharvested and undisturbed by this metric?

```{r plot fia status, eval = FALSE}
cfiabp_trees |>
  distinct(MasterPlotID) |>
  left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
  left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
  mutate(
    Status = case_when(
      FIAHarvested & FIADisturbed ~ "Harvested & Disturbed",
      FIAHarvested ~ "Harvested",
      FIADisturbed ~ "Disturbed",
      .default = "Neither"
    )
  ) |>
  ggplot(aes(Status)) +
  geom_bar() +
  geom_text(aes(y = after_stat(count + 5), label = after_stat(count)), stat = "count") +
  theme_bw() +
  ggtitle("CFI Plots by FIA Status") +
  ylab("Number of Plots")
```

### Longest Undisturbed Period


```{r fia plot disturbance history, eval = FALSE}
tblDWSPCFIPlotVisitDisturbances |>
  left_join(
    tblDWSPCFIPlotVisitsComplete |>
      distinct(MasterPlotVisitID, MasterPlotID, VisitYear, VisitCycle),
    by = join_by(MasterPlotVisitID)
  ) |>
  # Remove harvest and harvest-related disturbances
  # filter(!PlotVisitDisturbanceCode %in% c(8, 9, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22)) |>
  filter(
    PlotVisitDisturbanceYearCorrected >= VisitYear - 10 &
      PlotVisitDisturbanceYearCorrected >= 1970 &
      PlotVisitDisturbanceYearCorrected < 9999 &
      (is.na(PlotVisitDisturbanceSeverity) | PlotVisitDisturbanceSeverity > 1)
  ) |>
  full_join(
    cfiabp_trees |> distinct(MasterPlotID, VisitCycle),
    by = join_by(MasterPlotID, VisitCycle)
  ) |>
  inner_join(
    cfiabp_trees |> distinct(MasterPlotID, VisitCycle),
    by = join_by(MasterPlotID, VisitCycle)
  ) |>
  mutate(PlotVisitDisturbanceCode = replace_na(PlotVisitDisturbanceCode, 0)) |>
  group_by(MasterPlotID, VisitCycle) |>
  summarize(PlotVisitDisturbanceCode = max(PlotVisitDisturbanceCode, na.rm = TRUE), .groups = "drop") |>
  mutate(
    undisturbed_interval = if_else(
      PlotVisitDisturbanceCode > 0, 0,
      if_else(
        VisitCycle == 1970, 1, NA
      )
    )
  ) |>
  group_by(MasterPlotID) |>
  arrange(VisitCycle) |>
  mutate(
    undisturbed_interval = case_when(
      !is.na(undisturbed_interval) ~ undisturbed_interval,
      VisitCycle == 1980 ~ lag(undisturbed_interval) + 1
    )
  ) |>
  mutate(
    undisturbed_interval = case_when(
      !is.na(undisturbed_interval) ~ undisturbed_interval,
      VisitCycle == 1990 ~ lag(undisturbed_interval) + 1
    )
  ) |>
  mutate(
    undisturbed_interval = case_when(
      !is.na(undisturbed_interval) ~ undisturbed_interval,
      VisitCycle == 2000 ~ lag(undisturbed_interval) + 1
    )
  ) |>
  mutate(
    undisturbed_interval = case_when(
      !is.na(undisturbed_interval) ~ undisturbed_interval,
      VisitCycle == 2010 ~ lag(undisturbed_interval) + 1
    )
  ) |>
    mutate(
    undisturbed_interval = case_when(
      !is.na(undisturbed_interval) ~ undisturbed_interval,
      VisitCycle == 2020 ~ lag(undisturbed_interval) + 1
    )
  ) |>
  ungroup() |>
  group_by(MasterPlotID) |>
  summarize(MaxUndisturbInterval = max(undisturbed_interval), .groups = "drop") |>
  filter(!is.na(MaxUndisturbInterval)) |>
  ggplot(aes(MaxUndisturbInterval)) +
  geom_bar() +
  theme_bw() +
  ggtitle("Number of Plots by Undisturbed Interval") +
  ylab("Number of Plots") +
  xlab("Visits witout disturbance")

```

## Break Diameter

At what diameter do trees ingrow?

DSWP_CFI_METADATA_Appendix_Final, table 22B Tree Status Codes, shows the
varied history of break diameter:
- >= 5.6"
- > 4.9" (>= 5.0")
- > 5.5" (>= 5.6")
- > 5.9" (>= 6.0")


```{r ingrowth diameter over time, eval = FALSE}
qryDWSPCFIPlotVisitTreeDetail |>
  filter(VisitTreeDIAM > 0) |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
  left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
  mutate(IngrowthClass = case_when(
    VisitTreeDIAM < 5 ~ "< 5\"",
    VisitTreeDIAM < 5.6 ~ "< 5.6\"",
    VisitTreeDIAM < 6.0 ~ "< 6\""
  )) |>
  filter(!is.na(IngrowthClass)) |>
  ggplot(aes(VisitTreeDIAM)) +
  geom_histogram(binwidth = 0.1) +
  scale_y_continuous(transform = "log10") +
  coord_cartesian(xlim = c(4.5, 6.0))
```

Minimum diameter is 4.5" - this is important for BRK_DBH - trees smaller
than BRK_DBH will be on the microplot, and will get the microplot TPA
multiplier (385), rather than the plot multiplier (5). There is a history
of using different diameters in different CFI inventories.

From 1970 - 2020, only 2 trees establish on grow-only plots with DIAM < 5.6".

We will use 5" as BRK_DBH, and filter out trees with diameter < 5.

## Grow-Only vs. Harvested vs. Disturbed

How distinct are grow-only, disturbed, harvested and harvested/disturbed plots?

```{r plot comparison by status, eval = FALSE}
tmp_trees <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  filter(VisitCycle == 1970) |>
  filter(cfi_status_live(VisitTreeStatusCode)) |> # Only Live Trees
  left_join(
    species_crosswalk |> select(SPCD, SCIENTIFIC_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    TPA = conv_unit(5, "hectare", "acre"),
    BA = TPA * pi * conv_unit(VisitTreeDIAM / 2, "in", "m")^2,
  )

tmp_by_quabbin <- tmp_trees |>
  group_by() |>
  summarize(
    TPA = sum(TPA, na.rm = TRUE),
    BA = sum(BA, na.rm = TRUE),
    .groups = "drop"
  )

tmp_by_species <- tmp_trees |>
  group_by(SCIENTIFIC_NAME) |>
  summarize(
    TPA = sum(TPA, na.rm = TRUE),
    BA = sum(BA, na.rm = TRUE),
    .groups = "drop"
  )

tmp_by_plot <- tmp_trees |>
  group_by(MasterPlotID) |>
  summarize(
    TPA = sum(TPA, na.rm = TRUE),
    BA = sum(BA, na.rm = TRUE),
    .groups = "drop"
  )

tmp_top_species <- tmp_by_species |>
  cross_join(tmp_by_quabbin |> select(BA_Total = BA)) |>
  mutate(BA_Frac = BA / BA_Total) |>
  filter(BA_Frac > 0.1)

tmp_plot_species <- tmp_trees |>
  left_join(
    tmp_by_plot |>
      select(MasterPlotID, BA_Plot = BA),
    by = join_by(MasterPlotID)
  ) |>
  group_by(MasterPlotID, SCIENTIFIC_NAME) |>
  mutate(BA_Frac = sum(BA, na.rm = TRUE) / BA_Plot) |>
  ungroup() |>
  filter(BA_Frac > 0.1) |>
  filter(SCIENTIFIC_NAME %in% tmp_top_species$SCIENTIFIC_NAME) |>
  distinct(MasterPlotID, SCIENTIFIC_NAME) |>
  group_by(MasterPlotID) |>
  summarize(
    Species = do.call(
      paste,
      append(sort(SCIENTIFIC_NAME), list(sep = ", "))
    ),
    .groups = "drop"
  )

tmp_trees |>
  group_by(MasterPlotID) |>
  summarize(
    TPA = sum(TPA, na.rm = TRUE),
    BA = sum(BA, na.rm = TRUE),
    .groups = "drop"
  ) |>
  ungroup() |>
  left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
  left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
  left_join(tmp_plot_species, by = join_by(MasterPlotID)) |>
  mutate(
    Species = if_else(is.na(Species), "Other", Species),
    Status = case_when(
      CFIHarvested & CFIDisturbed ~ "Harvested & Disturbed",
      CFIHarvested ~ "Harvested",
      CFIDisturbed ~ "Disturbed",
      .default = "Grow-Only"
    )
  ) |>
  ggplot(aes(BA, TPA, color = Status)) +
  geom_point() +
  scale_color_manual( values = c(
    "Grow-Only" = "black",
    "Harvested" = "red",
    "Disturbed" = "royalblue",
    "Harvested & Disturbed" = "orange"
  )) +
  scale_x_continuous(transform = "log10") +
  scale_y_continuous(transform = "log10") +
  theme_bw() +
  ggtitle("CFI Plot Overview") +
  xlab(bquote("Basal Area" ~ (m^2 %.% hectare^-1))) +
  ylab(bquote("Population" ~ (stems %.% hectare^-1))) +
  facet_wrap("Species")
```

It looks like there is hope for matching most disrupted plots to
grow-only plots; 

## Final Formatting

put it in the right shape for FVS.
When FVS processes a stand from FIA data, it says things like
(omitting WAS IGNORED columns):

```
SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'

STAND-LEVEL DATA BASE READ:
  INV_YEAR:               2006 - VisitYear 
  REGION:                    9 - Keep it 9
  FOREST:                   20 - Nearest national forest / ranger district, 20 is Green Mountains
   COMPOSITE LOC:          920 - - See FVSne_Overview 3.1 Location Codes
  LOCATION:                920 - - See FVSne_Overview 3.1 Location Codes
  LONGITUDE:          -73.3379 - GPSLatitude
  LATITUDE:            41.2770 - GPSLongitude
  AGE:                      74 - ??? No Age
  ASPECT:                  6.0 - Aspect
  SLOPE:                  5.00 - Slope; CFI is probably %; FVS wants percent
  ELEVFT:                520.0 CONVERTED TO:    5.2 - join from MassGIS data
  BASAL_AREA_FACTOR:     -24.0 - plot radius for fixed-radius plot; 52.7
  INV_PLOT_SIZE:          300. - plot radius for fixed-size microplot; 6
  BRK_DBH:                 5.0 - Sapling / Tree DBH break; see above
  NUM_PLOTS:                 4 - Number of subplots; 1
  SAM_WT:          6321.345703 - Sample Weight (acres) - not used by FVS
  PHYSIO_REGION:            23 - maybe from fiadb 2.3.35 Physiographic Class; use forest type instead
  STATE:                     9 - State - fill in properly - 25
  COUNTY:                    1 - County - fill in properly - use MassGIS counties
END OF DATA BASE READ.
```

From the manual:
- Plots are 52.7' fixed-radius plots, which is 0.2 acre (0.2003011)
- Four, six-foot radius subplots are taken on each CFI pot along the cardinal directions, 26' from plot center.
- Size classes:
  - 1 - less than one foot in height
  - 2 - 1' to 4.5' in height
  - 3 - 4.5' to 1.0" DBH
  - 4 - 1" to 5" dbh
- Seedlings less than one foot in height (class 1) and thos 1' to 4.5' in height
  (class 2) are counted individually up to ten and in groups of ten (11 to 20 = 20, etc.)
  when their number exceeds ten.
- For the other sizes [sic] classes (3 and 4), individual stems are recorded.

Site index is recorded, but we don't seem to have it. We'll use the limited height
info we have to calibrate FVS.

It looks like forest type / ecoregion will be used if present

ForestTypeDesc might be available - see appendix.

STAND_CN - MasterPlotVisitID
STAND_ID - MasterPlotID
VARIANT - NE
INV_YEAR / INV_MONTH / INV_DAY - VisitMeasuredDate
LATITUDE / LONGITUDE - GPSLatitude / GPSLongitude
DATUM - NA
REGION - 20
FOREST - 920
DISTRICT - ?
ECOREGION - can maybe get this
AGE - ?
ASPECT - ASPECT
SLOPE - SLOPE
ELEVATION - ?
ELEVFT - ELEVATION
INV_PLOT_SIZE - -52.7
BRK_DBH - 5
NUM_PLOTS - 1
SITE_SPECIES - ?
SITE_INDEX - ?
SITE_INDEX_BASE_AG - ?
FOREST_TYPE_FIA - ?
STATE - 25
COUNTY - COUNTY

```{targets cfigro_plot, tar_simple = TRUE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  group_by(MasterPlotID) |>
  mutate(
    FIRST_YEAR = VisitYear,
    LAST_YEAR = max(VisitYear, na.rm = TRUE)
  ) |>
  arrange(VisitCycle) |>
  filter(row_number() == 1) |>
  ungroup() |>
  left_join(
    cfigro_plot_elevft,
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    cfigro_plot_county,
    by = join_by(MasterPlotID)
  ) |>
  mutate(
    STAND_CN = as.character(MasterPlotVisitID),
    STAND_ID = MasterPlotID,
    INV_YEAR = VisitYear,
    REGION = 9,
    FOREST = 22,
    LONGITUDE = GPSLongitude,
    LATITUDE = GPSLatitude,
    AGE = NA,
    ASPECT = Aspect,
    SLOPE = Slope,
    ELEVFT = ELEVFT,
    BASAL_AREA_FACTOR = -5, # 52.7' = 1/5 acre; negative means fixed radius
    INV_PLOT_SIZE = 385, # Microplot area, in inverse fraction of an acre
    BRK_DBH = 5, # ABP uses 6" for break diameter; see ABP 2025
    NUM_PLOTS = 1,
    SAM_WT = 0.2,
    STATE = STATECD,
    COUNTY = COUNTYCD
  ) |>
  select(
    STAND_CN, STAND_ID, INV_YEAR, REGION, STATE, COUNTY, FOREST,
    LONGITUDE, LATITUDE, ASPECT, SLOPE, ELEVFT, AGE,
    BASAL_AREA_FACTOR, INV_PLOT_SIZE, BRK_DBH, NUM_PLOTS,
    SAM_WT, FIRST_YEAR, LAST_YEAR
  )
```

# Trees

It looks like pretty much everything is in the ABP table.
When comparing current to previous status, and for diameter and 
height growth, the VisitTree* values are more densely populated
which works better for change-over-time calculations.

```
SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'
  PLOT_ID            WAS USED - MasterPlotID
  TREE_ID            WAS USED - MasterTreeID
  TREE_COUNT         WAS USED - stemsha.L6
  HISTORY            WAS USED - status.prior6 - no, use VisitTreeStatusCode, except for harvest
  SPECIES            WAS USED - genusp - swizzle through crosswalk
  DIAMETER           WAS USED - dbhcm - no, use VisitTreeDIAM
  HT                 WAS USED - VisitTreeTotalHeight
  HTTOPK             WAS USED - :-(
  CRRATIO            WAS USED - :-( - maybe in supplement; see appendix
  DAMAGE1            WAS USED - X
  SEVERITY1          WAS USED - X
  DAMAGE2            WAS USED - X
  SEVERITY2          WAS USED - X
  DAMAGE3            WAS USED - X
  SEVERITY3          WAS USED - X
  TREEVALUE          WAS USED - X - tree removal priority
  PRESCRIPTION       WAS USED - X - tree removal group
  AGE                WAS USED - X
  SLOPE              WAS USED - Slope
  ASPECT             WAS USED - Aspect
  PV_CODE            WAS USED - ecoregion? - not used
  TOPOCODE           WAS USED - ?
  SITEPREP           WAS USED - ?
  DG                 WAS USED - Diameter growth - dbh.prior.cm; no, use lag(VisitTreeDIAM)
  HTG                WAS USED - height growth - lag(VisitTreeTotalHeight)
NUMBER ROWS PROCESSED:   30
```

FVS TOPOCODE:
1 = bottom
2 = lower slope
3 = mid-slope
4 = upper slope
5 = ridge top

CFI Terrain Position:
1 = Top of slope; convex region.
2 = Upper slope; convex region at upper edge of slope.
3 = Mid-slope; uniform, fairly straight region.
4 = Bench; area of level land with slopes above and below.
5 = Lower slope; concave region at the lower edge of slope.
6 = Bottomland; horizontal region in low-lying areas, may be subject to occasional flooding.
7 = Flatland; regions not part of or related to slopes; may have minimal elevation changes - less than 5% slope.

```{targets cfigro_trees, tar_simple = TRUE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  filter(VisitTreeStatusCode != 4) |> # Skip missing trees
  cfi_abp(cfiabp_trees) |>
  group_by(MasterPlotID, MasterTreeID) |>
  arrange(VisitCycle) |>
  mutate(
    PreviousStatus6 = lag(Status6),
    PreviousDIAM = lag(VisitTreeDIAM),
    PreviousHeight = lag(VisitTreeTotalHeight)
  ) |>
  ungroup() |>
  cfi_topocode() |>
  cfi_history() |>
  left_join(
    species_crosswalk |> select(SPCD, FVS_SPCD),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    STAND_CN = as.character(MasterPlotVisitID),
    STAND_ID = MasterPlotID,
    TREE_CN = as.character(VisitTreeNumberDetail),
    TREE_ID = MasterTreeID,
    PLOT_ID = 1, # CFI does not use subplots, so all PLOT_IDs are 1
    INV_YEAR = VisitYear,
    TREE_COUNT = 1, #conv_unit(1, "acre", "ft2") / (pi * 52.7^2),
    HISTORY = HISTORY,
    SPECIES = FVS_SPCD,
    DIAMETER = VisitTreeDIAM,
    HT = VisitTreeTotalHeight,
    # HTTOPK = VisitTreeTotalHeight, # Height to top kill; we don't ahve that
    # CRRATIO            WAS USED - not available
    # DAMAGE1            WAS USED - not available
    # SEVERITY1          WAS USED - not available
    # DAMAGE2            WAS USED - not available
    # SEVERITY2          WAS USED - not available
    # DAMAGE3            WAS USED - not available
    # SEVERITY3          WAS USED - not avialable
    # TREEVALUE          WAS USED - X - tree removal priority
    # PRESCRIPTION       WAS USED - X - tree removal group
    # AGE                WAS USED - X
    SLOPE = Slope,
    ASPECT = Aspect,
    # PV_CODE            WAS USED - ecoregion? - not used
    TOPOCODE = TOPOCODE, # See EssentialFVS 5.4.1.2
    # SITEPREP           WAS USED - ?
    DG = PreviousDIAM,
    HTG = PreviousHeight
  ) |>
  select(
    STAND_CN, STAND_ID, TREE_CN, TREE_ID, PLOT_ID,
    TREE_COUNT, HISTORY, SPECIES, DIAMETER, HT,
    SLOPE, ASPECT, TOPOCODE, DG, HTG
  )
```

## DWSCFI Observations

Where does that land us in terms of growth?

Look at stand-level BA over time:

```{r plot dwscfi ba, eval = FALSE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
  left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
  filter(!CFIHarvested & !CFIDisturbed) |>
  group_by(MasterPlotID, VisitYear) |>
  summarize(BA = sum(pi * (VisitTreeDIAM/24)^2, na.rm = TRUE), .groups = "drop") |>
  mutate(
    MasterPlotID = factor(MasterPlotID),
    BA_METRIC = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")
  ) |>
  ggplot(aes(VisitYear, BA_METRIC, color = MasterPlotID)) +
  geom_line() +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none") +
  ggtitle("DCR CFI Quabbin Grow-Only Plots Observed BA") +
  ylab(bquote("BA" ~ (m^2 %.% hectare^-1)))

```


And stand-level stem density over time:

```{r plot dwscfi tpa, eval = FALSE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
  left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
  filter(!CFIHarvested & !CFIDisturbed) |>
  group_by(MasterPlotID, VisitYear) |>
  summarize(TPA = n() * conv_unit(1, "acre", "ft2") / (pi * 52.7^2), .groups = "drop") |>
  mutate(
    MasterPlotID = factor(MasterPlotID)
  ) |>
  ggplot(aes(VisitYear, TPA, color = MasterPlotID)) +
  geom_line() +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none") +
  ggtitle("DCR CFI Quabbin Grow-Only Plots Observed TPA") +
  ylab("TPA")

```


# Regeneration & Calibration

We can build the tables for regeneration and calibration from CFI data for FVS

## Regeneration

We need two things:
- For each plot, for each species, how many trees ingrow from 1970 to 2020?
- For each of those trees, what is its height at the time of ingrowth?

We'll give FVS data in the form of:
- STAND_CN (MasterPlotVisitID)
- SPECIES (FVS_SPCD)
- DENSITY (TPA)
- HEIGHT (FT)

Let's make sure we don't have meaningful height information:

```{r cfi height availability, eval = FALSE}
qryDWSPCFIPlotVisitTreeDetail |>
  filter(VisitTreeDIAM >= 5) |> # There are a few <5"
  filter(!is.na(VisitTreeTotalHeight)) |>
  # We need MasterPlotID and VisitCycle to join with ABP trees
  left_join(
    tblDWSPCFIPlotVisitsComplete |>
      select(MasterPlotID, VisitCycle, MasterPlotVisitID),
    by = join_by(MasterPlotVisitID)
  ) |>
  # Filter to ABP trees
  inner_join(
    cfiabp_trees |> distinct(MasterPlotID, VisitCycle, MasterTreeID, StatusB, dbhcm),
    by = join_by(MasterPlotID, VisitCycle, MasterTreeID)
  ) |>
  group_by(MasterPlotID, MasterTreeID) |>
  arrange(VisitCycle) |>
  mutate(PreviousTreeStatusCode = lag(VisitTreeStatusCode)) |>
  ungroup() |>
  mutate(Recruit = if_else(
    is.na(PreviousTreeStatusCode),
    "Recruit",
    "Existing")
  ) |>
  filter(VisitCycle > 1970 & VisitTreeStatusCode == 1) |>
  select(VisitTreeDIAM, VisitTreeTotalHeight, Recruit, StatusB) |>
  ggplot(aes(VisitTreeDIAM)) +
  geom_histogram(binwidth = 1) +
  facet_wrap("StatusB") +
  theme_bw() +
  ggtitle("DBH at time of height measurement") +
  xlab("Diameter (in)") +
  ylab("Number of Trees")
```

Amazing! It looks like we have heights for lots of trees in the 5-6" DBH
range! And lots of those are recruits.

For how many recruits do we _not_ have height?

```{r cfi height for recruites, eval = FALSE}
qryDWSPCFIPlotVisitTreeDetail |>
  # We need MasterPlotID and VisitCycle to join with ABP trees
  left_join(
    tblDWSPCFIPlotVisitsComplete |>
      select(MasterPlotID, VisitCycle, MasterPlotVisitID),
    by = join_by(MasterPlotVisitID)
  ) |>
  # Filter to ABP trees
  inner_join(
    cfiabp_trees |> distinct(MasterPlotID, VisitCycle, MasterTreeID),
    by = join_by(MasterPlotID, VisitCycle, MasterTreeID)
  ) |>
  group_by(MasterPlotID, MasterTreeID) |>
  arrange(VisitCycle) |>
  mutate(PreviousTreeStatusCode = lag(VisitTreeStatusCode)) |>
  ungroup() |>
  # We are interested in trees that establish after 1970
  filter(VisitCycle > 1970 & !is.na(PreviousTreeStatusCode) & PreviousTreeStatusCode == 1) |>
  mutate(HasHeight = if_else(
      is.na(VisitTreeTotalHeight),
      "No Height",
      "Height"
    )
  ) |>
  select(VisitTreeDIAM, HasHeight) |>
  ggplot(aes(HasHeight)) +
  geom_bar() +
  theme_bw() +
  ggtitle("Do CFI recruits have height") +
  ylab("Number of Trees")
```

Most recruits do not have height.

So, we'll attempt to use observed heights, and supplement with plot and
regional heights when necessary.

Most ingrowth is recorded at 5.6" DBH; some is at 5.4", and some at 5.9".
We'll use 5.6" as the target diameter for height estimation, then adjust
for individual trees in the regen table.

```{targets cfigro_estab, tar_simple = TRUE}
cycle_length <- 10
plots_per_acre <- 5
survey_period <- 50
minimum_sane_height_for_a_5inch_dbh_tree <- 10

# Trees to use for modeling height estimation
qryDWSPCFIPlotVisitTreeDetail |>
  filter(VisitTreeStatusCode == 1) |>
  left_join(
    tblDWSPCFIPlotVisitsComplete |>
      select(MasterPlotID, VisitCycle, MasterPlotVisitID),
    by = join_by(MasterPlotVisitID)
  ) |>
  left_join( 
    tblDWSPCFITreesComplete |> select(MasterTreeID, SpeciesCode),
    by = join_by(MasterTreeID)
  ) |>
  inner_join(
    cfiabp_trees |> distinct(MasterPlotID, VisitCycle, MasterTreeID, StatusB),
    by = join_by(MasterPlotID, VisitCycle, MasterTreeID)
  ) |>
  filter(VisitCycle >= 1970) |>
  filter(StatusB == "R") |> 
  # Remove suspicious heights
  mutate(VisitTreeTotalHeight = if_else(VisitTreeTotalHeight < 10, NA, VisitTreeTotalHeight)) |>
  group_by(SpeciesCode) |>
  mutate(SPECIES_MIN_HT = min(VisitTreeTotalHeight, na.rm = TRUE), .groups = "keep") |>
  ungroup() |>
  group_by(MasterPlotID, SpeciesCode) |>
  summarize(
    DENSITY = n() * plots_per_acre * cycle_length / survey_period, # Stems per acre per 10-year interval
    HEIGHT = min(VisitTreeTotalHeight, na.rm = TRUE),
    SPECIES_MIN_HT = min(SPECIES_MIN_HT)
  ) |>
  ungroup() |>
  mutate(HEIGHT = if_else(is.infinite(HEIGHT), SPECIES_MIN_HT, HEIGHT)) |>
  filter(!is.na(HEIGHT) & !is.infinite(HEIGHT)) |>
  left_join(
    tblDWSPCFIPlotVisitsComplete |>
      filter(VisitCycle == 1970) |>
      select(MasterPlotID, STAND_CN = MasterPlotVisitID),
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    species_crosswalk |> select(SPCD, FVS_SPCD),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  filter(!is.na(FVS_SPCD)) |>
  select(
    STAND_CN,
    SPECIES = FVS_SPCD,
    DENSITY,
    HEIGHT
  )
```

## Calibration

Use the mortality data from 1980 for calibration.

### Growth

Find the trees in the 1980 survey that also exist in the 1970 survey.
The diameter and height in 1980 are the growth values.

```{targets cfigro_none_growth, tar_simple = TRUE}
# Trees to use for modeling height estimation
cfigro_none_growth <- qryDWSPCFIPlotVisitTreeDetail |>
  filter(VisitTreeStatusCode == 1) |>
  left_join(
    tblDWSPCFIPlotVisitsComplete |>
      select(MasterPlotID, VisitCycle, MasterPlotVisitID),
    by = join_by(MasterPlotVisitID)
  ) |>
  left_join( 
    tblDWSPCFITreesComplete |> select(MasterTreeID, SpeciesCode),
    by = join_by(MasterTreeID)
  ) |>
  inner_join(
    cfiabp_trees |> distinct(MasterPlotID, VisitCycle, MasterTreeID, StatusB),
    by = join_by(MasterPlotID, VisitCycle, MasterTreeID)
  ) |>
  filter(VisitCycle %in% c(1970, 1980)) |>
  group_by(MasterPlotID, MasterTreeID) |>
  arrange(VisitCycle) |>
  mutate(
    PREV_STATUSCD = lag(VisitTreeStatusCode),
    STAND_CN = as.character(lag(MasterPlotVisitID)),
    TREE_CN = as.character(lag(VisitTreeNumberDetail))
  ) |>
  ungroup() |>
  filter(VisitCycle == 1980 & PREV_STATUSCD == 1) |>
  select(
    STAND_CN,
    TREE_CN,
    DG = VisitTreeDIAM,
    HTG = VisitTreeTotalHeight
  )
```

### Mortality

```{targets cfigro_none_death, tar_simple = TRUE}
# All the trees we'll give to FVS for calibration
# There are 3 sets of trees:
# 1. Trees that are live (1) in 1970 that are standing (2) or fallen (3) dead in 1980
# 2. Trees that are dead in 1970 and still dead in 1980
# 3. Trees that are not present in 1970 then establish and die in 1980
tmp_trees_1970 <- qryDWSPCFIPlotVisitTreeDetail |>
  left_join(
    tblDWSPCFIPlotVisitsComplete |>
      select(MasterPlotID, VisitCycle, MasterPlotVisitID),
    by = join_by(MasterPlotVisitID)
  ) |>
  left_join( 
    tblDWSPCFITreesComplete |> select(MasterTreeID, SpeciesCode),
    by = join_by(MasterTreeID)
  ) |>
  inner_join(
    cfiabp_trees |> distinct(MasterPlotID, VisitCycle, MasterTreeID, StatusB),
    by = join_by(MasterPlotID, VisitCycle, MasterTreeID)
  ) |>
  filter(VisitCycle == 1970) |>
  mutate(
    TREE_CN1 = as.character(VisitTreeNumberDetail),
    STATUS1 = VisitTreeStatusCode,
    DIAM1 = if_else(VisitTreeDIAM > 0, VisitTreeDIAM, NA),
    HT1 = if_else(VisitTreeTotalHeight > 0, VisitTreeTotalHeight, NA)
  ) |>
  select(MasterTreeID, TREE_CN1, STATUS1, DIAM1, HT1)

tmp_trees_1980 <- qryDWSPCFIPlotVisitTreeDetail |>
  filter(cfi_status_dead(VisitTreeStatusCode)) |>
  left_join(
    tblDWSPCFIPlotVisitsComplete |>
      select(MasterPlotID, VisitCycle, MasterPlotVisitID),
    by = join_by(MasterPlotVisitID)
  ) |>
  left_join( 
    tblDWSPCFITreesComplete |> select(MasterTreeID, SpeciesCode),
    by = join_by(MasterTreeID)
  ) |>
  inner_join(
    cfiabp_trees |> distinct(MasterPlotID, VisitCycle, MasterTreeID, StatusB),
    by = join_by(MasterPlotID, VisitCycle, MasterTreeID)
  ) |>
  filter(VisitCycle == 1980) |>
  left_join(species_crosswalk |> select(SPCD, FVS_SPCD), by = join_by(SpeciesCode == SPCD)) |>
  mutate(
    SPECIES = FVS_SPCD,
    TREE_CN2 = as.character(VisitTreeNumberDetail),
    STATUS2 = VisitTreeStatusCode,
    DIAM2 = if_else(VisitTreeDIAM > 0, VisitTreeDIAM, NA),
    HT2 = if_else(VisitTreeTotalHeight > 0, VisitTreeTotalHeight, NA)
  ) |>
  select(MasterPlotID, MasterTreeID, SPECIES, TREE_CN2, STATUS2, DIAM2, HT2)

tmp_trees_death <- tmp_trees_1980 |>
  left_join(tmp_trees_1970, by = join_by(MasterTreeID))

tmp_stand_cn <- tblDWSPCFIPlotVisitsComplete |>
  filter(VisitCycle == 1970) |>
  mutate(STAND_CN = as.character(MasterPlotVisitID)) |>
  select(MasterPlotID, STAND_CN)

tmp_stand_info <- tblDWSPCFIPlotsComplete |>
  select(MasterPlotID, SLOPE = Slope, ASPECT = Aspect) |>
  left_join(tmp_stand_cn, by = join_by(MasterPlotID))

cfigro_none_death <- tmp_trees_death |>
  left_join(tmp_stand_info, by = join_by(MasterPlotID)) |>
  mutate(
    STAND_ID = MasterPlotID,
    PLOT_CN = STAND_CN,
    PLOT_ID = 1,
    STANDPLOT_CN = paste0(STAND_CN, "_", PLOT_CN),
    STANDPLOT_ID = paste0(STAND_ID, "_", PLOT_ID),
    TREE_CN = coalesce(TREE_CN1, TREE_CN2),
    TREE_ID = MasterTreeID,
    TREE_COUNT = 1,
    HISTORY = case_when(
      is.na(STATUS1) & cfi_status_dead(STATUS2) ~ 6,
      cfi_status_live(STATUS1) & cfi_status_dead(STATUS2) ~ 6,
      cfi_status_dead(STATUS1) & cfi_status_dead(STATUS2) ~ 8
    ),
    DIAMETER = coalesce(DIAM2, DIAM1),
    HT = coalesce(HT2, HT1)
  ) |>
  filter(!is.na(HISTORY) & !is.na(SPECIES)) |>
  select(
    STAND_CN,
    STAND_ID,
    PLOT_CN,
    PLOT_ID,
    STANDPLOT_CN,
    STANDPLOT_ID,
    TREE_CN,
    TREE_ID,
    TREE_COUNT,
    SPECIES,
    HISTORY,
    DIAMETER,
    HT,
    SLOPE,
    ASPECT
  )
```


# Run FVS

## FVS CFIGRO NONE

```{targets cfigro_none}
tar_target(
  cfigro_none,
  {
    # fvs_run wants a table of the form:
    # STAND_ID - arbitrary identifier for a stand
    # STAND_CN - CN for the plot
    # FIRST_YEAR - start of the projection; if this doesn't align with the actual
    #   year (MEASYEAR) of first survey, the stand will be projected from the
    #   survey year to the start of the projection.
    # LAST_YEAR - end of the projection
    timestep <- 10 # years; determined by FVSne variant
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "CFIGrowOnly"
    mgmt_id <- "NONE"
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = NULL,
      title = title,
      mgmt_id = mgmt_id,
      stands = cfigro_plot |>
        left_join(cfigro_plot_harvested, by = join_by(STAND_ID == MasterPlotID)) |>
        left_join(cfigro_plot_disturbed, by = join_by(STAND_ID == MasterPlotID)) |>
        filter(!CFIHarvested & !CFIDisturbed),
      trees = cfigro_trees,
      regen = cfigro_estab,
      calibration = cfigro_none_growth,
      calib_mort = cfigro_none_death,
      calib_years = 10,
      num_partitions = fvs_num_partitions,
      partition = fvs_partition,
      random_seed = fvs_randseed
    )
  },
  # iteration = "vector" branches execution for each partition value (see below)
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here.
  # cross() ensures that every combination of values for its arguments is processed
  # map() distributes each value of its argument to a separate sub-target (branch)
  # so cross(randseed, map(partition)) will run each partition in a separate branch,
  # and each branch will run with each value of randseed
  pattern = cross(fvs_randseed, map(fvs_partition))
)
```

## FVS CFIGRO SRVY

```{targets cfigro_srvy}
tar_target(
  cfigro_srvy,
  {
    # Find all the VisitYears for each plot,
    # and expand the plots to visit in each year
    visits <- cfiabp_trees |>
      left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
      left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
      filter(!CFIHarvested & !CFIDisturbed) |>
      distinct(MasterPlotID, VisitCycle) |>
      left_join(
        tblDWSPCFIPlotVisitsComplete |>
          select(MasterPlotID, VisitCycle, MasterPlotVisitID, VisitYear),
        by = join_by(MasterPlotID, VisitCycle)
      ) |>
      mutate(MasterPlotVisitID = as.character(MasterPlotVisitID)) |>
      select(
        STAND_CN = MasterPlotVisitID,
        STAND_ID = MasterPlotID,
        INV_YEAR = VisitYear
      )
    
    plots_for_fvs <- cfigro_plot |>
      left_join(cfigro_plot_harvested, by = join_by(STAND_ID == MasterPlotID)) |>
      left_join(cfigro_plot_disturbed, by = join_by(STAND_ID == MasterPlotID)) |>
      filter(!CFIHarvested & !CFIDisturbed) |>
      select(-STAND_CN, -INV_YEAR) |>
      full_join(visits, by = join_by(STAND_ID)) |>
      mutate(FIRST_YEAR = INV_YEAR, LAST_YEAR = INV_YEAR)

    # No establishment for survey runs

    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "CFIGrowOnly"
    mgmt_id <- "SRVY"

    # We communicate with FVS through files. FVSOnline shows a model in which
    # a "project" (the inputs and outputs of a single FVS run) live in a
    # single directory; we follow that model.
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = NULL,
      title = title,
      mgmt_id = mgmt_id,
      stands = plots_for_fvs,
      trees = cfigro_trees,
      num_partitions = fvs_num_partitions,
      partition = fvs_partition
    )
  },
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here:
  pattern = map(fvs_partition)
)
```


# Results

## Load Results

Load the output from all FVS partitions into a single dataframe

Consolidate outputs that use multiple random seeds;
average the multiple runs with different random seeds.

### CFI GrowOnly NONE

Carbon

```{targets cfigro_none_carbon, tar_simple = TRUE}
fvs_read_output(cfigro_none, "FVS_Carbon") |>
  group_by(StandID, Year) |> # Combine results from different random seeds
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    .groups = "keep"
  ) |>
  ungroup()
```

Summary

```{targets cfigro_none_summary, tar_simple = TRUE}
fvs_read_output(cfigro_none, "FVS_Summary2_East") |>
  group_by(StandID, Year) |>
  summarize(
    BA = mean(BA),
    Tpa = mean(Tpa),
    .groups = 'keep'
  ) |>
  ungroup()
```


## Load Results

Load the output from all FVS partitions into a single dataframe

Consolidate outputs that use multiple random seeds;
average the multiple runs with different random seeds.

### CFI GrowOnly SRVY

Carbon

```{targets cfigro_srvy_carbon, tar_simple = TRUE}
fvs_read_output(cfigro_srvy, "FVS_Carbon") |>
  select(StandID, Year, Aboveground_Total_Live)
```

Summary

```{targets cfigro_srvy_summary, tar_simple = TRUE}
fvs_read_output(cfigro_srvy, "FVS_Summary2_East") |>
  select(StandID, Year, BA, Tpa)
```

# Basal Area Increment

## CFIGRO SRVY BAI

```{r sanity cfigro srvy, eval = FALSE}
cfigro_srvy_summary |>
  filter(Year %% 10 == 0) |>
  mutate(BA_METRIC = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
#  filter(StandID == "10464") |>
  ggplot(aes(Year, BA_METRIC, color = StandID)) +
  geom_line() +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none") +
  ggtitle("Quabbin Grow-Only Plots Observed BA") +
  ylab(bquote("BA" ~ (m^2 %.% hectare^-1)))
```

### The Fate of Plot 10464

```{r plot 10464 ba, eval = FALSE}
cfi_raw <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  filter(MasterPlotID == 10464) |>
  filter(VisitTreeStatusCode == 1) |>
  group_by(MasterPlotID, VisitYear) |>
  summarize(
    BA = sum(pi * (VisitTreeDIAM/2)^2, na.rm = TRUE),
    Tpa = n() * 5,
    .groups = "drop"
  ) |>
  ungroup() |>
  mutate(
    StandID = factor(MasterPlotID),
    Year = VisitYear,
    Series = "CFI"
  )

cfi_fvs <- cfigro_srvy_summary |>
  filter(StandID == "10464") |>
  filter(Year %% 10 == 0) |>
  mutate(
    Series = "FVS"
  )

bind_rows(cfi_raw, cfi_fvs) |>
  ggplot(aes(Year, Tpa, fill = Series)) +
  geom_col(position = "dodge") +
  theme_bw() +
  ggtitle("CFI vs. FVS reported TPA for plot 10464") +
  ylab(bquote("TPA" ~ (trees %.% acre^-1))) +
  coord_cartesian(ylim = c(0, NA))
```

## NRSGRO SRVY BAI

Compare to NRSGrowOnly:

```{r sanity nrsgro srvy, eval = FALSE}
nrsgro_srvy_summary |>
  filter(Year %% 10 == 0) |>
  mutate(BA_METRIC = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  ggplot(aes(Year, BA_METRIC, color = StandID)) +
  geom_line() +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none") +
  ggtitle("NRS Grow-Only Plots Observed BA") +
  ylab(bquote("BA" ~ (m^2 %.% hectare^-1)))
```

## CFIGRO NONE BA

```{r sanity none, eval = FALSE}
cfigro_none_summary |>
  filter(Year < 2021) |>
  mutate(BA_METRIC = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  ggplot(aes(Year, BA_METRIC, color = StandID)) +
  geom_line() +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none") +
  ggtitle("Quabbin Grow-Only Plots Projected BA") +
  ylab(bquote("BA" ~ (m^2 %.% hectare^-1)))
```

# Projected vs. Measured

Compare FVS projected values vs. measured values

```{targets cfigro_none_proj_vs_meas, tar_simple = TRUE}
projected_carbon_tmp <- cfigro_none_carbon |>
  select(StandID, Year, Aboveground_Total_Live) |>
  rename(Projected_Carbon = Aboveground_Total_Live)

projected_ba_tmp <- cfigro_none_summary |>
  mutate(Projected_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  mutate(Projected_Tph = conv_unit(Tpa, "hectare", "acre")) |>
  select(StandID, Year, Projected_BA, Projected_Tph)

projected_tmp <- projected_carbon_tmp |>
  full_join(projected_ba_tmp, by = join_by(StandID, Year)) |>
  select(StandID, Year, Projected_Carbon, Projected_BA, Projected_Tph)

surveyed_carbon_tmp <- cfigro_srvy_carbon |>
  select(StandID, Year, Aboveground_Total_Live) |>
  rename(Measured_Carbon = Aboveground_Total_Live)

surveyed_ba_tmp <- cfigro_srvy_summary |>
  mutate(Measured_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")) |>
  mutate(Measured_Tph = conv_unit(Tpa, "hectare", "acre")) |>
  select(StandID, Year, Measured_BA, Measured_Tph)

surveyed_tmp <- surveyed_carbon_tmp |>
  full_join(surveyed_ba_tmp, by = join_by(StandID, Year)) |>
  filter(!is.na(Measured_Carbon)) |> # other metrics get an extra year
  select(StandID, Year, Measured_Carbon, Measured_BA, Measured_Tph)

#cfigro_none_proj_vs_meas <- qryDWSPCFIPlotVisitTreeDetail |>
#  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
#  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
#  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
#  filter(VisitTreeStatusCode != 4) |> # Skip missing trees
#  cfi_abp(cfiabp_trees) |>
#  mutate(StandID = as.character(MasterPlotID)) |>
#  select(
#    StandID,
#    Year = VisitYear
#  ) |>
#  left_join(surveyed_tmp, by = join_by(StandID, Year)) |>
cfigro_none_proj_vs_meas <- surveyed_tmp |>
  left_join(projected_tmp, by = join_by(StandID, Year)) |>
  group_by(StandID) |>
  mutate(
    First_Year = min(Year, na.rm = TRUE),
    Last_Year = max(Year, na.rm = TRUE),
    Starting_Carbon = min(
      if_else(Year == First_Year, Measured_Carbon, NA),
      na.rm = TRUE
    ),
    Projected_Carbon_Delta = Projected_Carbon - Starting_Carbon,
    Projected_Carbon_Flux = if_else(
      Year == First_Year,
      0,
      -(Projected_Carbon_Delta / (Year - First_Year))
    ),
    Measured_Carbon_Delta = Measured_Carbon - Starting_Carbon,
    Measured_Carbon_Flux = if_else(
      Year == First_Year,
      0,
      -(Measured_Carbon_Delta / (Year - First_Year))
    ),
    Starting_BA = min(
      if_else(Year == First_Year, Measured_BA, NA),
      na.rm = TRUE
    ),
    Projected_BA_Delta = Projected_BA - Starting_BA,
    Projected_BAI = if_else(
      Year == First_Year,
      0,
      Projected_BA_Delta / (Year - First_Year)
    ),
    Measured_BA_Delta = Measured_BA - Starting_BA,
    Measured_BAI = if_else(
      Year == First_Year,
      0,
      Measured_BA_Delta / (Year - First_Year))
  ) |>
  ungroup() |>
#  filter(Year == First_Year | Year == Last_Year) |>
  filter(!is.na(Projected_Carbon) & !is.na(Measured_Carbon)) |>
  mutate(Projection_Years = Year - First_Year) |>
  mutate(BA_Residual = Projected_BA - Measured_BA) |>
  mutate(BA_Error = 2 * abs(BA_Residual) / (Projected_BA + Measured_BA)) |>
  mutate(BA_Delta_Residual = Projected_BA_Delta - Measured_BA_Delta) |>
  mutate(BAI_Residual = BA_Delta_Residual / Projection_Years) |>
  mutate(Carbon_Residual = Projected_Carbon - Measured_Carbon) |>
  mutate(Carbon_Error = 2 * abs(Carbon_Residual) / (Projected_Carbon + Measured_Carbon)) |>
  mutate(Carbon_Delta_Residual = Projected_Carbon_Delta - Measured_Carbon_Delta) |>
  mutate(Carbon_Flux_Residual = Projected_Carbon_Flux - Measured_Carbon_Flux)
```


```{r plot bai density, eval = FALSE}
cfigro_none_proj_vs_meas |>
  filter(Projection_Years == 50) |>
  select(
    StandID,
    Projected_BAI,
    Measured_BAI) |>
  pivot_longer(
    cols = c("Projected_BAI", "Measured_BAI"),
    names_to = "Series",
    values_to = "BAI"
  ) |>
  ggplot(aes(BAI, fill = Series)) +
  geom_density(alpha = 0.5) +
  geom_vline(xintercept = 0, color = "black", linewidth = 0.25) +
  theme_bw() +
  xlab(bquote("Basal Area Increment" ~ (m^2 %.% ha^-1 %.% year^-1))) +
  ylab("Density") +
  scale_fill_brewer(palette="Set1") +
  ggtitle("Basal Area Increment Projection")
```

Same, but as a histogram:


```{r plot bai density histogram, eval = FALSE}
cfigro_none_proj_vs_meas |>
  filter(Projection_Years == 50) |>
  select(
    StandID,
    Projected_BAI,
    Measured_BAI) |>
  pivot_longer(
    cols = c("Projected_BAI", "Measured_BAI"),
    names_to = "Series",
    values_to = "BAI"
  ) |>
  ggplot(aes(BAI, fill = Series)) +
  geom_histogram(binwidth = 0.05, position = "dodge") +
  geom_vline(xintercept = 0, color = "black", linewidth = 0.25) +
  theme_bw() +
  xlab(bquote("Basal Area Increment" ~ (m^2 %.% ha^-1 %.% year^-1))) +
  ylab("Number of Plots") +
  scale_fill_brewer(palette="Set1") +
  ggtitle("Basal Area Increment Projection")
```


```{r plot carbon flux density, eval = FALSE}
cfigro_none_proj_vs_meas |>
  filter(Projection_Years == 50) |>
  select(
    StandID,
    Projected_Carbon_Flux,
    Measured_Carbon_Flux) |>
  pivot_longer(
    cols = c("Projected_Carbon_Flux", "Measured_Carbon_Flux"),
    names_to = "Series",
    values_to = "Carbon_Flux"
  ) |>
  ggplot(aes(Carbon_Flux, fill = Series)) +
  geom_density(alpha = 0.5) +
  geom_vline(xintercept = 0, color = "black", linewidth = 0.25) +
  theme_bw() +
  xlab(bquote("Carbon Flux" ~ (`Mg C` %.% ha^-1 %.% year^-1))) +
  ylab("Density") +
  scale_fill_brewer(palette="Set1") +
  ggtitle("Carbon Flux Projection") +
  coord_cartesian(xlim = c(-2.5, 0))
```

# Projection Error from FIA

We have a model of FVS projection error; how accurate is it?

## Model Inputs

What does the model need?

```{r nrsres_model selected features, eval = FALSE}
nrsres_model$selected_features()
```

We can get these from:
- ASPECT - cfigro_plot$ASPECT - need to apply Beers' transformation
- ELEV - cfigro_plot$ELEVFT - correct, elevation above sea level in feet
- FOREST_TYPE - need to fill this in
- LAT - cfigro_plot$LATITUDE - decimal degrees
- SLOPE - cfigro_plot$SLOPE - percent
- BA_Proj - metric; cfigro_proj_vs_meas$Projected_BA is metric
- Tph_Proj - metic; cfigro_proj_vs_meas$Projected_Tph is metric

### Forest Type

CFI documents their cover type in `tblSuppPlotForestTypeCodes`, but there are
two issues with using this:
1. Some CFI Cover types don't align with FIA forest types, e.g. CFI
   cover type 3,	"White pine - Pitch pine"
2. For cover types whose names align between CFI and FIA, there's no assurance
   that the forest composition is actually aligned.

The FIA process for determining Forest Type is described in
wo-v9-3_sep2023_fg_nfi_natl.pdf, the Forest Inventory and Analysis National
Core Field Guid for the Nationwide Forest Inventory, version 9.3.

Forest types, and how to determine them, is described in:

> Appendix 2. FIA Forest Type Codes

Forest type code depends on the stocking level of the different species in the
plot; stocking is described in:

> Appendix 5. Determination of Stocking Values for Land Use Classification

We can use Table 5f:

> Table 5f. Stocking values for all trees 5.0 inches and greater observed on one acre

This allows us to tally trees, look them up in the table, and derive stocking
level for the species.

```{targets fiafg_table_5f}
tarchetypes::tar_file_read(
  fiafg_table_5f,
  "data/raw/FIAFG_Table_5f.csv",
  read_csv(!!.x)
)
```
Turn Table 5f into a lookup table, and apply that across plots.

Derivation of Forest Type from plot/species stocking level is described in
Appendix 2:

>  Unless otherwise stated, forest types are named for the predominant species (or
>  group of species) on the condition. In order to determine if the type should be
>  classified as softwood versus hardwood, first estimate the stocking (site
>  occupancy) of trees in each of these two categories. If softwoods predominate
>  (50% or more), then the forest type will be one of the softwood types (codes 101
>  through 391) and vice versa for hardwoods (codes 401 through 995).

>  For the Eastern United States, there are mixed hardwood-pine forest types (codes
>  401 through 409) when the pine and/or redcedar (either eastern or southern)
>  component is between 25 and 49% of the stocking. If the pine/redcedar component
>  is less than 25% of the stocking, then one of the hardwood forest types is
>  assigned.

```{targets cfigro_forest_type, tar_simple = TRUE}
stocking_table <- fiafg_table_5f |>
  pivot_longer(-"Species", names_to = "dbh", values_to = "stocking") |>
  mutate(dbh = as.numeric(dbh)) |>
  rename(SpeciesCode = Species, min_dbh = dbh) |>
  group_by(SpeciesCode) |>
  arrange(rev(min_dbh)) |>
  mutate(max_dbh = replace_na(lag(min_dbh), Inf))

qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  filter(VisitTreeStatusCode == 1) |> # Only live trees
  filter(VisitCycle == 1970) |>
  left_join(
    stocking_table,
    by = join_by(
      SpeciesCode,
      VisitTreeDIAM >= min_dbh,
      VisitTreeDIAM < max_dbh
    )
  ) |>
  group_by(MasterPlotID, SpeciesCode) |>
  summarize(
    stocking = sum(stocking, na.rm = TRUE) * 5, # Each tree is 5 trees per acre
    .groups = "keep"
  ) |>
  ungroup() |>
  left_join(
    species_crosswalk |>
      select(SPCD, SCIENTIFIC_NAME, HARD_SOFT),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  group_by(MasterPlotID) |>
  mutate(
    total_stocking = sum(stocking),
    hardwood_pct = sum(if_else(HARD_SOFT == "HARDWOOD", stocking, 0)) / total_stocking,
    softwood_pct = sum(if_else(HARD_SOFT == "SOFTWOOD", stocking, 0)) / total_stocking,
  ) |>
  ungroup() |>
  mutate(stocking_pct = stocking / total_stocking) |>
  #filter(stocking_pct >= 0.1) |>
  pivot_wider(
    id_cols = c("MasterPlotID", "total_stocking", "softwood_pct"),
    names_from = "SCIENTIFIC_NAME",
    names_sort = TRUE,
    values_from = "stocking_pct",
    values_fill = 0
  ) |>
  mutate(
    FORTYPCD = case_when(
      # If softwoods are 50% or more of the stocking, it is a softwood type.
      
      # White/Red/Jack Pine group
      `Pinus resinosa` >= 0.5 ~ 102, # Red pine
      `Pinus strobus` >= 0.5 ~ 103, # Pure eastern white pine
      `Tsuga canadensis` >= 0.5 ~ 105, # Pure eastern hemlock
      # Spruce / Fir group
      `Picea rubens` >= 0.5 ~ 123, # red spruce
      
      # less pure versions of softwood stands
      # these come after the pure versions, so the pure versions are caught first
      `Pinus strobus` + `Tsuga canadensis` >= 0.5 ~ 104, # Eastern white pine / eastern hemlock
      `Pinus resinosa` >= 0.20 & softwood_pct >= 0.5 ~ 102, # Red pine, even if mixed
      `Pinus rigida` >= 0.20 & softwood_pct >= 0.5 ~ 167, # Pitch pine, even if mixed
      `Pinus strobus` >= 0.20 & softwood_pct >= 0.5 ~ 103, # Eastern white pine, even if mixed
      `Tsuga canadensis` >= 0.20 & softwood_pct >= 0.5 ~ 105, # Eastern hemlock, even if mixed
      
      # For the Eastern United States, when the pine and/or redcedar component is
      # between 25% and 49% of the stocking, there are mixed hardwood-pine forest types.
      # Therefore we consider hardwood groups to only be when softwood_pct < 0.25
      
      # Oak / Hickory group
      `Quercus prinus` >= 0.5 & softwood_pct < 0.25 ~ 502, # Chestnut oak
      `Quercus alba` >= 0.5 & softwood_pct < 0.25 ~ 503, # White oak/red oak/hickory
      `Quercus rubra` >= 0.5 & softwood_pct < 0.25 ~ 503, # White oak/red oak/hickory
      `Quercus velutina` >= 0.5 & softwood_pct < 0.25 ~ 515, # Chestnut oak/black oak/scarlet oak
      `Fraxinus americana` >= 0.5 & softwood_pct < 0.25 ~ 516, # Cherry/white ash/yellow-poplar
      # MAPLE/BEECH/BIRCH GROUP
      `Acer saccharum` >= 0.5 & softwood_pct < 0.25 ~ 801, # Sugar maple/beech/yellow birch
      `Betula alleghaniensis` >= 0.5 & softwood_pct < 0.25 ~ 801, # Sugar maple/beech/yellow birch
      `Acer rubrum` >= 0.5 & softwood_pct < 0.25 ~ 809, # Red maple/upland
      # ASPEN/BIRCH GROUP
      `Betula papyrifera` >= 0.5 & softwood_pct < 0.25 ~ 902, # Paper birch
      
      # less pure versions of hardwood stands
      # these come after the pure versions, so the pure versions are caught first
      `Quercus alba` >= 0.20 & softwood_pct < 0.25 ~ 503, # White oak/red oak/hickory
      `Quercus rubra` >= 0.20 & softwood_pct < 0.25 ~ 503, # White oak/red oak/hickory
      `Quercus velutina` >= 0.20 & softwood_pct < 0.25 ~ 515, # Chestnut oak/black oak/scarlet oak
      `Acer rubrum` >= 0.20 & softwood_pct < 0.25 ~ 809, # Red maple/upland
      `Acer saccharum` >= 0.20 & softwood_pct < 0.25 ~ 801, # Sugar maple/beech/yellow birch
      `Fraxinus americana` >= 0.20 & softwood_pct < 0.25 ~ 516, # Cherry/white ash/yellow-poplar
      `Betula papyrifera` >= 0.20 & softwood_pct < 0.25 ~ 902, # Paper birch
      `Betula alleghaniensis` >= 0.20 & softwood_pct < 0.25 ~ 801, # Sugar maple/beech/yellow birch
      
      # Mixed hard and softwood stands
      (`Pinus strobus` + `Tsuga canadensis`) >= 0.1 & softwood_pct >= 0.25 ~ 401, # Eastern white pine/northern red oak/white ash
      softwood_pct >= 0.25 ~ 409, # Other pine/hardwood
     
      # This leaves us with stands dominated by sweet birch, which FIA
      # seems to think can't happen. Assign them 801 sugar maple, even though there's
      # no sugar maple on there.
      `Betula lenta` >= 0.20 ~ 801, # Sugar maple/beech/yellow birch
    )
  ) |>
  left_join(
      fia_tbl(fiadb, "REF_FOREST_TYPE", \(.data, con) {
        .data |>
          select(VALUE, MEANING) |>
          rename(
            FORTYPCD = VALUE,
            FOREST_TYPE = MEANING,
          )
      }),
      by = join_by(FORTYPCD)
  )
```

## Apply Model

```{r projection_50, eval = FALSE}
projection_50 <-cfigro_plot |>
  select(STAND_ID, ASPECT, ELEV = ELEVFT, LAT = LATITUDE, SLOPE) |>
  mutate(ASPECT = beers_transformation(ASPECT)) |>
  left_join(
    cfigro_forest_type |>
      select(MasterPlotID, FOREST_TYPE),
    by = join_by(STAND_ID == MasterPlotID)
  ) |>
  mutate(STAND_ID = as.character(STAND_ID)) |>
  inner_join(
    cfigro_none_proj_vs_meas |>
      filter(Projection_Years == 50) |>
      select(
        StandID,
        BA_Proj = Projected_BA,
        Tph_Proj = Projected_Tph,
        BA_Srvy = Measured_BA,
        Tph_Srvy = Measured_Tph,
        Projection_Years
      ),
    by = join_by(STAND_ID == StandID)
  ) |>
  left_join(
    cfigro_none_proj_vs_meas |>
      filter(Projection_Years == 0) |>
      select(StandID, BA_Start = Measured_BA, Tph_Start = Measured_Tph),
    by = join_by(STAND_ID == StandID)
  ) |>
  mutate(
    BAI_Proj = (BA_Proj - BA_Start) / Projection_Years,
    BAI_Srvy = (BA_Srvy - BA_Start) / Projection_Years,
    BAI_Error = nrsres_model$predict_newdata(pick(everything()))$response,
    BAI_Adj = BAI_Proj - BAI_Error
  )
```

```{r plot projection_50, eval = FALSE}
projection_50 |>
  rename(
    `FVS Projected` = BAI_Proj,
    `CFI Observed` = BAI_Srvy,
    `Corrected` = BAI_Adj
  ) |>
  pivot_longer(c("FVS Projected", "CFI Observed", "Corrected")) |>
  ggplot(aes(value, fill = name)) +
  geom_density(alpha = 0.5) +
  theme_bw() +
  scale_fill_discrete(name = "Series") +
  xlab(bquote("Basal Area Increment" ~ (m^2 %.% hectare^-1 %.% year^-1))) +
  ylab("Density") +
  ggtitle("CFI Quabbin Grow-Only Plots 50 year BAI Prediction")
```

What if we do 20 year projections instead?

```{r projection_20, eval = FALSE}
projection_20 <-cfigro_plot |>
  select(STAND_ID, ASPECT, ELEV = ELEVFT, LAT = LATITUDE, SLOPE) |>
  mutate(ASPECT = beers_transformation(ASPECT)) |>
  left_join(
    cfigro_forest_type |>
      select(MasterPlotID, FOREST_TYPE),
    by = join_by(STAND_ID == MasterPlotID)
  ) |>
  mutate(STAND_ID = as.character(STAND_ID)) |>
  inner_join(
    cfigro_none_proj_vs_meas |>
      filter(Projection_Years == 20) |>
      select(
        StandID,
        BA_Proj = Projected_BA,
        Tph_Proj = Projected_Tph,
        BA_Srvy = Measured_BA,
        Tph_Srvy = Measured_Tph,
        Projection_Years
      ),
    by = join_by(STAND_ID == StandID)
  ) |>
  left_join(
    cfigro_none_proj_vs_meas |>
      filter(Projection_Years == 0) |>
      select(StandID, BA_Start = Measured_BA, Tph_Start = Measured_Tph),
    by = join_by(STAND_ID == StandID)
  ) |>
  mutate(
    BAI_Proj = (BA_Proj - BA_Start) / Projection_Years,
    BAI_Srvy = (BA_Srvy - BA_Start) / Projection_Years,
    BAI_Error = nrsres_model$predict_newdata(pick(everything()))$response,
    BAI_Adj = BAI_Proj - BAI_Error
  )
```


```{r plot projection_20, eval = FALSE}
projection_20 |>
  rename(
    `FVS Projected` = BAI_Proj,
    `CFI Observed` = BAI_Srvy,
    `Corrected` = BAI_Adj
  ) |>
  pivot_longer(c("FVS Projected", "CFI Observed", "Corrected")) |>
  ggplot(aes(value, fill = name)) +
  geom_density(alpha = 0.5) +
  theme_bw() +
  scale_fill_discrete(name = "Series") +
  xlab(bquote("Basal Area Increment" ~ (m^2 %.% hectare^-1 %.% year^-1))) +
  ylab("Density") +
  ggtitle("CFI Quabbin Grow-Only Plots 20 year BAI Prediction")
```

# CFI-Specific Modeled Error

Applying the model derived from FIA data doesn't work well on the CFI plots.
Let's try building a CFI-specific model.

## Training Data

One of the things we need is species composition, since e.g. eastern white pine
grows very different from red oak.

From above, we observe that the three dominant species in the Quabbin (more
than 10% of BA in the watershed) are:
- Acer rubrum
- Pinus strobus
- Quercus rubra

Let's create profiles of each CFI plot, indicating whether >= 10% of its BA
consisted of each of these species in 1970.

The rest of the training data follows the same model as for nrsgro.

```{targets cfigro_training_data, tar_simple = TRUE}
tmp_top_species <- c("Acer rubrum", "Pinus strobus", "Quercus rubra")

tmp_trees <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  filter(VisitCycle == 1970) |>
  filter(cfi_status_live(VisitTreeStatusCode)) |> # Only Live Trees
  left_join(
    species_crosswalk |> select(SPCD, SCIENTIFIC_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    TPA = conv_unit(5, "hectare", "acre"),
    BA = TPA * pi * conv_unit(VisitTreeDIAM / 2, "in", "m")^2,
  )

tmp_by_plot <- tmp_trees |>
  group_by(MasterPlotID) |>
  summarize(
    TPA = sum(TPA, na.rm = TRUE),
    BA = sum(BA, na.rm = TRUE),
    .groups = "drop"
  )

# Top species by plot
# (only considering top plots)
tmp_plot_species <- tmp_trees |>
  group_by(MasterPlotID, SCIENTIFIC_NAME) |>
  summarize(BA = sum(BA, na.rm = TRUE), .groups = "keep") |>
  ungroup() |>
  left_join(
    tmp_by_plot |>
      select(MasterPlotID, BA_Plot = BA),
    by = join_by(MasterPlotID)
  ) |>
  mutate(BA_Frac = BA / BA_Plot) |>
  filter(SCIENTIFIC_NAME %in% tmp_top_species) |>
  mutate(
    SCIENTIFIC_NAME = sub(" ", "_", SCIENTIFIC_NAME)
  ) |>
  pivot_wider(
    id_cols = MasterPlotID,
    names_from = SCIENTIFIC_NAME,
    values_from = BA_Frac,
    values_fill = 0
  ) |>
  mutate(MasterPlotID = as.character(MasterPlotID))

cfigro_none_proj_vs_meas |>
  filter(Year == 2020) |>
  select(MasterPlotID = StandID, BAI_Residual, Projected_BA, Projected_Tph) |>
  left_join(
    cfigro_plot |>
      filter(INV_YEAR == 1970) |>
      mutate(MasterPlotID = as.character(STAND_ID)) |>
      select(MasterPlotID, LAT = LATITUDE, ASPECT, SLOPE, ELEV = ELEVFT),
    by = join_by(MasterPlotID)
  ) |>
  left_join(
    tmp_plot_species,
    by = join_by(MasterPlotID)
  )
```

## Feature Selection

previous experience shows that doing an exhaustive search for the best combination
of features works fine.

Try it using fselect:
```{r feature selection, eval = FALSE}
cfigro_bai_task <- as_task_regr(
  cfigro_training_data,
  target = "BAI_Residual"
)
cfigro_bai_fs_task <- fselect(
  fselector = fs("sequential"),
  task = cfigro_bai_task,
  learner = lrn("regr.ranger"),
  # mlr3 section on resampling suggests repeated cv with 10/10 for small training sets
  # https://mlr3book.mlr-org.com/chapters/chapter3/evaluation_and_benchmarking.html#sec-resampling
  resampling = rsmp("repeated_cv", repeats = 10, folds = 10),
  measure = msrs("regr.rmse")
)
View(cfigro_bai_fs_task$archive$data |> arrange(regr.rmse))
```


```{r selected features, eval = FALSE}
cfigro_bai_fs_task$result |>
  pivot_longer(cols = -any_of(c("features", "n_features", "regr.rmse"))) |>
  filter(value) |>
  pull(name)
```
[1] "Acer_rubrum"   "LAT" Projected_BA"  "Projected_Tph" "Quercus_rubra"

It seems to select the two projected quantities, and two of the three species
selectors, and LAT. Interesting that it omits elevation, but ok.

## Hyperparameters

```{r optimize hyperparameters, eval = FALSE}
cfigro_bai_task$select(c("Acer_rubrum", "LAT", "Projected_BA", "Projected_Tph", "Quercus_rubra"))

lrn_regr_ranger <- lrn(
  "regr.ranger",
  importance = to_tune(c("impurity", "permutation")),
  max.depth = to_tune(1, 100, logscale = TRUE),
  min.node.size = to_tune(1:5 * 3 + 2), # minimum 5 for regression
  mtry = to_tune(2:ceiling(sqrt(length(names(cfigro_bai_task$data()))))),
  num.trees = to_tune(1, 100, logscale = TRUE)
)

nrsres_bai_hp_task <- tune(
  tuner = tnr("mbo"),
  task = cfigro_bai_task,
  learner = lrn_regr_ranger,
  resampling = rsmp("repeated_cv", repeats = 10, folds = 10),
  measures = msr("regr.rmse"),
  terminator = trm("stagnation", threshold = 0.1)
)

unlist(nrsres_bai_hp_task$result_x_domain)
```

```
> unlist(nrsres_bai_hp_task$result_x_domain)
   importance     max.depth min.node.size          mtry     num.trees 
   "impurity"          "16"          "11"           "2"          "68" 
> unlist(nrsres_bai_hp_task$result_x_domain)
   importance     max.depth min.node.size          mtry     num.trees 
"permutation"           "3"          "11"           "2"          "38" 
> unlist(nrsres_bai_hp_task$result_x_domain)
   importance     max.depth min.node.size          mtry     num.trees 
"permutation"          "24"           "8"           "2"          "84" 
> unlist(nrsres_bai_hp_task$result_x_domain)
   importance     max.depth min.node.size          mtry     num.trees 
   "impurity"           "4"           "8"           "2"          "51" 
> unlist(nrsres_bai_hp_task$result_x_domain)
   importance     max.depth min.node.size          mtry     num.trees 
   "impurity"          "24"          "17"           "2"          "71" 
```

So, that's kind of all over the map. The first result seems representative:
   importance     max.depth min.node.size          mtry     num.trees 
   "impurity"          "16"          "11"           "2"          "68" 

## Train and Predict

```{targets cfigro_bai_model, tar_simple = TRUE}
cfigro_bai_task <- as_task_regr(
  cfigro_training_data,
  target = "BAI_Residual"
)
cfigro_bai_task$select(
  c("Acer_rubrum", "LAT", "Projected_BA", "Projected_Tph", "Quercus_rubra")
)

#cfigro_bai_model <- lrn(
#  "regr.ranger",
#  importance = "permutation",
#  max.depth = 30,
#  min.node.size = 17,
#  mtry = 2,
#  num.trees = 31
#)
cfigro_bai_model <- lrn(
  "regr.ranger",
  importance = "impurity",
  max.depth = 16,
  min.node.size = 11,
  mtry = 2,
  num.trees = 68
)

cfigro_bai_model$train(cfigro_bai_task)

cfigro_bai_model
```


```{r plot cfigro_bai_model, eval = FALSE}
autoplot(cfigro_bai_model$predict(cfigro_bai_task)) +
  xlab("Predicted BAI Residual") +
  ylab("Actual BAI Residual") +
  ggtitle("Modeled FVS BAI Residual on CFI Grow-Only Plots")
```

```{r plot cfigro_bai_model density, eval = FALSE}
cfigro_none_proj_vs_meas |>
  filter(Year == 2020) |>
  mutate(Adjusted_BAI = Projected_BAI - cfigro_bai_model$predict(cfigro_bai_task)$response) |>
  select(
    StandID,
    Adjusted_BAI,
    Projected_BAI,
    Measured_BAI) |>

  pivot_longer(
    cols = c("Adjusted_BAI", "Projected_BAI", "Measured_BAI"),
    names_to = "Series",
    values_to = "BAI"
  ) |>
  ggplot(aes(BAI, fill = Series)) +
  geom_density(alpha = 0.5) +
  geom_vline(xintercept = 0, color = "black", linewidth = 0.25) +
  theme_bw() +
  xlab(bquote("Basal Area Increment" ~ (m^2 %.% ha^-1 %.% year^-1))) +
  ylab("Density") +
  scale_fill_brewer(palette="Set1") +
  ggtitle("Basal Area Increment Projection")
```


