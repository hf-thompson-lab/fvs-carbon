---
title: "12_CFICOP"
output: html_document
---

# Setup

```{r setup, include=FALSE}
suppressPackageStartupMessages({
  library(targets)
  library(tarchetypes)
  library(tidyverse)
  library(readxl)
  library(terra)
  library(sf)
  library(rnaturalearth)
  library(measurements)
  library(mlr3verse) # Machine Learning in R framework, larger universe
  library(ggspatial) # annotation_scale, annotation_north_arrow
})
tar_source()
```

## Load targets results from other documents

```{r load tar objects, eval = FALSE}
tar_load(fiadb)
tar_load(species_crosswalk)
tar_load(fvs_num_partitions)
tar_load(fvs_partition)
tar_load(fvs_randseed)
tar_load(fvsne_states)
tar_load(cfigro_bai_model)
tar_load(cfigro_estab)
tar_load(cfigro_none_growth)
```

## Preload everything from 11_CFIGrowOnly.Rmd

```{r load 11 cfigrowonly, eval = FALSE}
get_this_rmd_file() |>
  str_replace(basename(get_this_rmd_file()), "11_CFIGrowOnly.Rmd") |>
  tar_objects_defined_in_rmd() |>
  tar_load()
```

## Preload targets results from this document

When tar_make() has already built the objects defined in this document,
run this block to pre-load them. You can then skip running ```{targets} blocks.

```{r load tar objects defined here, eval = FALSE}
get_this_rmd_file() |>
  tar_objects_defined_in_rmd() |>
  tar_load()
```

# MODEL ALL* THE PLOTS!!!

We want to:
- Model all the plots grow-only
- Apply the model of residuals to get an idea of how much FVS might have over-projected
- Look at harvest, and how much carbon is actually on the landscape
- Multiply by area to get an idea of what COP would be, etc.

* We don't have harvest information except on Audrey's plots, so we'll actually
just use her 283 plots. So it's not _all_ of all the plots, but it's all the
plots for which we have good data.

## Plots

cfigro_plot has all 283 plots.

## Trees

cfigro_tree has trees for all 283 plots.

## Regeneration

We ignored harvest in CFIGRO; can we continue to ignore it?

```{r plot establishment rate, eval = FALSE}
cfigro_estab |>
  mutate(STAND_CN = as.character(STAND_CN)) |>
  group_by(STAND_CN) |>
  summarize(DENSITY = sum(DENSITY), .groups = "keep") |>
  left_join(cfigro_plot |> select(STAND_CN, STAND_ID), by = join_by(STAND_CN)) |>
  mutate(MasterPlotID = as.numeric(STAND_ID)) |>
  left_join(cfigro_plot_harvested, by = join_by(MasterPlotID)) |>
  left_join(cfigro_plot_disturbed, by = join_by(MasterPlotID)) |>
  mutate(Status = case_when(
    CFIDisturbed & CFIHarvested ~ "Disturbed & Harvested",
    CFIDisturbed ~ "Disturbed",
    CFIHarvested ~ "Harvested",
    .default = "Grow-Only"
  )) |>
  group_by(Status) |>
  mutate(Status = paste0(Status, ", n=", n())) |>
  ggplot(aes(Status, DENSITY)) +
  geom_boxplot() +
  theme_bw() +
  ggtitle("Establishment rate by plot status") +
  ylab(bquote("Establishment rate" ~ (stems %.% acre^-1 %.% year^-1)))
#  scale_y_continuous(transform = "log10")
  
```

non-Grow-Only plots show double and more the establishment rate of grow-only
plots.

Establishment comes from saplings / seedlings, which come from seeds, which
either come into the plot from outside or come from mature trees on the plot.
All of these plots are co-located, so they can trade seeds with each other.
For available seeds from trees on the plot, we can match plots by BA of the
major species, then use the establishment from the matched / sibling plot.

### Plot Matching

Start simple - minimize the delta in the three major species. We can leave "Other" alone.

```{targets cficop_plot_sibling, tar_simple = TRUE}
tmp_trees <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  filter(VisitCycle == 1970) |>
  filter(cfi_status_live(VisitTreeStatusCode)) |> # Only Live Trees
  # Quercus rubra and Quercus velutina are often conflated in surveys; instead
  # of treating them as two separate important species, combine them into one and
  # treat them as a single species.
  # Replace Quercus velutina (837) with Quercus rubra (833)
  mutate(
    SpeciesCode = if_else(SpeciesCode == 837, 833, SpeciesCode)
  ) |>
  left_join(
    species_crosswalk |> select(SPCD, SCIENTIFIC_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    TPA = 5,
    BA = VisitTreeDIAM
  )

tmp_by_plot <- tmp_trees |>
  group_by(MasterPlotID) |>
  summarize(
    TPA_Plot = sum(TPA, na.rm = TRUE),
    BA_Plot = sum(BA, na.rm = TRUE),
    .groups = "drop"
  ) |>
  ungroup() |>
  select(MasterPlotID, TPA_Plot, BA_Plot)

tmp_top_species <- c(
  "Acer rubrum", "Quercus rubra", "Pinus strobus"
)

tmp_plot_fingerprint <- tmp_trees |>
  group_by(MasterPlotID, SCIENTIFIC_NAME) |>
  summarize(
    TPA_Species = sum(TPA, na.rm = TRUE),
    BA_Species = sum(BA, na.rm = TRUE),
    .groups = "keep"
  ) |>
  ungroup() |>
  left_join(tmp_by_plot, by = join_by(MasterPlotID)) |>
  mutate(
    TPA_Frac = TPA_Species / TPA_Plot,
    BA_Frac = BA_Species / BA_Plot
  ) |>
  select(-ends_with("_Species")) |>
#  filter(BA_Frac > 0.1) |>
  filter(SCIENTIFIC_NAME %in% tmp_top_species) |>
  group_by(MasterPlotID) |>
  mutate(
    Species = do.call(
      paste,
      append(sort(SCIENTIFIC_NAME), list(sep = ", "))
    )
  ) |>
  ungroup() |>
  mutate(SCIENTIFIC_NAME = gsub(" ", "_", SCIENTIFIC_NAME)) |>
  pivot_wider(names_from = "SCIENTIFIC_NAME", values_from = c("TPA_Frac", "BA_Frac"))

tmp_plots_grow_only <- cfigro_plot_harvested |>
  filter(!CFIHarvested) |>
  inner_join(
    cfigro_plot_disturbed |> filter(!CFIDisturbed),
    by = join_by(MasterPlotID)
  ) |>
  select(MasterPlotID)

pct_diff <- function(a, b) {
  abs(a - b) / ((a + b) / 2)
}

most_similar_plot <- function(target_plots) {
  target_plots <- target_plots |>
    # Penalize things that differ on whether they have
    # a species on the landscape
    replace_na(list(
      BA_Frac_Pinus_strobus = -1,
      BA_Frac_Acer_rubrum = -1,
      BA_Frac_Quercus_rubra = -1
    ))

  lapply(1:nrow(target_plots), \(n) {
    # Minimize RMS difference in BA
    ba_plot <- target_plots[[n, "BA_Plot"]]
    ba_pist <- target_plots[[n, "BA_Frac_Pinus_strobus"]]
    ba_acru <- target_plots[[n, "BA_Frac_Acer_rubrum"]]
    ba_quru <- target_plots[[n, "BA_Frac_Quercus_rubra"]]
    tmp_plot_fingerprint |>
      inner_join(tmp_plots_grow_only, by = join_by(MasterPlotID)) |>
      replace_na(list(
        BA_Frac_Pinus_strobus = -1,
        BA_Frac_Acer_rubrum = -1,
        BA_Frac_Quercus_rubra = -1
      )) |>
      mutate(
        BA_RMSE = sqrt(
          pct_diff(BA_Plot, ba_plot)^2 +
            (BA_Frac_Pinus_strobus - ba_pist)^2 +
            (BA_Frac_Acer_rubrum - ba_acru)^2 +
            (BA_Frac_Quercus_rubra - ba_quru)^2
        )
      ) |>
      arrange(BA_RMSE) |>
      head(1) |>
      pull(MasterPlotID)    
  }) |>
    unlist()
}

tmp_plot_fingerprint |>
  mutate(sibling_plot = most_similar_plot(tmp_plot_fingerprint)) |>
  select(MasterPlotID, sibling_plot)
```

How's that looks:

```{r plot sibling plots, eval = FALSE}
tmp_top_species <- c(
  "Acer rubrum", "Quercus rubra", "Pinus strobus"
)

tmp_species <- qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  filter(VisitCycle == 1970) |>
  filter(cfi_status_live(VisitTreeStatusCode)) |> # Only Live Trees
  mutate(
    SpeciesCode = if_else(SpeciesCode == 837, 833, SpeciesCode)
  ) |>
  left_join(
    species_crosswalk |> select(SPCD, SCIENTIFIC_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  filter(SCIENTIFIC_NAME %in% tmp_top_species) |>
  distinct(MasterPlotID, SCIENTIFIC_NAME) |>
  group_by(MasterPlotID) |>
  summarize(
    Species = do.call(
      paste,
      append(sort(SCIENTIFIC_NAME), list(sep = ", "))
    ),
    .groups = "drop"
  ) |>
  select(MasterPlotID, Species)

matched_plots <- cficop_plot_sibling |>
  mutate(
    status = if_else(MasterPlotID == sibling_plot, "reference", "matched")
  ) |>
  left_join(
    cfigro_plot,
    by = join_by(MasterPlotID == STAND_ID)
  ) |>
  rename(
    lat = LATITUDE,
    long = LONGITUDE
  ) |>
  mutate(
    group = as.character(sibling_plot)
  ) |>
  select(
    MasterPlotID, status, lat, long, group
  ) |>
  left_join(
    tmp_species, by = join_by(MasterPlotID)
  ) |>
  group_by(group) |>
  mutate(n = n(), group = paste0(group, ", n=", n())) |>
  ungroup() |>
  filter(n > 12)
#  filter(n > 6)

matched_plot_group_order <- matched_plots |>
  distinct(group, n) |>
  arrange(desc(n))

matched_plots$group <- ordered(matched_plots$group, levels = matched_plot_group_order$group)

cfi_bbox <- st_as_sfc(
  st_bbox(vect(matched_plots, geom = c("long", "lat")))
)
sf_use_s2(FALSE)
st_crs(cfi_bbox) <- "WGS84"
lakes_north_america <- ne_download(
  scale = 10, type = "lakes_north_america", category = "physical"
)
lakes <- lakes_north_america[
  st_intersects(lakes_north_america, cfi_bbox, sparse = FALSE),
]
rivers_north_america <- ne_download(
  scale = 10, type = "rivers_north_america", category = "physical"
)
rivers <- rivers_north_america[
  st_intersects(rivers_north_america, cfi_bbox, sparse = FALSE),
]
ggplot() +
  geom_sf(data = lakes, fill = "blue", inherit.aes = FALSE) +
#  geom_sf(data = rivers, fill = "blue", inherit.aes = FALSE) +
  geom_point(
    data = matched_plots |> filter(status == "reference"),
    aes(long, lat, color = Species, shape = status), size = 2.5
  ) +
  geom_point(
    data = matched_plots |> filter(status == "matched"),
    aes(long, lat, color = Species, shape = status), size = 1.75
  ) +
  facet_wrap("group") +
#  scale_color_discrete(guide = "none") +
  scale_shape_manual(values = list(reference = 17, matched = 16)) +
#  annotation_scale(location = "br") +
#  annotation_north_arrow(
#    location = "tl",
#    width = unit(1, "cm"),
#    pad_x = unit(0.75, "cm"),
#    pad_y = unit(0.5, "cm")
#  ) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = -30, hjust = 0, vjust = 1)) +
  ggtitle("Matching harvested and disturbed CFI plots to grow-only plots")
```


### Copy CFIGRO Estab

We'll duplicate cfigro_estab from the reference plots to their sibling plots.

```{targets cficop_estab, tar_simple = TRUE}
# Each plot has a sibling plot;
# find the estab associated with the sibling plot.
cficop_plot_sibling |>
  left_join(
    cfigro_plot |> select(STAND_CN, MasterPlotID = STAND_ID),
    by = join_by(sibling_plot == MasterPlotID)
  ) |>
  mutate(STAND_CN = as.numeric(STAND_CN)) |>
  left_join(
    cfigro_estab,
    by = join_by(STAND_CN),
    # Each row on the left is a stand; many stands have the same STAND_CN.
    # Each row on the right is a stand-species; many rows on the right will
    # match a single stand. Therefore this is a many-to-many join.
    relationship = "many-to-many"
  ) |>
  # STAND_CN is for the sibling plot; swap that out
  # with the STAND_CN for the matched plot.
  select(-STAND_CN) |>
  left_join(
    cfigro_plot |> select(STAND_CN, MasterPlotID = STAND_ID),
    by = join_by(MasterPlotID)
  )
```

### Growth

cfigro_none_growth is tree-specific; for each tree within a plot, provide the diameter
and height 10 years from the simulation start time.

### Mortality

cfigro_none_death is tree-specific; for each tree within a plot, provide the status
at simulation start time.

## Watershed Area

I think I need to get a polygon for the watershed / districts, then use
land cover to find the forested area ... in 1970. Which I can't. Unless
they have literature that tells me.

But we can start with, what if it's 100% forested.

```{targets cficop_sam_wt, tar_simple = TRUE}
qryDWSPCFIPlotVisitTreeDetail |>
  cfi_with_visit_info(tblDWSPCFIPlotVisitsComplete) |>
  cfi_with_tree_info(tblDWSPCFITreesComplete) |>
  cfi_with_plot_info(tblDWSPCFIPlotsComplete) |>
  cfi_abp(cfiabp_trees) |>
  group_by(MasterPlotID) |>
  arrange(VisitCycle, MasterTreeID) |>
  filter(row_number() == 1) |>
  ungroup() |>
  left_join(
    tblSuppPlotForestrySubBasins,
    by = join_by(DWSPForestrySubWatershed == MasterForestryBasinID)
  ) |>
  group_by(EQDISTRICT, EQSUBDISTRICT) |>
  mutate(
    TotalAcres = max(DWSPOwnedAcres, na.rm = TRUE),
    NumPlots = n(),
    AcresPerPlot = TotalAcres / NumPlots,
    .groups = "keep"
  ) |>
  ungroup() |>
  select(
    EQDISTRICT,
    EQSUBDISTRICT,
    MasterPlotID,
    TotalAcres,
    NumPlots,
    AcresPerPlot
  )
```

```{r plot scaling cfi plots to watershed, eval = FALSE}
cficop_sam_wt |>
  group_by(EQSUBDISTRICT) |>
  filter(row_number() == 1) |>
  ggplot(aes(EQSUBDISTRICT, NumPlots, size = AcresPerPlot)) +
  geom_point() +
  coord_cartesian(ylim = c(0, 80)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = -15, hjust = 0, vjust = 1)) +
  ggtitle("Scaling CFI plots to the Watershed") +
  xlab("Subwatershed") +
  ylab("Number of Plots")
```

```{r map cfi plot scaling to watershed, eval = FALSE}
tmp_state_map <- fvsne_states |>
  filter(STATE_NAME == "Massachusetts") |>
  rename(region = STATE_NAME) |>
  _$region |>
  map_data("state", region = _)

tmp_plot_loc <- cfigro_plot |>
  rename(lat = LATITUDE, long = LONGITUDE, group = STAND_CN) |>
  left_join(
    cficop_sam_wt |> select(MasterPlotID, EQSUBDISTRICT, AcresPerPlot),
    by = join_by(STAND_ID == MasterPlotID)
  )

ggplot(tmp_state_map, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", color = "black") +
  geom_point(
    data = tmp_plot_loc,
    aes(size = AcresPerPlot, color = EQSUBDISTRICT)
  ) +
  coord_cartesian(xlim = c(-72.45, -72.15), ylim = c(42.25, 42.55)) +
  theme_bw()
```

# CFICOP_NONE

## Run FVS

```{targets cficop_none}
tar_target(
  cficop_none,
  {
    timestep <- 10 # years; determined by FVSne variant
    fvsbin_dir <- "/fvs/fvsbin" # TODO: put these in a config file
    fvs_variant <- "fvsne"      # TODO: put these in a config file
    data_dir <- "data/fvs"
    title <- "CFICarbonOffsetProgram"
    mgmt_id <- "NONE"
    project_dir <- file.path(data_dir, paste0("FVS_", title, "_", mgmt_id))
    if (!dir.exists(project_dir)) {
      dir.create(project_dir)
    }
    
    fvs_run(
      fvsbin_dir = fvsbin_dir,
      fvs_variant = fvs_variant,
      project_dir = project_dir,
      fiadb = NULL,
      title = title,
      mgmt_id = mgmt_id,
      stands = cfigro_plot |>
        # Filter out the 6 plots that do not get a sibling
        semi_join(
          cficop_plot_sibling,
          by = join_by(STAND_ID == MasterPlotID)
        ),
#        left_join(
#          cficop_sam_wt |> select(STAND_ID = MasterPlotID, SAM_WT = AcresPerPlot),
#          by = join_by(STAND_ID)
#        ),
      trees = cfigro_trees,
      regen = cficop_estab,
#      calibration = cfigro_none_growth,
#      calib_mort = cfigro_none_death,
#      calib_years = 10,
      num_partitions = fvs_num_partitions,
      partition = fvs_partition,
      random_seed = fvs_randseed
    )
  },
  # iteration = "vector" branches execution for each partition value (see below)
  iteration = "vector",
  # cross() and map() are unparsed targets:: functions here.
  # cross() ensures that every combination of values for its arguments is processed
  # map() distributes each value of its argument to a separate sub-target (branch)
  # so cross(randseed, map(partition)) will run each partition in a separate branch,
  # and each branch will run with each value of randseed
  pattern = cross(fvs_randseed, map(fvs_partition))
)
```

## Load Results

Carbon

```{targets cficop_none_carbon, tar_simple = TRUE}
fvs_read_output(cficop_none, "FVS_Carbon") |>
  group_by(StandID, Year) |> # Combine results from different random seeds
  summarize(
    Aboveground_Total_Live = mean(Aboveground_Total_Live),
    .groups = "keep"
  ) |>
  ungroup()
```

Summary

```{targets cficop_none_summary, tar_simple = TRUE}
fvs_read_output(cficop_none, "FVS_Summary2_East") |>
  group_by(StandID, Year) |>
  summarize(
    BA = mean(BA),
    Tpa = mean(Tpa),
    .groups = 'keep'
  ) |>
  ungroup()
```

## BA Over Time

```{r plot ba over time, eval = FALSE}
cficop_none_summary |>
  filter(Year %% 10 == 0) |>
#  group_by(Year) |>
#  summarize(BA = sum(BA) / n()) |>
#  ungroup() |>
  mutate(Series = "Projected") |>
  union_all(
    cfigro_srvy_summary |>
      filter(Year %% 10 == 0) |>
#      group_by(Year) |>
#      summarize(BA = sum(BA) / n()) |>
#      ungroup() |>
      mutate(Series = "Observed")
  ) |>
  mutate(
    Year = as.character(Year),
    BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare")
  ) |>
  ggplot(aes(Year, BA, fill = Series)) +
  geom_boxplot(outlier.size = 0.5) +
  theme_bw() +
  ggtitle("CFI Grow-Only Projection") +
  ylab(bquote("Basal Area " ~ (m^2 %.% hectare^-1)))

```

## Carbon Over Time

```{r plot carbon over time, eval = FALSE}
cficop_none_carbon |>
#  group_by(Year) |>
#  summarize(Aboveground_Total_Live = sum(Aboveground_Total_Live) / n()) |>
#  ungroup() |>
  mutate(Series = paste0("Projection, n=", n_distinct(StandID))) |>
  union_all(
    cfigro_srvy_carbon |>
#      group_by(Year) |>
#      summarize(Aboveground_Total_Live = sum(Aboveground_Total_Live) / n()) |>
#      ungroup() |>
      mutate(Series = paste0("Reference, n=", n_distinct(StandID)))
  ) |>
  mutate(Year = as.character(Year)) |>
  ggplot(aes(Year, Aboveground_Total_Live, fill = Series)) +
  geom_boxplot(outlier.size = 0.5) +
  theme_bw() +
  ggtitle("CFI Grow-Only Projection") +
  ylab(bquote("Aboveground Live Carbon " ~ (`Mg C` %.% hectare^-1)))
```

## Error Model

We need:
cfigro_bai_task$select(
  c("Acer_rubrum", "LAT", "Pinus_strobus", "Projected_BA", "Projected_Tph", "Quercus_rubra", "SLOPE")
)

```{r cficop modeled error, eval = FALSE}
tmp_top_species <- c("Acer rubrum", "Pinus strobus", "Quercus rubra")

tmp_species_cmp <- fvs_species_composition(cficop_none) |>
  filter(Year == 2020) |>
  mutate(SpeciesCode = as.numeric(SpeciesFIA)) |>
  # Combine black oak and red oak
  mutate(
    SpeciesCode = if_else(SpeciesCode == 837, 833, SpeciesCode)
  ) |>
  group_by(StandID, Year, SpeciesCode, random_seed) |>
  summarize(BA = sum(BA), TPA = sum(TPA), .groups = "drop") |>
  left_join(
    species_crosswalk |> select(SPCD, SCIENTIFIC_NAME),
    by = join_by(SpeciesCode == SPCD)
  ) |>
  mutate(
    TPH = conv_unit(TPA, "hectare", "acre"),
    BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare"),
  )

tmp_by_plot <- tmp_species_cmp |>
  group_by(StandID, random_seed) |>
  summarize(
    TPA = sum(TPA),
    BA = sum(BA),
    .groups = "drop"
  )

# Top species by plot
# (only considering tmp_top_species)
tmp_plot_species <- tmp_species_cmp |>
  group_by(StandID, SCIENTIFIC_NAME, random_seed) |>
  summarize(BA = sum(BA), .groups = "drop") |>
  ungroup() |>
  left_join(
    tmp_by_plot |>
      select(StandID, random_seed, BA_Plot = BA),
    by = join_by(StandID, random_seed)
  ) |>
  mutate(BA_Frac = BA / BA_Plot) |>
  filter(SCIENTIFIC_NAME %in% tmp_top_species) |>
  mutate(
    SCIENTIFIC_NAME = sub(" ", "_", SCIENTIFIC_NAME)
  ) |>
  pivot_wider(
    id_cols = c("StandID", "random_seed"),
    names_from = SCIENTIFIC_NAME,
    values_from = BA_Frac,
    values_fill = 0
  )

# cficop_none_summary aggregates over random_seed; we need random_seed
# in the output.
tmp_none_summary <- fvs_read_output(cficop_none, "FVS_Summary2_East")

tmp_plot_starting_ba <- tmp_none_summary |>
  filter(Year == 1970) |>
  mutate(
    Starting_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare"),
    Starting_Tph = conv_unit(Tpa, "hectare", "acre")
  ) |>
  select(StandID, random_seed, Starting_BA, Starting_Tph)

tmp_plot_projected_ba <- tmp_none_summary |>
  filter(Year == 2020) |>
  mutate(
    Projected_BA = conv_multiunit(BA, "ft2 / acre", "m2 / hectare"),
    Projected_Tph = conv_unit(Tpa, "hectare", "acre")
  ) |>
  select(StandID, random_seed, Projected_BA, Projected_Tph)

# cficop_none_carbon aggregates over random_seed; we need random_seed
# in the output.
tmp_none_carbon <- fvs_read_output(cficop_none, "FVS_Carbon")

tmp_plot_starting_carbon <- tmp_none_carbon |>
  filter(Year == 1970) |>
  rename(Starting_Carbon = Aboveground_Total_Live) |>
  select(StandID, random_seed, Starting_Carbon)

tmp_plot_projected_carbon <- tmp_none_carbon |>
  filter(Year == 2020) |>
  rename(Projected_Carbon = Aboveground_Total_Live) |>
  select(StandID, random_seed, Projected_Carbon)

cficop_none_bai <- tmp_plot_species |>
  left_join(
    cfigro_plot |>
      filter(INV_YEAR == 1970) |>
      mutate(StandID = as.character(STAND_ID)) |>
      select(StandID, LAT = LATITUDE, ASPECT, SLOPE, ELEV = ELEVFT),
    by = join_by(StandID)
  ) |>
  left_join(
    tmp_plot_starting_ba,
    by = join_by(StandID, random_seed)
  ) |>
  left_join(
    tmp_plot_projected_ba,
    by = join_by(StandID, random_seed)
  ) |>
  left_join(
    tmp_plot_starting_carbon,
    by = join_by(StandID, random_seed)
  ) |>
  left_join(
    tmp_plot_projected_carbon,
    by = join_by(StandID, random_seed)
  ) |>
  mutate(
    BAI_Error = cfigro_bai_model$predict_newdata(pick(everything()))$response,
    Carbon_Flux_Error = cfigro_aglcf_model$predict_newdata(pick(everything()))$response
  ) |>
  mutate(
    Projected_BAI = (Projected_BA - Starting_BA) / (2020 - 1970),
    Adjusted_BAI = Projected_BAI - BAI_Error,
    Projected_AGLCF = (Projected_Carbon - Starting_Carbon) / (2020 - 1970),
    Adjusted_AGLCF = Projected_AGLCF - Carbon_Flux_Error
  )
```

Plot it:

```{r plot cficop none bai, eval = FALSE}
cficop_none_bai |>
  rename(
    `FVS Projected` = Projected_BAI,
    `Corrected` = Adjusted_BAI
  ) |>
  pivot_longer(c("FVS Projected", "Corrected")) |>
  ggplot(aes(value, fill = name)) +
  geom_density(alpha = 0.5) +
  theme_bw() +
  scale_fill_discrete(name = "Series") +
  xlab(bquote("Basal Area Increment" ~ (m^2 %.% hectare^-1 %.% year^-1))) +
  ylab("Density") +
  ggtitle("CFI Quabbin All Plots 50 year BAI Projection")
```

```{r plot cficop none aglcf, eval = FALSE}
cficop_none_bai |>
  rename(
    `FVS Projected` = Projected_AGLCF,
    `Corrected` = Adjusted_AGLCF
  ) |>
  pivot_longer(c("FVS Projected", "Corrected")) |>
  ggplot(aes(value, fill = name)) +
  geom_density(alpha = 0.5) +
  theme_bw() +
  scale_fill_discrete(name = "Series") +
  xlab(bquote("Aboveground Live Carbon Flux" ~ (`Mg C` %.% hectare^-1 %.% year^-1))) +
  ylab("Density") +
  ggtitle("CFI Quabbin All Plots 50 year Aboveground Live Carbon Flux Projection")
```

## Carbon on the Landscape

What does this mean for total carbon on the landscape?

I think we just multiply the FVS projected vs. corrected AGLCF times years
times acres (converted to hectares).

```{r projected vs corrected carbon, eval = FALSE}
projected_vs_corrected_carbon <- cficop_none_bai |>
  left_join(
    cficop_sam_wt |> mutate(StandID = as.character(MasterPlotID)),
    by = join_by(StandID)
  ) |>
  mutate(
    HectaresPerPlot = conv_unit(AcresPerPlot, "acre", "hectare"),
    StartingCarbon = Starting_Carbon * HectaresPerPlot,
    ProjectedCarbon = Projected_AGLCF * (2020 - 1970) * HectaresPerPlot,
    CorrectedCarbon = Adjusted_AGLCF * (2020 - 1970) * HectaresPerPlot
  ) |>
  group_by(random_seed) |>
  summarize(
    StartingCarbon = sum(StartingCarbon),
    ProjectedCarbon = sum(ProjectedCarbon),
    CorrectedCarbon = sum(CorrectedCarbon),
    CarbonError = (ProjectedCarbon - CorrectedCarbon) / ((ProjectedCarbon + CorrectedCarbon) / 2),
    CarbonGrowthError = (ProjectedCarbon - CorrectedCarbon) / (ProjectedCarbon - StartingCarbon)
  )

projected_vs_corrected_carbon
```

```{r plot projected vs corrected carbon, eval = FALSE}
projected_vs_corrected_carbon |>
  pivot_longer(c("StartingCarbon", "ProjectedCarbon", "CorrectedCarbon")) |>
  mutate(name = ordered(name, levels = c("StartingCarbon", "ProjectedCarbon", "CorrectedCarbon"))) |>
  ggplot(aes(name, value)) +
  geom_boxplot() +
  theme_bw() +
  ggtitle("CFI Quabbin Plots 50-year Grow-Only Carbon Projection") +
  xlab(label = NULL) +
  ylab(bquote("Aboveground Live Carbon" ~ (`Mg C`))) +
  scale_fill_viridis_d() +
  scale_y_continuous(limits = c(0, NA), n.breaks = 6)
```

So, it over-projects by 22.2+-0.3%

