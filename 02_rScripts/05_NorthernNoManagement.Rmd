---
title: "Nunery Keeton Revisited"
author: "Nikolaus Bates-Haus"
output:
  pdf_document: default
  html_document: default
editor_options:
  markdown:
    wrap: 72
---

```{r setup, include=FALSE}
# Pre-load libraries that issue warnings on startup so these
# warnings don't corrupt the text later.
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(reshape2)) # for melt()
suppressPackageStartupMessages(library(RSQLite))
suppressPackageStartupMessages(library(htmltools))
suppressPackageStartupMessages(library(rmarkdown))
suppressPackageStartupMessages(library(dbplyr))
suppressPackageStartupMessages(library(measurements))
```

## Grow-Only Plots in the Northeast

Find all FIA plots in the northeastern region that are grow-only, that have
a measurement year between 1999 and 2004. We select 1999 becasue FIA changed
to the 4-subplot structure in 1999; we select 2004 so that we will have
at least 20 years of growth.

Northeastern region:

*  SURVEY.RCSD == 24

Grow-only is described previously:

*  Only one condition: max(FIA.COND.CONDID) == 1
*  Survey was not skipped: COND.COND_STATUS_CD == 1
*  Plot was not disturbed: COND.DSTRBCD1 == 0 & COND.DSTRBCD2 == 0 & COND.DSTRBCD3 == 0
*  Plot was not treated: COND.TRTCD1 == 0 & TRTCD2 == 0 & TRTCD3 == 0

```{r}
fia <- DBI::dbConnect(RSQLite::SQLite(), '../00_rawData/SQLite_FIADB_ENTIRE.db')
fia_cond <- tbl(fia, 'COND')
fia_plot <- tbl(fia, 'PLOT') |>
  # Narrow and rename columns to facilitate join
  select(CN, SRV_CN, MEASYEAR) |>
  rename(PLT_CN = CN)
fia_survey <- tbl(fia, 'SURVEY') |>
  # Narrow and rename columns to facilitate join
  select(CN, RSCD) |>
  rename(SRV_CN = CN)

plot_grow_only <- fia_cond |>
  filter(INVYR >= 1999) |>
  left_join(fia_plot, by = join_by(PLT_CN)) |>
  left_join(fia_survey, by = join_by(SRV_CN)) |>
  filter(RSCD == 24) |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    FIRST_MEASYEAR = min(MEASYEAR, na.rm = TRUE),
    CONDID = max(CONDID, na.rm = TRUE),
    COND_STATUS_CD = max(COND_STATUS_CD, na.rm = TRUE),
    DSTRBCD1 = max(DSTRBCD1, na.rm = TRUE),
    DSTRBCD2 = max(DSTRBCD2, na.rm = TRUE),
    DSTRBCD3 = max(DSTRBCD3, na.rm = TRUE),
    TRTCD1 = max(TRTCD1, na.rm = TRUE),
    TRTCD2 = max(TRTCD2, na.rm = TRUE),
    TRTCD3 = max(TRTCD3, na.rm = TRUE),
    .groups = "keep"
  ) |>
  ungroup() |>
  filter(FIRST_MEASYEAR <= 2004) |>
  filter(CONDID == 1) |>
  filter(COND_STATUS_CD == 1) |>
  filter(
    (is.na(DSTRBCD1) | DSTRBCD1 == 0) & 
    (is.na(DSTRBCD2) | DSTRBCD2 == 0) &
    (is.na(DSTRBCD3) | DSTRBCD3 == 0)
  ) |>
  filter(
    (is.na(TRTCD1) | TRTCD1 == 0) &
    (is.na(TRTCD2) | TRTCD2 == 0) &
    (is.na(TRTCD3) | TRTCD3 == 0)
  ) |>
  select(STATECD, COUNTYCD, PLOT) |>
  collect()

DBI::dbDisconnect(fia)
remove(fia, fia_cond, fia_plot, fia_survey)

length(plot_grow_only$PLOT)
```

This filters to 2609 plots, most of which will have multiple inventories.
 
### FIA Carbon and BALIVE

We can gather BALIVE and CARBON_AG for these plots over time.

```{r}
fia <- DBI::dbConnect(RSQLite::SQLite(), '../00_rawData/SQLite_FIADB_ENTIRE.db')

measyear <- tbl(fia, 'PLOT') |>
  select(STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR)

forest_type <- tbl(fia, 'REF_FOREST_TYPE') |>
  select(VALUE, MEANING) |>
  rename(FORTYPCD = VALUE) |>
  rename(FORTYPE = MEANING)

tree_stats <- tbl(fia, 'TREE') |>
  group_by(STATECD, COUNTYCD, PLOT, CONDID, INVYR) |>
  summarize(
    CARBON_AG = sum(CARBON_AG, na.rm = TRUE),
    CPA = sum(CARBON_AG * TPA_UNADJ, na.rm = TRUE),
    .groups = "keep"
  )

stand_stats <- tbl(fia, 'COND') |>
  select(STATECD, COUNTYCD, PLOT, INVYR, STDAGE, BALIVE, FORTYPCD) |>
  filter(INVYR >= 1999) |>
  semi_join(plot_grow_only, by = join_by(STATECD, COUNTYCD, PLOT), copy = TRUE) |>
  group_by(STATECD, COUNTYCD, PLOT, INVYR) |>
  summarize(
    BALIVE = sum(BALIVE, na.rm = TRUE),
    FORTYPCD = max(FORTYPCD, na.rm = TRUE),
    STDAGE = max(STDAGE, na.rm = TRUE),
    .groups = "keep"
  ) |>
  left_join(measyear, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
  left_join(tree_stats, by = join_by(STATECD, COUNTYCD, PLOT, INVYR)) |>
  filter(!is.na(CARBON_AG)) |>
  left_join(forest_type, by = join_by(FORTYPCD)) |>
  rename(`Forest Type` = FORTYPE) |>
  mutate(FORTYPCD = floor(FORTYPCD / 10) * 10) |>
  left_join(forest_type, by = join_by(FORTYPCD)) |>
  rename(`Forest Type Group` = FORTYPE) |>
  collect() |>
  mutate(BALIVE_METRIC = conv_multiunit(BALIVE, "ft2 / acre", "m2 / hectare")) |>
  mutate(CARBON_METRIC = conv_multiunit(CPA, "lbs / acre", "Mg / hectare"))

DBI::dbDisconnect(fia)
remove(fia, measyear, forest_type, tree_stats)
```

Look at BA over time

```{r}
ggplot(
    data = stand_stats |> filter(STDAGE > 0),
    mapping = aes(x = STDAGE, y = BALIVE_METRIC)
  ) +
  geom_point(alpha = 0.25) +
  facet_wrap(~`Forest Type Group`) +
  ggtitle("Grow-Only Stands\nFIA Measured basal area (m2 / ha)")
```

```{r}
latest_measyear <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    MEASYEAR = max(MEASYEAR),
    .groups = "keep"
  ) |>
  ungroup()

seen_types <- stand_stats |>
  semi_join(latest_measyear, by = join_by(STATECD, COUNTYCD, PLOT, MEASYEAR)) |>
  group_by(`Forest Type`) |>
  summarize(
    CARBON_AG_METRIC = sum(conv_unit(CARBON_AG, "lbs", "Mg")),
    .groups = "keep"
  )

seen_types |>
  ggplot(
    aes(y = fct_reorder(`Forest Type`, CARBON_AG_METRIC), x = CARBON_AG_METRIC)
  ) +
  scale_x_log10() +
  geom_col() +
  ggtitle("Total Carbon by Forest Type (Mg)") +
  ylab("Forest Type") +
  xlab("Carbon")
```

## Run FVS

### Generate Keyfile

An FVS run is scripted by a keyfile. The keyfile describes how to run the
model and extensions, including where to read input, all parameters to
control processing, and where to write output.

The keyfile is structured by stand; each stand is a separate run of the
model.

To run in parallel, a separate keyfile must be generated for each partition
to be run in parallel. Each partition must send its output to a separate
location, and these can be assembled into a single output as a post-
processing step.

#### Stand Identification

For each stand, we need:

-  StdIdent: Stand Identifier, from fia.FVS_STANDINIT_PLOT.FVS_STAND_ID
-  StandCN: Stand control number, from fia.PLOT.CN
-  MgmtId: Management ID, for no treatment, this is NONE

#### Time

We will run the model from first measurement year to 2024, with a 1-year timestep.

-  InvYear: Inventory Year, this is the first fia.PLOT.MEASYEAR
-  TimeInt: Time Interval, set this to 1 for all timesteps
-  NumCycle: Number of cycles to run, 2024 - InvYear

#### Input

There are two inputs, Stand and Tree. Both are configured to use a database
query.

Within a Database subsection:

-  DSNIn: Data Source Name (DSN) for input; SQLite filename
-  StandSQL: SQL query to fetch a stand, given %Stand_CN%
-  TreeSQL: SQL query to fetch all trees for a stand, given %Stand_CN%

#### Fire and Fuels

Carbon is calculated by the fire and fuels extension.

-  FMIn: Starts configuration of Fire and Fuels extension
-  CarbRept: Carbon Report; save to database (2)
-  CarbCut: Harvested Carbon Report; disable (0)
-  CarbCalc: Carbon calculation; metric (1)
-  FuelOut: Fuel Output, disable (0)
-  FuelRept: Fuel Report, disable (0)

Fire and Fuels also interacts with the database extension; it provides additional
Database keywords to configure Fire and Fuels output to the database.

Within a Database section:

-  CarbReDB: FVS_Carbon and FVS_Hrv_Carbon tables: database (2)
-  FuelReDB: FVS_Consumption table: database (2)
-  FuelsOut: FVS_Fuels table: database (2)

#### Output

We use database output; it is easiest to work with. Many output options take
a parameter that is 0 to disable output, 1 for file output, 2 for database
output, and 3 for both file and database output.

Within a Database section:

-  DSNOut: Data Source Name (DSN) for output; SQLite filename
-  Summary: Configure FVS_Summary; use version 2
-  Computdb: Configure FVS_Compute; disable
-  MisRpts: Configure Mistletoe reports; disable

#### Processing Order

Each stand has its own section of the keyword file, including everything from
StdIdent to Process. Each stand is processed before moving to the next stand.

At the end of all stands, the Stop keyword tells FVS to exit cleanly.

#### Example

```
StdIdent
230202502686        NoManagement
StandCN
52967848010538
MgmtId
NONE
InvYear         2002
TimeInt            0         1
NumCycle           1

FMIn
CarbRept           2
CarbCut            2
CarbCalc           0         1    0.0425         9        11
FuelOut            2
FuelRept           2
End

Database

DSNIn
SQLite_FIADB_ENTIRE.db

StandSQL
SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL

TreeSQL
SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'
EndSQL

DSNOut
FVS_Out.db

Summary            2
Computdb           0         1
MisRpts            2
CarbReDB           2
FuelReDB           2
FuelsOut           2

END

Process

Stop
```

#### Generation

Gather stand IDs and CNs for keywordfile generation.

```{r}
first_measyear <- stand_stats |>
  group_by(STATECD, COUNTYCD, PLOT) |>
  summarize(
    INVYR = min(INVYR),
    MEASYEAR = min(MEASYEAR, na.rm = TRUE),
    .groups = "keep"
  ) |>
  ungroup()


fia <- DBI::dbConnect(RSQLite::SQLite(), '../00_rawData/SQLite_FIADB_ENTIRE.db')
fia_fvs_standinit_plot <- tbl(fia, 'FVS_StandInit_Plot') |>
  select(STAND_CN, STAND_ID)

keywordfile_stands <- tbl(fia, 'PLOT') |>
  select(CN, STATECD, COUNTYCD, PLOT, INVYR, MEASYEAR) |>
  filter(INVYR >= 1999) |>
  rename(STAND_CN = CN) |>
  semi_join(first_measyear, by = join_by(STATECD, COUNTYCD, PLOT, INVYR), copy = TRUE) |>
  left_join(fia_fvs_standinit_plot, by = join_by(STAND_CN)) |>
  collect()

DBI::dbDisconnect(fia)
remove(fia, fia_fvs_standinit_plot)
```

A function to generate a keywordfile section from information about a stand.

> TODO nik: All FVS files should probably be named by:
> -  Title; NoManagement
> -  MgmtId; NONE
> -  Partition
> -  File type
> So,
> NoManagement_NONE_part1.key
> NoManagement_NONE_part1.db
> etc.

```{r}
keywordfile_section <- function(StandID, StandCN, MeasYear, Partition) {
  MeasYear <- as.integer(MeasYear)
  paste0(
"StdIdent\n",
StandID, "        NoManagement\n",
"StandCN\n",
StandCN, "\n",
"MgmtId\n",
"NONE\n",
"InvYear   ", sprintf('%10s', MeasYear), "\n",
"TimeInt            0         1\n",
"NumCycle  ", sprintf('%10d', 2025 - MeasYear), "\n",
"FMIn\n",
"CarbRept           2\n",
"CarbCut            2\n",
"CarbCalc           0         1    0.0425         9        11\n",
"FuelOut            2\n",
"FuelRept           2\n",
"End\n",
"Database\n",
"DSNIn\n",
"SQLite_FIADB_ENTIRE.db\n",
"StandSQL\n",
"SELECT * FROM FVS_StandInit_Plot WHERE Stand_CN = '%Stand_CN%'\n",
"EndSQL\n",
"TreeSQL\n",
"SELECT * FROM FVS_TreeInit_Plot WHERE Stand_CN = '%Stand_CN%'\n",
"EndSQL\n",
"DSNOut\n",
"FVS_Out_", Partition, ".db\n",
"Summary            2\n",
"Computdb           0         1\n",
"MisRpts            2\n",
"CarbReDB           2\n",
"FuelReDB           2\n",
"FuelsOut           2\n",
"End\n",
"Process\n"
  )
}

```

Generate a keywordfile per partition, distributing across partitions using
STAND_ID. 

```{r}
for (partition in 1:8) {
  filename <- paste0("NONE_partition_", partition, ".key")
  write_lines(
    apply(
      keywordfile_stands |> filter((as.numeric(STAND_ID) %% 8) == (partition - 1)),
      1,
      function(row) {
        keywordfile_section(row['STAND_ID'], row['STAND_CN'], row['MEASYEAR'], partition)
      }
    ),
    filename
  )
  write_lines("Stop", filename, append = TRUE)
}
```

Run FVS.

```{r}
# TODO nik: Run FVS from in R.
# Batch file to run FVS in parallel:
# for %%p in (NONE_Partition_*.key) do start \FVS\FVSbin\FVSne.exe --keywordfile=%%p
```


